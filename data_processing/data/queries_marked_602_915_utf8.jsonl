{"instruction":"Optimize the SQL query","input":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1;","output":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE serial_number = 'ABC123' AND pharmacies_id = 456;","output":"SELECT * FROM assets WHERE serial_number = 'ABC123' AND pharmacies_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL '1 week';","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE facility_id = 789;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE facility_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-07-01' AND '2023-07-31';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-07-01' AND '2023-07-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND is_open = 1;","output":"SELECT * FROM events WHERE events_type_id = 123 AND is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE roles_id = 789 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW();","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW();"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123;","output":"SELECT * FROM pharmacies WHERE activated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT id, full_name FROM staff_directory WHERE org_id = 123;","output":"SELECT id, full_name FROM staff_directory WHERE org_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456;","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE name = 'Fire Hazard' AND description = 'High risk of fire outbreak.';","output":"SELECT * FROM hazards WHERE name = 'Fire Hazard' AND description = 'High risk of fire outbreak.';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE forms_id = 789 AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE forms_id = 789 AND is_default = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_at >= NOW() - INTERVAL '1 week';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id = 789 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = 789 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND is_open = 1;","output":"SELECT * FROM events WHERE users_id = 123 AND is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1;","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND city = 'New York';","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND city = 'New York';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM pharmacies WHERE activated_by >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT user_id, full_name FROM staff_directory WHERE is_active = 1 AND org_id = 123;","output":"SELECT user_id, full_name FROM staff_directory WHERE is_active = 1 AND org_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE created_at >= NOW() - INTERVAL '30 days' OR updated_at >= NOW() - INTERVAL '30 days';","output":"SELECT * FROM assets WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' OR updated_at >= CURRENT_DATE - INTERVAL '30 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months';","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days';","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London';","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND updated_at >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND updated_at >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months' ORDER BY name ASC;","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days' ORDER BY events_type_id ASC;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days' ORDER BY events_type_id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London' ORDER BY trial_ends_at DESC;","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London' ORDER BY trial_ends_at DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND reg_number IS NOT NULL;","output":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND reg_number IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND updated_at >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND updated_at >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months' ORDER BY name ASC LIMIT 10;","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months' ORDER BY name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0 ORDER BY order DESC;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0 ORDER BY \"order\" DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 20;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days' ORDER BY events_type_id ASC LIMIT 50;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days' ORDER BY events_type_id ASC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND updated_at >= NOW() - INTERVAL '3 months';","output":"SELECT full_name, id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND updated_at >= CURRENT_DATE - INTERVAL '3 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND serial_number LIKE 'ABC%';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND serial_number LIKE 'ABC%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%fire%' AND created_at >= NOW() - INTERVAL '6 months' ORDER BY created_at DESC;","output":"SELECT * FROM hazards WHERE description LIKE '%fire%' AND created_at >= CURRENT_DATE - INTERVAL '6 months' ORDER BY created_at DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND name NOT LIKE '%Admin%';","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND name NOT LIKE '%Admin%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 50;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC LIMIT 10;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '1 month' ORDER BY events_type_id ASC LIMIT 20;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '1 month' ORDER BY events_type_id ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT id, full_name FROM staff_directory WHERE official_user_id IS NOT NULL AND org_id = 123 AND is_active = 1;","output":"SELECT id, full_name FROM staff_directory WHERE official_user_id IS NOT NULL AND org_id = 123 AND is_active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name FROM staff_directory WHERE official_user_id IS NOT NULL;","output":"SELECT full_name FROM staff_directory WHERE official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) > 100;","output":"SELECT * FROM hazards WHERE LENGTH(description) > 100;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, `order` FROM event_staff_roles ORDER BY name ASC;","output":"SELECT name, \"order\" FROM event_staff_roles ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE updated_by = 123;","output":"SELECT * FROM event_actions WHERE updated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE is_open = 1;","output":"SELECT * FROM events WHERE is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE type = 'admin' AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE type = 'admin' AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE city = 'New York';","output":"SELECT * FROM organizations WHERE city = 'New York';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123;","output":"SELECT * FROM pharmacies WHERE activated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE 'ABC%';","output":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE 'ABC%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL 30 DAYS AND organizations_id = 789;","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND organizations_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory ORDER BY full_name ASC;","output":"SELECT full_name, id FROM staff_directory ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456;","output":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= NOW() - INTERVAL 6 MONTHS;","output":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= CURRENT_DATE - INTERVAL '6 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE `order` = 1;","output":"SELECT * FROM event_staff_roles WHERE \"order\" = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456;","output":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456;","output":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1;","output":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123;","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01';","output":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS AND organizations_id = 123;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days' AND organizations_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456;","output":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, `order` FROM event_staff_roles ORDER BY `order` DESC;","output":"SELECT name, \"order\" FROM event_staff_roles ORDER BY \"order\" DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE updated_by = 123 AND date_created > '2023-01-01';","output":"SELECT * FROM event_actions WHERE updated_by = 123 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id = 123 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = 123 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE is_open = 1 AND users_id = 123;","output":"SELECT * FROM events WHERE is_open = 1 AND users_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE type = 'admin' AND date_created BETWEEN '2023-01-01' AND '2023-01-31';","output":"SELECT * FROM users WHERE type = 'admin' AND date_created BETWEEN '2023-01-01' AND '2023-01-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE city = 'London' AND date_created > '2023-01-01';","output":"SELECT * FROM organizations WHERE city = 'London' AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123 AND date_created < '2023-01-01';","output":"SELECT * FROM pharmacies WHERE activated_by = 123 AND date_created < '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE '%XYZ';","output":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE '%XYZ';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL 30 DAYS AND organizations_id = 123;","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND organizations_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory ORDER BY id ASC;","output":"SELECT full_name, id FROM staff_directory ORDER BY id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456 AND serial_number = 'XYZ';","output":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456 AND serial_number = 'XYZ';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= NOW() - INTERVAL 6 MONTHS ORDER BY name ASC;","output":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= CURRENT_DATE - INTERVAL '6 months' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE `order` = 1 AND forms_id = 123;","output":"SELECT * FROM event_staff_roles WHERE \"order\" = 1 AND forms_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456 AND action_date BETWEEN '2023-01-01' AND '2023-12-31';","output":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456 AND action_date BETWEEN '2023-01-01' AND '2023-12-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456 AND date_closed >= NOW() - INTERVAL 1 MONTH;","output":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;","output":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123 AND trial_ends_at > NOW();","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123 AND trial_ends_at > NOW();"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01' AND activated_by = 456;","output":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01' AND activated_by = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS AND organizations_id = 123 AND asset_type_id = 456;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days' AND organizations_id = 123 AND asset_type_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456 AND organizations_id = 789;","output":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456 AND organizations_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1;","output":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE serial_number = 'ABC123' AND pharmacies_id = 456;","output":"SELECT * FROM assets WHERE serial_number = 'ABC123' AND pharmacies_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL '1 week';","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE facility_id = 789;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE facility_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-07-01' AND '2023-07-31';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-07-01' AND '2023-07-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND is_open = 1;","output":"SELECT * FROM events WHERE events_type_id = 123 AND is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE roles_id = 789 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW();","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW();"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123;","output":"SELECT * FROM pharmacies WHERE activated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT id, full_name FROM staff_directory WHERE org_id = 123;","output":"SELECT id, full_name FROM staff_directory WHERE org_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456;","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE name = 'Fire Hazard' AND description = 'High risk of fire outbreak.';","output":"SELECT * FROM hazards WHERE name = 'Fire Hazard' AND description = 'High risk of fire outbreak.';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE forms_id = 789 AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE forms_id = 789 AND is_default = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_at >= NOW() - INTERVAL '1 week';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id = 789 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = 789 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND is_open = 1;","output":"SELECT * FROM events WHERE users_id = 123 AND is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1;","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND city = 'New York';","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND city = 'New York';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM pharmacies WHERE activated_by >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT user_id, full_name FROM staff_directory WHERE is_active = 1 AND org_id = 123;","output":"SELECT user_id, full_name FROM staff_directory WHERE is_active = 1 AND org_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE created_at >= NOW() - INTERVAL '30 days' OR updated_at >= NOW() - INTERVAL '30 days';","output":"SELECT * FROM assets WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' OR updated_at >= CURRENT_DATE - INTERVAL '30 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months';","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days';","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London';","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND updated_at >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND updated_at >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months' ORDER BY name ASC;","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days' ORDER BY events_type_id ASC;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days' ORDER BY events_type_id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London' ORDER BY trial_ends_at DESC;","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London' ORDER BY trial_ends_at DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND reg_number IS NOT NULL;","output":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND reg_number IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND updated_at >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND updated_at >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months' ORDER BY name ASC LIMIT 10;","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months' ORDER BY name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0 ORDER BY order DESC;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0 ORDER BY \"order\" DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 20;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days' ORDER BY events_type_id ASC LIMIT 50;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days' ORDER BY events_type_id ASC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND updated_at >= NOW() - INTERVAL '3 months';","output":"SELECT full_name, id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND updated_at >= CURRENT_DATE - INTERVAL '3 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND serial_number LIKE 'ABC%';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND serial_number LIKE 'ABC%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%fire%' AND created_at >= NOW() - INTERVAL '6 months' ORDER BY created_at DESC;","output":"SELECT * FROM hazards WHERE description LIKE '%fire%' AND created_at >= CURRENT_DATE - INTERVAL '6 months' ORDER BY created_at DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND name NOT LIKE '%Admin%';","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND name NOT LIKE '%Admin%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 50;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC LIMIT 10;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '1 month' ORDER BY events_type_id ASC LIMIT 20;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '1 month' ORDER BY events_type_id ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT id, full_name FROM staff_directory WHERE official_user_id IS NOT NULL AND org_id = 123 AND is_active = 1;","output":"SELECT id, full_name FROM staff_directory WHERE official_user_id IS NOT NULL AND org_id = 123 AND is_active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name FROM staff_directory WHERE official_user_id IS NOT NULL;","output":"SELECT full_name FROM staff_directory WHERE official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) > 100;","output":"SELECT * FROM hazards WHERE LENGTH(description) > 100;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, `order` FROM event_staff_roles ORDER BY name ASC;","output":"SELECT name, \"order\" FROM event_staff_roles ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE updated_by = 123;","output":"SELECT * FROM event_actions WHERE updated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE is_open = 1;","output":"SELECT * FROM events WHERE is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE type = 'admin' AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE type = 'admin' AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE city = 'New York';","output":"SELECT * FROM organizations WHERE city = 'New York';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123;","output":"SELECT * FROM pharmacies WHERE activated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE 'ABC%';","output":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE 'ABC%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL 30 DAYS AND organizations_id = 789;","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND organizations_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory ORDER BY full_name ASC;","output":"SELECT full_name, id FROM staff_directory ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456;","output":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= NOW() - INTERVAL 6 MONTHS;","output":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= CURRENT_DATE - INTERVAL '6 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE `order` = 1;","output":"SELECT * FROM event_staff_roles WHERE \"order\" = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456;","output":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456;","output":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1;","output":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123;","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01';","output":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS AND organizations_id = 123;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days' AND organizations_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456;","output":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, `order` FROM event_staff_roles ORDER BY `order` DESC;","output":"SELECT name, \"order\" FROM event_staff_roles ORDER BY \"order\" DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE updated_by = 123 AND date_created > '2023-01-01';","output":"SELECT * FROM event_actions WHERE updated_by = 123 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id = 123 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = 123 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE is_open = 1 AND users_id = 123;","output":"SELECT * FROM events WHERE is_open = 1 AND users_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE type = 'admin' AND date_created BETWEEN '2023-01-01' AND '2023-01-31';","output":"SELECT * FROM users WHERE type = 'admin' AND date_created BETWEEN '2023-01-01' AND '2023-01-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE city = 'London' AND date_created > '2023-01-01';","output":"SELECT * FROM organizations WHERE city = 'London' AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123 AND date_created < '2023-01-01';","output":"SELECT * FROM pharmacies WHERE activated_by = 123 AND date_created < '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE '%XYZ';","output":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE '%XYZ';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL 30 DAYS AND organizations_id = 123;","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND organizations_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory ORDER BY id ASC;","output":"SELECT full_name, id FROM staff_directory ORDER BY id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456 AND serial_number = 'XYZ';","output":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456 AND serial_number = 'XYZ';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= NOW() - INTERVAL 6 MONTHS ORDER BY name ASC;","output":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= CURRENT_DATE - INTERVAL '6 months' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE `order` = 1 AND forms_id = 123;","output":"SELECT * FROM event_staff_roles WHERE \"order\" = 1 AND forms_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456 AND action_date BETWEEN '2023-01-01' AND '2023-12-31';","output":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456 AND action_date BETWEEN '2023-01-01' AND '2023-12-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456 AND date_closed >= NOW() - INTERVAL 1 MONTH;","output":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;","output":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123 AND trial_ends_at > NOW();","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123 AND trial_ends_at > NOW();"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01' AND activated_by = 456;","output":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01' AND activated_by = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS AND organizations_id = 123 AND asset_type_id = 456;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days' AND organizations_id = 123 AND asset_type_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456 AND organizations_id = 789;","output":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456 AND organizations_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND date_updated IS NOT NULL AND date_updated <> NULL AND LENGTH(type) > 0 AND CHAR_LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > CAST('2023-02-01' AS TEXT) AND countries_id IS NOT NULL AND countries_id <> NULL AND EXTRACT(YEAR FROM created_at) = 2023 AND EXTRACT(MONTH FROM created_at) >= 2;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND LOWER(city) = 'chicago' AND city LIKE '%Chicago%';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND LENGTH(user_id) = 5 AND user_id LIKE '13579%';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND active IS NOT NULL AND active = 1;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE is_default = CAST(true AS BOOLEAN) AND forms_id IS NOT NULL AND forms_id <> NULL AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE is_default = true AND forms_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(user_id AS TEXT) = '65432' AND updated_at IS NOT NULL AND updated_at <> NULL AND user_id::text LIKE '65432%';","output":"SELECT * FROM event_actions WHERE user_id = '65432' AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(facility_id AS TEXT) = '54321' AND CAST(organization_id AS TEXT) = '87654' AND tools_id IS NOT NULL AND tools_id <> NULL AND facility_id::text = '54321' AND organization_id::text = '87654';","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = '54321' AND organization_id = '87654' AND tools_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE ((harmt IS NOT NULL AND harmt <> NULL) OR (prescribers_id IS NOT NULL AND prescribers_id <> NULL)) AND is_open = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND date_closed IS NOT NULL AND date_closed <> NULL;","output":"SELECT * FROM events WHERE (harmt IS NOT NULL OR prescribers_id IS NOT NULL) AND is_open = true AND date_created IS NOT NULL AND date_closed IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) > '2023-04-01' AND updated_at IS NOT NULL AND updated_at <> NULL AND is_active = 1;","output":"SELECT * FROM users WHERE is_active = true AND updated_at > '2023-04-01' AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE UPPER(city) = UPPER('Denver') AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND LOWER(city) = 'denver';","output":"SELECT * FROM organizations WHERE city = 'Denver' AND trial_ends_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) = UPPER('Pharmacist D') AND activate_at IS NOT NULL AND activate_at <> NULL AND activated_by ILIKE 'Pharmacist D';","output":"SELECT * FROM pharmacies WHERE activated_by = 'Pharmacist D' AND activate_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '97531' AND employee_id IS NOT NULL AND employee_id <> NULL AND user_id::text = '97531';","output":"SELECT * FROM staff_directory WHERE user_id = '97531' AND employee_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND serial_number <> '' AND LENGTH(serial_number) > 0 AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND serial_number <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(name) = UPPER('Chemical Spill') AND description <> '' AND LENGTH(description) > 0 AND name ILIKE 'Chemical Spill';","output":"SELECT * FROM hazards WHERE name = 'Chemical Spill' AND description <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND \"order\" IS NOT NULL AND \"order\" <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND \"order\" IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '321' AND action_date IS NOT NULL AND action_date <> NULL AND date_done IS NOT NULL AND date_done <> NULL AND events_id::text = '321';","output":"SELECT * FROM event_actions WHERE events_id = '321' AND action_date IS NOT NULL AND date_done IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '876' AND CAST(facility_id AS TEXT) = '543' AND updated_by IS NOT NULL AND updated_by <> NULL AND updated_at IS NOT NULL AND updated_at <> NULL;","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '876' AND facility_id = '543' AND updated_by IS NOT NULL AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '987' AND date_created IS NOT NULL AND date_created <> NULL AND updated_by IS NOT NULL AND updated_by <> NULL AND harmt IS NOT NULL AND harmt <> NULL;","output":"SELECT * FROM events WHERE reporters_id = '987' AND date_created IS NOT NULL AND updated_by IS NOT NULL AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND sf_id IS NOT NULL AND sf_id <> NULL AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND is_active = true AND date_created IS NOT NULL AND sf_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-02-01' AND countries_id IS NOT NULL AND countries_id <> NULL AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND name <> '' AND LENGTH(name) > 0;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL AND trial_ends_at IS NOT NULL AND name <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND activated_by IS NOT NULL AND activated_by <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL AND activated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND fixed = CAST(true AS BOOLEAN) AND user_id::text = '13579';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL AND fixed = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND asset_type_id IS NOT NULL AND asset_type_id <> NULL AND active = 1;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL AND asset_type_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id IS NOT NULL AND pharmacies_id <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL AND pharmacies_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE is_default = CAST(true AS BOOLEAN) AND forms_id IS NOT NULL AND forms_id <> NULL AND facility_id IS NOT NULL AND facility_id <> NULL AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE is_default = true AND forms_id IS NOT NULL AND facility_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(user_id AS TEXT) = '65432' AND updated_at IS NOT NULL AND updated_at <> NULL AND user_pharmacy_id IS NOT NULL AND user_pharmacy_id <> NULL AND user_id::text = '65432';","output":"SELECT * FROM event_actions WHERE user_id = '65432' AND updated_at IS NOT NULL AND user_pharmacy_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(facility_id AS TEXT) = '54321' AND CAST(organization_id AS TEXT) = '87654' AND tools_id IS NOT NULL AND tools_id <> NULL AND updated_by IS NOT NULL AND updated_by <> NULL AND facility_id::text = '54321';","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = '54321' AND organization_id = '87654' AND tools_id IS NOT NULL AND updated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE ((harmt IS NOT NULL AND harmt <> NULL) OR (prescribers_id IS NOT NULL AND prescribers_id <> NULL)) AND is_open = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND date_closed IS NOT NULL AND date_closed <> NULL;","output":"SELECT * FROM events WHERE (harmt IS NOT NULL OR prescribers_id IS NOT NULL) AND is_open = true AND date_created IS NOT NULL AND date_closed IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) > '2023-03-01' AND type IS NOT NULL AND type <> NULL AND date_updated IS NOT NULL AND date_updated <> NULL AND is_active = 1;","output":"SELECT * FROM users WHERE is_active = true AND updated_at > '2023-03-01' AND type IS NOT NULL AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE UPPER(city) = UPPER('Seattle') AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND countries_id IS NOT NULL AND countries_id <> NULL AND city ILIKE 'seattle';","output":"SELECT * FROM organizations WHERE city = 'Seattle' AND trial_ends_at IS NOT NULL AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) = UPPER('Pharmacist B') AND activate_at IS NOT NULL AND activate_at <> NULL AND activated_by ILIKE 'Pharmacist B';","output":"SELECT * FROM pharmacies WHERE activated_by = 'Pharmacist B' AND activate_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '98765' AND created_at IS NOT NULL AND created_at <> NULL AND user_id::text = '98765';","output":"SELECT * FROM staff_directory WHERE user_id = '98765' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(asset_type_id AS TEXT) = '789' AND serial_number IS NOT NULL AND serial_number <> NULL AND asset_type_id::text = '789';","output":"SELECT * FROM assets WHERE asset_type_id = '789' AND serial_number IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '65432' AND description <> '' AND LENGTH(description) > 0 AND pharmacies_id::text = '65432';","output":"SELECT * FROM hazards WHERE pharmacies_id = '65432' AND description <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND \"order\" IS NOT NULL AND \"order\" <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND \"order\" IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '987' AND UPPER(updated_by) = UPPER('John Smith') AND events_id::text = '987' AND updated_by ILIKE 'John Smith';","output":"SELECT * FROM event_actions WHERE events_id = '987' AND updated_by = 'John Smith';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '543' AND UPPER(updated_by) = UPPER('Jane Doe') AND organization_id::text = '543' AND updated_by ILIKE 'Jane Doe';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '543' AND updated_by = 'Jane Doe';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '321' AND harmt IS NOT NULL AND harmt <> NULL AND reporters_id::text = '321';","output":"SELECT * FROM events WHERE reporters_id = '321' AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('Admin' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND LENGTH(type) = 5;","output":"SELECT * FROM users WHERE type = 'Admin' AND is_active = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-01-01' AND CAST(updated_at AS TEXT) < '2023-06-30' AND created_at IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-01-01' AND updated_at < '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Los Angeles') AND daye_enabled IS NOT NULL AND daye_enabled <> NULL AND city ILIKE 'los angeles';","output":"SELECT * FROM pharmacies WHERE city = 'Los Angeles' AND daye_enabled IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(full_name) = UPPER('Jane Doe') AND fixed = CAST(true AS BOOLEAN) AND full_name ILIKE 'Jane Doe';","output":"SELECT * FROM staff_directory WHERE full_name = 'Jane Doe' AND fixed = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) >= '2023-01-01' AND CAST(updated_at AS TEXT) <= '2023-06-30' AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND updated_at BETWEEN '2023-01-01' AND '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(name) LIKE UPPER('Chemical%') AND name IS NOT NULL;","output":"SELECT * FROM hazards WHERE name LIKE 'Chemical%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '789' AND CAST(facility_id AS TEXT) = '654' AND forms_id::text = '789' AND facility_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '789' AND facility_id = '654';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '987' AND UPPER(updated_by) = UPPER('John Smith') AND events_id::text = '987';","output":"SELECT * FROM event_actions WHERE events_id = '987' AND updated_by = 'John Smith';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '543' AND UPPER(updated_by) = UPPER('Jane Doe') AND organization_id::text = '543';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '543' AND updated_by = 'Jane Doe';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '321' AND harmt IS NOT NULL AND harmt <> NULL AND reporters_id::text = '321';","output":"SELECT * FROM events WHERE reporters_id = '321' AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND is_active = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-01-01' AND CAST(updated_at AS TEXT) < '2023-06-30' AND created_at IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-01-01' AND updated_at < '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND user_id::text = '13579';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND updates_by IS NOT NULL AND updates_by <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND updates_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '321' AND action_date IS NOT NULL AND action_date <> NULL AND events_id::text = '321';","output":"SELECT * FROM event_actions WHERE events_id = '321' AND action_date IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '876' AND CAST(facility_id AS TEXT) = '543' AND updated_by IS NOT NULL AND updated_by <> NULL AND organization_id::text = '876';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '876' AND facility_id = '543' AND updated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '987' AND date_created IS NOT NULL AND date_created <> NULL AND reporters_id::text = '987';","output":"SELECT * FROM events WHERE reporters_id = '987' AND date_created IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND date_updated IS NOT NULL AND date_updated <> NULL AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-02-01' AND countries_id IS NOT NULL AND countries_id <> NULL AND created_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(employee_id) LIKE UPPER('EMP-%') AND employee_id IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE employee_id LIKE 'EMP-%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(updated_at AS TEXT) > CAST((CURRENT_TIMESTAMP - INTERVAL '1 day') AS TEXT) AND updated_at IS NOT NULL;","output":"SELECT * FROM assets WHERE updated_at > (CURRENT_TIMESTAMP - INTERVAL '1 day');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies WHERE UPPER(name) LIKE UPPER('%Healthcare%') AND name IS NOT NULL);","output":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies WHERE name LIKE '%Healthcare%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE UPPER(name) LIKE UPPER('%Coordinator%') AND name IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE name LIKE '%Coordinator%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id IN (SELECT user_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE UPPER(role) = UPPER('Supervisor') AND role IS NOT NULL) AND user_id IS NOT NULL);","output":"SELECT * FROM event_actions WHERE user_id IN (SELECT user_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE role = 'Supervisor'));"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('S%') AND city IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'S%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE harmt IS NOT NULL AND harmt <> NULL AND reporters_id IN (SELECT users_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE UPPER(role) = UPPER('Admin') AND role IS NOT NULL) AND users_id IS NOT NULL);","output":"SELECT * FROM events WHERE harmt IS NOT NULL AND reporters_id IN (SELECT users_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE role = 'Admin'));"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(1 AS BOOLEAN) AND EXTRACT(DOW FROM updated_at) IN (1, 7) AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE is_active = 1 AND DAYOFWEEK(updated_at) IN (1, 7);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE sf_id IN (SELECT sf_id FROM organizations GROUP BY sf_id HAVING COUNT(DISTINCT countries_id) > 1 AND COUNT(DISTINCT countries_id) <> 0);","output":"SELECT * FROM organizations WHERE sf_id IN (SELECT sf_id FROM organizations GROUP BY sf_id HAVING COUNT(DISTINCT countries_id) > 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) LIKE UPPER('%Pharma%') AND organizations_id IN (SELECT organizations_id FROM organizations WHERE UPPER(address) LIKE UPPER('P%') AND address IS NOT NULL);","output":"SELECT * FROM pharmacies WHERE activated_by LIKE '%Pharma%' AND organizations_id IN (SELECT organizations_id FROM organizations WHERE address LIKE 'P%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(full_name) LIKE UPPER('%John%') AND UPPER(full_name) LIKE UPPER('%Doe%') AND full_name IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE full_name LIKE '%John%' AND full_name LIKE '%Doe%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id IN (SELECT MAX(CAST(asset_items_id AS BIGINT)) FROM assets WHERE asset_items_id IS NOT NULL);","output":"SELECT * FROM assets WHERE asset_items_id IN (SELECT MAX(asset_items_id) FROM assets);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies GROUP BY pharmacies_id ORDER BY COUNT(*) DESC, pharmacies_id ASC LIMIT 1);","output":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies GROUP BY pharmacies_id ORDER BY COUNT(*) DESC LIMIT 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE forms_id IN (SELECT forms_id FROM event_staff_roles GROUP BY forms_id ORDER BY COUNT(*) DESC, forms_id ASC);","output":"SELECT * FROM event_staff_roles WHERE forms_id IN (SELECT forms_id FROM event_staff_roles GROUP BY forms_id ORDER BY COUNT(*) DESC);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE EXTRACT(DOW FROM action_date) IN (5, 6) AND action_date IS NOT NULL;","output":"SELECT * FROM event_actions WHERE WEEKDAY(action_date) IN (5, 6);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE organization_id IN (SELECT organization_id FROM organizations WHERE UPPER(name) LIKE UPPER('%Institute%') AND name IS NOT NULL) AND facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('M%') AND city IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE organization_id IN (SELECT organization_id FROM organizations WHERE name LIKE '%Institute%') AND facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'M%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(harmt AS TEXT) = CAST(prescribers_id AS TEXT) AND harmt IS NOT NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE harmt = prescribers_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(date_created AS DATE) = CAST(updated_at AS DATE) AND date_created IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE DATE(date_created) = DATE(updated_at);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at IN (SELECT trial_ends_at FROM organizations GROUP BY trial_ends_at HAVING COUNT(*) > 1 AND COUNT(*) <> 0);","output":"SELECT * FROM organizations WHERE trial_ends_at IN (SELECT trial_ends_at FROM organizations GROUP BY trial_ends_at HAVING COUNT(*) > 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activate_at = CAST('specific_date' AS TIMESTAMP) AND activated_by = SUBSTRING(name, 1, 2) AND name IS NOT NULL;","output":"SELECT * FROM pharmacies WHERE activate_at = 'specific_date' AND activated_by = SUBSTRING(name, 1, 2);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE employee_id = REVERSE(employee_id) AND employee_id IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE employee_id = REVERSE(employee_id);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE serial_number ~ '[0-9]{3}' AND serial_number IS NOT NULL;","output":"SELECT * FROM assets WHERE serial_number REGEXP '[0-9]{3}';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE (UPPER(description) LIKE UPPER('%color1%') OR UPPER(description) LIKE UPPER('%color2%') OR UPPER(description) LIKE UPPER('%color3%')) AND description IS NOT NULL;","output":"SELECT * FROM hazards WHERE description LIKE '%color1%' OR description LIKE '%color2%' OR description LIKE '%color3%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE \"order\" = forms_id AND \"order\" IS NOT NULL AND forms_id IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE order = forms_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = user_pharmacy_id AND user_id IS NOT NULL AND user_pharmacy_id IS NOT NULL;","output":"SELECT * FROM event_actions WHERE user_id = user_pharmacy_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MAX(updated_at) FROM formsettings_summarytools WHERE updated_at IS NOT NULL) UNION SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MIN(updated_at) FROM formsettings_summarytools WHERE updated_at IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MAX(updated_at) FROM formsettings_summarytools) UNION SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MIN(updated_at) FROM formsettings_summarytools);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE LENGTH(harmt) = LENGTH(prescribers_id) AND harmt IS NOT NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE LENGTH(harmt) = LENGTH(prescribers_id);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE updated_at >= (SELECT DATE_SUB(NOW(), INTERVAL '1 week')) GROUP BY user_id HAVING COUNT(DISTINCT DATE(updated_at)) >= 2 AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE updated_at >= (SELECT DATE_SUB(NOW(), INTERVAL 1 WEEK)) GROUP BY user_id HAVING COUNT(DISTINCT DATE(updated_at)) >= 2;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at = DATE(created_at) AND trial_ends_at IS NOT NULL AND created_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE trial_ends_at = DATE(created_at);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE (SELECT COUNT(*) FROM pharmacies WHERE daye_enabled IS NOT NULL) > (SELECT COUNT(*) FROM pharmacies WHERE date_disabled IS NOT NULL);","output":"SELECT * FROM pharmacies WHERE (SELECT COUNT() FROM pharmacies WHERE daye_enabled IS NOT NULL) > (SELECT COUNT() FROM pharmacies WHERE date_disabled IS NOT NULL);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE LENGTH(full_name) = (SELECT MAX(LENGTH(full_name)) FROM staff_directory WHERE full_name IS NOT NULL) AND full_name IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE LENGTH(full_name) = (SELECT MAX(LENGTH(full_name)) FROM staff_directory);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(updated_at AS TEXT) > CAST((CURRENT_TIMESTAMP - INTERVAL '1 day') AS TEXT) AND serial_number ~ '([A-Za-z0-9]{2})+' AND serial_number IS NOT NULL;","output":"SELECT * FROM assets WHERE updated_at > (CURRENT_TIMESTAMP - INTERVAL 1 DAY) AND serial_number REGEXP '([A-Za-z0-9]{2})+';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(description) LIKE UPPER('%industry_keyword%') AND description IS NOT NULL;","output":"SELECT * FROM hazards WHERE description LIKE '%industry_keyword%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE UPPER(name) LIKE UPPER('%Lead%') ORDER BY \"order\" DESC AND name IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE name LIKE '%Lead%' ORDER BY order DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE EXTRACT(DOW FROM action_date) IN (5, 6) AND date_done IS NOT NULL AND date_done <> NULL AND action_date IS NOT NULL;","output":"SELECT * FROM event_actions WHERE WEEKDAY(action_date) IN (5, 6) AND date_done IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('M%') AND city IS NOT NULL) AND updated_by IN (SELECT name FROM organizations WHERE UPPER(name) LIKE UPPER('%Institute%') AND name IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'M%') AND updated_by IN (SELECT name FROM organizations WHERE name LIKE '%Institute%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(harmt AS TEXT) = CAST(prescribers_id AS TEXT) AND harmt IS NOT NULL AND harmt <> NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE harmt = prescribers_id AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(first_name) = UPPER('john') AND LOWER(last_name) = LOWER('doe') AND LENGTH(email) > 10 AND CHAR_LENGTH(phone) = 12 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND updated_at <> NULL","output":"SELECT * FROM users WHERE first_name = 'john' AND last_name = 'doe' AND LENGTH(email) > 10 AND LENGTH(phone) = 12 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL"}
{"instruction":"Optimize the SQL query","input":"SELECT product_id, product_name, price FROM products WHERE price BETWEEN 100.00 AND 500.00 AND category_id IN (SELECT category_id FROM categories WHERE category_name ILIKE '%electronics%') ORDER BY price DESC, product_name ASC LIMIT 50 OFFSET 0","output":"SELECT product_id, product_name, price FROM products WHERE price BETWEEN 100.00 AND 500.00 AND category_id IN (SELECT category_id FROM categories WHERE category_name ILIKE '%electronics%') ORDER BY price DESC, product_name ASC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, COUNT(*) as order_count, SUM(total_amount) as total_spent FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2023 AND EXTRACT(MONTH FROM order_date) BETWEEN 1 AND 6 GROUP BY customer_id HAVING COUNT(*) > 5 AND SUM(total_amount) > 1000.00 ORDER BY total_spent DESC","output":"SELECT customer_id, COUNT(*) as order_count, SUM(total_amount) as total_spent FROM orders WHERE order_date >= '2023-01-01' AND order_date < '2023-07-01' GROUP BY customer_id HAVING COUNT(*) > 5 AND SUM(total_amount) > 1000.00 ORDER BY total_spent DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM employees WHERE (department = 'IT' OR department = 'Engineering') AND salary > 75000 AND EXTRACT(YEAR FROM hire_date) > 2018 AND active = TRUE AND manager_id IS NOT NULL ORDER BY last_name, first_name","output":"SELECT * FROM employees WHERE department IN ('IT', 'Engineering') AND salary > 75000 AND hire_date > '2018-12-31' AND active = true AND manager_id IS NOT NULL ORDER BY last_name, first_name"}
{"instruction":"Optimize the SQL query","input":"SELECT product_id, product_name, description FROM products WHERE description LIKE '%wireless%' AND description LIKE '%bluetooth%' AND description NOT LIKE '%cord%' AND price < 200.00 AND stock_quantity > 0 AND category_id IN (1,2,3,4,5)","output":"SELECT product_id, product_name, description FROM products WHERE description LIKE '%wireless%' AND description LIKE '%bluetooth%' AND description NOT LIKE '%cord%' AND price < 200.00 AND stock_quantity > 0 AND category_id IN (1,2,3,4,5)"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, c.customer_name, SUM(od.quantity * od.unit_price) as order_total FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, c.customer_name HAVING SUM(od.quantity * od.unit_price) > 500.00 ORDER BY order_total DESC","output":"SELECT o.order_id, o.order_date, c.customer_name, SUM(od.quantity * od.unit_price) as order_total FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, c.customer_name HAVING SUM(od.quantity * od.unit_price) > 500.00 ORDER BY order_total DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT employee_id, first_name, last_name, email, phone, department, salary FROM employees WHERE salary BETWEEN 50000 AND 100000 AND department IN ('Sales', 'Marketing', 'Finance') AND hire_date > '2020-01-01' AND active = 1 ORDER BY salary DESC, last_name ASC, first_name ASC LIMIT 25","output":"SELECT employee_id, first_name, last_name, email, phone, department, salary FROM employees WHERE salary BETWEEN 50000 AND 100000 AND department IN ('Sales', 'Marketing', 'Finance') AND hire_date > '2020-01-01' AND active = 1 ORDER BY salary DESC, last_name ASC, first_name ASC LIMIT 25"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, c.category_name, p.price, p.stock_quantity FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50.00 AND p.stock_quantity > 10 AND c.category_name LIKE '%Home%' AND p.discontinued = FALSE ORDER BY p.price ASC, p.product_name ASC","output":"SELECT p.product_id, p.product_name, c.category_name, p.price, p.stock_quantity FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50.00 AND p.stock_quantity > 10 AND c.category_name LIKE '%Home%' AND p.discontinued = false ORDER BY p.price ASC, p.product_name ASC"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, customer_name, email, phone, address, city, state, zip_code FROM customers WHERE (city = 'New York' OR city = 'Los Angeles' OR city = 'Chicago') AND created_at >= '2022-01-01' AND email IS NOT NULL AND phone IS NOT NULL ORDER BY customer_name ASC","output":"SELECT customer_id, customer_name, email, phone, address, city, state, zip_code FROM customers WHERE city IN ('New York', 'Los Angeles', 'Chicago') AND created_at >= '2022-01-01' AND email IS NOT NULL AND phone IS NOT NULL ORDER BY customer_name ASC"}
{"instruction":"Optimize the SQL query","input":"SELECT order_id, customer_id, order_date, total_amount, status FROM orders WHERE status IN ('Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-03-31' AND total_amount > 100.00 ORDER BY order_date DESC, total_amount DESC","output":"SELECT order_id, customer_id, order_date, total_amount, status FROM orders WHERE status IN ('Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-03-31' AND total_amount > 100.00 ORDER BY order_date DESC, total_amount DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(first_name) = UPPER('john') AND LOWER(last_name) = LOWER('doe') AND LENGTH(email) > 10 AND CHAR_LENGTH(phone) = 12 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND updated_at <> NULL","output":"SELECT * FROM users WHERE first_name = 'john' AND last_name = 'doe' AND LENGTH(email) > 10 AND LENGTH(phone) = 12 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL"}
{"instruction":"Optimize the SQL query","input":"SELECT product_id, product_name, price FROM products WHERE price BETWEEN 100.00 AND 500.00 AND category_id IN (SELECT category_id FROM categories WHERE category_name ILIKE '%electronics%') ORDER BY price DESC, product_name ASC LIMIT 50 OFFSET 0","output":"SELECT product_id, product_name, price FROM products WHERE price BETWEEN 100.00 AND 500.00 AND category_id IN (SELECT category_id FROM categories WHERE category_name ILIKE '%electronics%') ORDER BY price DESC, product_name ASC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, COUNT(*) as order_count, SUM(total_amount) as total_spent FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2023 AND EXTRACT(MONTH FROM order_date) BETWEEN 1 AND 6 GROUP BY customer_id HAVING COUNT(*) > 5 AND SUM(total_amount) > 1000.00 ORDER BY total_spent DESC","output":"SELECT customer_id, COUNT(*) as order_count, SUM(total_amount) as total_spent FROM orders WHERE order_date >= '2023-01-01' AND order_date < '2023-07-01' GROUP BY customer_id HAVING COUNT(*) > 5 AND SUM(total_amount) > 1000.00 ORDER BY total_spent DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM employees WHERE (department = 'IT' OR department = 'Engineering') AND salary > 75000 AND EXTRACT(YEAR FROM hire_date) > 2018 AND active = TRUE AND manager_id IS NOT NULL ORDER BY last_name, first_name","output":"SELECT * FROM employees WHERE department IN ('IT', 'Engineering') AND salary > 75000 AND hire_date > '2018-12-31' AND active = true AND manager_id IS NOT NULL ORDER BY last_name, first_name"}
{"instruction":"Optimize the SQL query","input":"SELECT product_id, product_name, description FROM products WHERE description LIKE '%wireless%' AND description LIKE '%bluetooth%' AND description NOT LIKE '%cord%' AND price < 200.00 AND stock_quantity > 0 AND category_id IN (1,2,3,4,5)","output":"SELECT product_id, product_name, description FROM products WHERE description LIKE '%wireless%' AND description LIKE '%bluetooth%' AND description NOT LIKE '%cord%' AND price < 200.00 AND stock_quantity > 0 AND category_id IN (1,2,3,4,5)"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, c.customer_name, SUM(od.quantity * od.unit_price) as order_total FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, c.customer_name HAVING SUM(od.quantity * od.unit_price) > 500.00 ORDER BY order_total DESC","output":"SELECT o.order_id, o.order_date, c.customer_name, SUM(od.quantity * od.unit_price) as order_total FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, c.customer_name HAVING SUM(od.quantity * od.unit_price) > 500.00 ORDER BY order_total DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT employee_id, first_name, last_name, email, phone, department, salary FROM employees WHERE salary BETWEEN 50000 AND 100000 AND department IN ('Sales', 'Marketing', 'Finance') AND hire_date > '2020-01-01' AND active = 1 ORDER BY salary DESC, last_name ASC, first_name ASC LIMIT 25","output":"SELECT employee_id, first_name, last_name, email, phone, department, salary FROM employees WHERE salary BETWEEN 50000 AND 100000 AND department IN ('Sales', 'Marketing', 'Finance') AND hire_date > '2020-01-01' AND active = 1 ORDER BY salary DESC, last_name ASC, first_name ASC LIMIT 25"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, c.category_name, p.price, p.stock_quantity FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50.00 AND p.stock_quantity > 10 AND c.category_name LIKE '%Home%' AND p.discontinued = FALSE ORDER BY p.price ASC, p.product_name ASC","output":"SELECT p.product_id, p.product_name, c.category_name, p.price, p.stock_quantity FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50.00 AND p.stock_quantity > 10 AND c.category_name LIKE '%Home%' AND p.discontinued = false ORDER BY p.price ASC, p.product_name ASC"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, customer_name, email, phone, address, city, state, zip_code FROM customers WHERE (city = 'New York' OR city = 'Los Angeles' OR city = 'Chicago') AND created_at >= '2022-01-01' AND email IS NOT NULL AND phone IS NOT NULL ORDER BY customer_name ASC","output":"SELECT customer_id, customer_name, email, phone, address, city, state, zip_code FROM customers WHERE city IN ('New York', 'Los Angeles', 'Chicago') AND created_at >= '2022-01-01' AND email IS NOT NULL AND phone IS NOT NULL ORDER BY customer_name ASC"}
{"instruction":"Optimize the SQL query","input":"SELECT order_id, customer_id, order_date, total_amount, status FROM orders WHERE status IN ('Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-03-31' AND total_amount > 100.00 ORDER BY order_date DESC, total_amount DESC","output":"SELECT order_id, customer_id, order_date, total_amount, status FROM orders WHERE status IN ('Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-03-31' AND total_amount > 100.00 ORDER BY order_date DESC, total_amount DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND date_updated IS NOT NULL AND date_updated <> NULL AND LENGTH(type) > 0 AND CHAR_LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > CAST('2023-02-01' AS TEXT) AND countries_id IS NOT NULL AND countries_id <> NULL AND EXTRACT(YEAR FROM created_at) = 2023 AND EXTRACT(MONTH FROM created_at) >= 2;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND LOWER(city) = 'chicago' AND city LIKE '%Chicago%';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND LENGTH(user_id) = 5 AND user_id LIKE '13579%';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND active IS NOT NULL AND active = 1;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE is_default = CAST(true AS BOOLEAN) AND forms_id IS NOT NULL AND forms_id <> NULL AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE is_default = true AND forms_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(user_id AS TEXT) = '65432' AND updated_at IS NOT NULL AND updated_at <> NULL AND user_id::text LIKE '65432%';","output":"SELECT * FROM event_actions WHERE user_id = '65432' AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(facility_id AS TEXT) = '54321' AND CAST(organization_id AS TEXT) = '87654' AND tools_id IS NOT NULL AND tools_id <> NULL AND facility_id::text = '54321' AND organization_id::text = '87654';","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = '54321' AND organization_id = '87654' AND tools_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE ((harmt IS NOT NULL AND harmt <> NULL) OR (prescribers_id IS NOT NULL AND prescribers_id <> NULL)) AND is_open = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND date_closed IS NOT NULL AND date_closed <> NULL;","output":"SELECT * FROM events WHERE (harmt IS NOT NULL OR prescribers_id IS NOT NULL) AND is_open = true AND date_created IS NOT NULL AND date_closed IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) > '2023-04-01' AND updated_at IS NOT NULL AND updated_at <> NULL AND is_active = 1;","output":"SELECT * FROM users WHERE is_active = true AND updated_at > '2023-04-01' AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE UPPER(city) = UPPER('Denver') AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND LOWER(city) = 'denver';","output":"SELECT * FROM organizations WHERE city = 'Denver' AND trial_ends_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) = UPPER('Pharmacist D') AND activate_at IS NOT NULL AND activate_at <> NULL AND activated_by ILIKE 'Pharmacist D';","output":"SELECT * FROM pharmacies WHERE activated_by = 'Pharmacist D' AND activate_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '97531' AND employee_id IS NOT NULL AND employee_id <> NULL AND user_id::text = '97531';","output":"SELECT * FROM staff_directory WHERE user_id = '97531' AND employee_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND serial_number <> '' AND LENGTH(serial_number) > 0 AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND serial_number <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(name) = UPPER('Chemical Spill') AND description <> '' AND LENGTH(description) > 0 AND name ILIKE 'Chemical Spill';","output":"SELECT * FROM hazards WHERE name = 'Chemical Spill' AND description <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND \"order\" IS NOT NULL AND \"order\" <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND \"order\" IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '321' AND action_date IS NOT NULL AND action_date <> NULL AND date_done IS NOT NULL AND date_done <> NULL AND events_id::text = '321';","output":"SELECT * FROM event_actions WHERE events_id = '321' AND action_date IS NOT NULL AND date_done IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '876' AND CAST(facility_id AS TEXT) = '543' AND updated_by IS NOT NULL AND updated_by <> NULL AND updated_at IS NOT NULL AND updated_at <> NULL;","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '876' AND facility_id = '543' AND updated_by IS NOT NULL AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '987' AND date_created IS NOT NULL AND date_created <> NULL AND updated_by IS NOT NULL AND updated_by <> NULL AND harmt IS NOT NULL AND harmt <> NULL;","output":"SELECT * FROM events WHERE reporters_id = '987' AND date_created IS NOT NULL AND updated_by IS NOT NULL AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND sf_id IS NOT NULL AND sf_id <> NULL AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND is_active = true AND date_created IS NOT NULL AND sf_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-02-01' AND countries_id IS NOT NULL AND countries_id <> NULL AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND name <> '' AND LENGTH(name) > 0;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL AND trial_ends_at IS NOT NULL AND name <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND activated_by IS NOT NULL AND activated_by <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL AND activated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND fixed = CAST(true AS BOOLEAN) AND user_id::text = '13579';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL AND fixed = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND asset_type_id IS NOT NULL AND asset_type_id <> NULL AND active = 1;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL AND asset_type_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id IS NOT NULL AND pharmacies_id <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL AND pharmacies_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE is_default = CAST(true AS BOOLEAN) AND forms_id IS NOT NULL AND forms_id <> NULL AND facility_id IS NOT NULL AND facility_id <> NULL AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE is_default = true AND forms_id IS NOT NULL AND facility_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(user_id AS TEXT) = '65432' AND updated_at IS NOT NULL AND updated_at <> NULL AND user_pharmacy_id IS NOT NULL AND user_pharmacy_id <> NULL AND user_id::text = '65432';","output":"SELECT * FROM event_actions WHERE user_id = '65432' AND updated_at IS NOT NULL AND user_pharmacy_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(facility_id AS TEXT) = '54321' AND CAST(organization_id AS TEXT) = '87654' AND tools_id IS NOT NULL AND tools_id <> NULL AND updated_by IS NOT NULL AND updated_by <> NULL AND facility_id::text = '54321';","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = '54321' AND organization_id = '87654' AND tools_id IS NOT NULL AND updated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE ((harmt IS NOT NULL AND harmt <> NULL) OR (prescribers_id IS NOT NULL AND prescribers_id <> NULL)) AND is_open = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND date_closed IS NOT NULL AND date_closed <> NULL;","output":"SELECT * FROM events WHERE (harmt IS NOT NULL OR prescribers_id IS NOT NULL) AND is_open = true AND date_created IS NOT NULL AND date_closed IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) > '2023-03-01' AND type IS NOT NULL AND type <> NULL AND date_updated IS NOT NULL AND date_updated <> NULL AND is_active = 1;","output":"SELECT * FROM users WHERE is_active = true AND updated_at > '2023-03-01' AND type IS NOT NULL AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE UPPER(city) = UPPER('Seattle') AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND countries_id IS NOT NULL AND countries_id <> NULL AND city ILIKE 'seattle';","output":"SELECT * FROM organizations WHERE city = 'Seattle' AND trial_ends_at IS NOT NULL AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) = UPPER('Pharmacist B') AND activate_at IS NOT NULL AND activate_at <> NULL AND activated_by ILIKE 'Pharmacist B';","output":"SELECT * FROM pharmacies WHERE activated_by = 'Pharmacist B' AND activate_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '98765' AND created_at IS NOT NULL AND created_at <> NULL AND user_id::text = '98765';","output":"SELECT * FROM staff_directory WHERE user_id = '98765' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(asset_type_id AS TEXT) = '789' AND serial_number IS NOT NULL AND serial_number <> NULL AND asset_type_id::text = '789';","output":"SELECT * FROM assets WHERE asset_type_id = '789' AND serial_number IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '65432' AND description <> '' AND LENGTH(description) > 0 AND pharmacies_id::text = '65432';","output":"SELECT * FROM hazards WHERE pharmacies_id = '65432' AND description <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND \"order\" IS NOT NULL AND \"order\" <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND \"order\" IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '987' AND UPPER(updated_by) = UPPER('John Smith') AND events_id::text = '987' AND updated_by ILIKE 'John Smith';","output":"SELECT * FROM event_actions WHERE events_id = '987' AND updated_by = 'John Smith';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '543' AND UPPER(updated_by) = UPPER('Jane Doe') AND organization_id::text = '543' AND updated_by ILIKE 'Jane Doe';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '543' AND updated_by = 'Jane Doe';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '321' AND harmt IS NOT NULL AND harmt <> NULL AND reporters_id::text = '321';","output":"SELECT * FROM events WHERE reporters_id = '321' AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('Admin' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND LENGTH(type) = 5;","output":"SELECT * FROM users WHERE type = 'Admin' AND is_active = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-01-01' AND CAST(updated_at AS TEXT) < '2023-06-30' AND created_at IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-01-01' AND updated_at < '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Los Angeles') AND daye_enabled IS NOT NULL AND daye_enabled <> NULL AND city ILIKE 'los angeles';","output":"SELECT * FROM pharmacies WHERE city = 'Los Angeles' AND daye_enabled IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(full_name) = UPPER('Jane Doe') AND fixed = CAST(true AS BOOLEAN) AND full_name ILIKE 'Jane Doe';","output":"SELECT * FROM staff_directory WHERE full_name = 'Jane Doe' AND fixed = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) >= '2023-01-01' AND CAST(updated_at AS TEXT) <= '2023-06-30' AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND updated_at BETWEEN '2023-01-01' AND '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(name) LIKE UPPER('Chemical%') AND name IS NOT NULL;","output":"SELECT * FROM hazards WHERE name LIKE 'Chemical%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '789' AND CAST(facility_id AS TEXT) = '654' AND forms_id::text = '789' AND facility_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '789' AND facility_id = '654';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '987' AND UPPER(updated_by) = UPPER('John Smith') AND events_id::text = '987';","output":"SELECT * FROM event_actions WHERE events_id = '987' AND updated_by = 'John Smith';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '543' AND UPPER(updated_by) = UPPER('Jane Doe') AND organization_id::text = '543';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '543' AND updated_by = 'Jane Doe';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '321' AND harmt IS NOT NULL AND harmt <> NULL AND reporters_id::text = '321';","output":"SELECT * FROM events WHERE reporters_id = '321' AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND is_active = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-01-01' AND CAST(updated_at AS TEXT) < '2023-06-30' AND created_at IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-01-01' AND updated_at < '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND user_id::text = '13579';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND updates_by IS NOT NULL AND updates_by <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND updates_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '321' AND action_date IS NOT NULL AND action_date <> NULL AND events_id::text = '321';","output":"SELECT * FROM event_actions WHERE events_id = '321' AND action_date IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '876' AND CAST(facility_id AS TEXT) = '543' AND updated_by IS NOT NULL AND updated_by <> NULL AND organization_id::text = '876';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '876' AND facility_id = '543' AND updated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '987' AND date_created IS NOT NULL AND date_created <> NULL AND reporters_id::text = '987';","output":"SELECT * FROM events WHERE reporters_id = '987' AND date_created IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND date_updated IS NOT NULL AND date_updated <> NULL AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-02-01' AND countries_id IS NOT NULL AND countries_id <> NULL AND created_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(employee_id) LIKE UPPER('EMP-%') AND employee_id IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE employee_id LIKE 'EMP-%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(updated_at AS TEXT) > CAST((CURRENT_TIMESTAMP - INTERVAL '1 day') AS TEXT) AND updated_at IS NOT NULL;","output":"SELECT * FROM assets WHERE updated_at > (CURRENT_TIMESTAMP - INTERVAL '1 day');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies WHERE UPPER(name) LIKE UPPER('%Healthcare%') AND name IS NOT NULL);","output":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies WHERE name LIKE '%Healthcare%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE UPPER(name) LIKE UPPER('%Coordinator%') AND name IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE name LIKE '%Coordinator%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id IN (SELECT user_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE UPPER(role) = UPPER('Supervisor') AND role IS NOT NULL) AND user_id IS NOT NULL);","output":"SELECT * FROM event_actions WHERE user_id IN (SELECT user_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE role = 'Supervisor'));"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('S%') AND city IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'S%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE harmt IS NOT NULL AND harmt <> NULL AND reporters_id IN (SELECT users_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE UPPER(role) = UPPER('Admin') AND role IS NOT NULL) AND users_id IS NOT NULL);","output":"SELECT * FROM events WHERE harmt IS NOT NULL AND reporters_id IN (SELECT users_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE role = 'Admin'));"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(1 AS BOOLEAN) AND EXTRACT(DOW FROM updated_at) IN (1, 7) AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE is_active = 1 AND DAYOFWEEK(updated_at) IN (1, 7);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE sf_id IN (SELECT sf_id FROM organizations GROUP BY sf_id HAVING COUNT(DISTINCT countries_id) > 1 AND COUNT(DISTINCT countries_id) <> 0);","output":"SELECT * FROM organizations WHERE sf_id IN (SELECT sf_id FROM organizations GROUP BY sf_id HAVING COUNT(DISTINCT countries_id) > 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) LIKE UPPER('%Pharma%') AND organizations_id IN (SELECT organizations_id FROM organizations WHERE UPPER(address) LIKE UPPER('P%') AND address IS NOT NULL);","output":"SELECT * FROM pharmacies WHERE activated_by LIKE '%Pharma%' AND organizations_id IN (SELECT organizations_id FROM organizations WHERE address LIKE 'P%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(full_name) LIKE UPPER('%John%') AND UPPER(full_name) LIKE UPPER('%Doe%') AND full_name IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE full_name LIKE '%John%' AND full_name LIKE '%Doe%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id IN (SELECT MAX(CAST(asset_items_id AS BIGINT)) FROM assets WHERE asset_items_id IS NOT NULL);","output":"SELECT * FROM assets WHERE asset_items_id IN (SELECT MAX(asset_items_id) FROM assets);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies GROUP BY pharmacies_id ORDER BY COUNT(*) DESC, pharmacies_id ASC LIMIT 1);","output":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies GROUP BY pharmacies_id ORDER BY COUNT(*) DESC LIMIT 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE forms_id IN (SELECT forms_id FROM event_staff_roles GROUP BY forms_id ORDER BY COUNT(*) DESC, forms_id ASC);","output":"SELECT * FROM event_staff_roles WHERE forms_id IN (SELECT forms_id FROM event_staff_roles GROUP BY forms_id ORDER BY COUNT(*) DESC);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE EXTRACT(DOW FROM action_date) IN (5, 6) AND action_date IS NOT NULL;","output":"SELECT * FROM event_actions WHERE WEEKDAY(action_date) IN (5, 6);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE organization_id IN (SELECT organization_id FROM organizations WHERE UPPER(name) LIKE UPPER('%Institute%') AND name IS NOT NULL) AND facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('M%') AND city IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE organization_id IN (SELECT organization_id FROM organizations WHERE name LIKE '%Institute%') AND facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'M%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(harmt AS TEXT) = CAST(prescribers_id AS TEXT) AND harmt IS NOT NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE harmt = prescribers_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(date_created AS DATE) = CAST(updated_at AS DATE) AND date_created IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE DATE(date_created) = DATE(updated_at);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at IN (SELECT trial_ends_at FROM organizations GROUP BY trial_ends_at HAVING COUNT(*) > 1 AND COUNT(*) <> 0);","output":"SELECT * FROM organizations WHERE trial_ends_at IN (SELECT trial_ends_at FROM organizations GROUP BY trial_ends_at HAVING COUNT(*) > 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activate_at = CAST('specific_date' AS TIMESTAMP) AND activated_by = SUBSTRING(name, 1, 2) AND name IS NOT NULL;","output":"SELECT * FROM pharmacies WHERE activate_at = 'specific_date' AND activated_by = SUBSTRING(name, 1, 2);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE employee_id = REVERSE(employee_id) AND employee_id IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE employee_id = REVERSE(employee_id);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE serial_number ~ '[0-9]{3}' AND serial_number IS NOT NULL;","output":"SELECT * FROM assets WHERE serial_number REGEXP '[0-9]{3}';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE (UPPER(description) LIKE UPPER('%color1%') OR UPPER(description) LIKE UPPER('%color2%') OR UPPER(description) LIKE UPPER('%color3%')) AND description IS NOT NULL;","output":"SELECT * FROM hazards WHERE description LIKE '%color1%' OR description LIKE '%color2%' OR description LIKE '%color3%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE \"order\" = forms_id AND \"order\" IS NOT NULL AND forms_id IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE order = forms_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = user_pharmacy_id AND user_id IS NOT NULL AND user_pharmacy_id IS NOT NULL;","output":"SELECT * FROM event_actions WHERE user_id = user_pharmacy_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MAX(updated_at) FROM formsettings_summarytools WHERE updated_at IS NOT NULL) UNION SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MIN(updated_at) FROM formsettings_summarytools WHERE updated_at IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MAX(updated_at) FROM formsettings_summarytools) UNION SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MIN(updated_at) FROM formsettings_summarytools);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE LENGTH(harmt) = LENGTH(prescribers_id) AND harmt IS NOT NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE LENGTH(harmt) = LENGTH(prescribers_id);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE updated_at >= (SELECT DATE_SUB(NOW(), INTERVAL '1 week')) GROUP BY user_id HAVING COUNT(DISTINCT DATE(updated_at)) >= 2 AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE updated_at >= (SELECT DATE_SUB(NOW(), INTERVAL 1 WEEK)) GROUP BY user_id HAVING COUNT(DISTINCT DATE(updated_at)) >= 2;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at = DATE(created_at) AND trial_ends_at IS NOT NULL AND created_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE trial_ends_at = DATE(created_at);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE (SELECT COUNT(*) FROM pharmacies WHERE daye_enabled IS NOT NULL) > (SELECT COUNT(*) FROM pharmacies WHERE date_disabled IS NOT NULL);","output":"SELECT * FROM pharmacies WHERE (SELECT COUNT() FROM pharmacies WHERE daye_enabled IS NOT NULL) > (SELECT COUNT() FROM pharmacies WHERE date_disabled IS NOT NULL);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE LENGTH(full_name) = (SELECT MAX(LENGTH(full_name)) FROM staff_directory WHERE full_name IS NOT NULL) AND full_name IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE LENGTH(full_name) = (SELECT MAX(LENGTH(full_name)) FROM staff_directory);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(updated_at AS TEXT) > CAST((CURRENT_TIMESTAMP - INTERVAL '1 day') AS TEXT) AND serial_number ~ '([A-Za-z0-9]{2})+' AND serial_number IS NOT NULL;","output":"SELECT * FROM assets WHERE updated_at > (CURRENT_TIMESTAMP - INTERVAL 1 DAY) AND serial_number REGEXP '([A-Za-z0-9]{2})+';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(description) LIKE UPPER('%industry_keyword%') AND description IS NOT NULL;","output":"SELECT * FROM hazards WHERE description LIKE '%industry_keyword%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE UPPER(name) LIKE UPPER('%Lead%') ORDER BY \"order\" DESC AND name IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE name LIKE '%Lead%' ORDER BY order DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE EXTRACT(DOW FROM action_date) IN (5, 6) AND date_done IS NOT NULL AND date_done <> NULL AND action_date IS NOT NULL;","output":"SELECT * FROM event_actions WHERE WEEKDAY(action_date) IN (5, 6) AND date_done IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('M%') AND city IS NOT NULL) AND updated_by IN (SELECT name FROM organizations WHERE UPPER(name) LIKE UPPER('%Institute%') AND name IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'M%') AND updated_by IN (SELECT name FROM organizations WHERE name LIKE '%Institute%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(harmt AS TEXT) = CAST(prescribers_id AS TEXT) AND harmt IS NOT NULL AND harmt <> NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE harmt = prescribers_id AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(username) = UPPER('john_doe') AND LENGTH(password) >= 8 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND is_active = TRUE AND email_verified = TRUE AND last_login > '2023-01-01' AND profile_complete = TRUE AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = TRUE AND two_factor_enabled = TRUE AND last_password_change > '2023-06-01'","output":"SELECT * FROM users WHERE username = 'john_doe' AND LENGTH(password) >= 8 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL AND is_active = true AND email_verified = true AND last_login > '2023-01-01' AND profile_complete = true AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = true AND two_factor_enabled = true AND last_password_change > '2023-06-01'"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75 OFFSET 0","output":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = TRUE AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100 OFFSET 0","output":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = true AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(username) = UPPER('john_doe') AND LENGTH(password) >= 8 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND is_active = TRUE AND email_verified = TRUE AND last_login > '2023-01-01' AND profile_complete = TRUE AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = TRUE AND two_factor_enabled = TRUE AND last_password_change > '2023-06-01'","output":"SELECT * FROM users WHERE username = 'john_doe' AND LENGTH(password) >= 8 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL AND is_active = true AND email_verified = true AND last_login > '2023-01-01' AND profile_complete = true AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = true AND two_factor_enabled = true AND last_password_change > '2023-06-01'"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75 OFFSET 0","output":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = TRUE AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100 OFFSET 0","output":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = true AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60 OFFSET 0","output":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40"}
{"instruction":"Optimize the SQL query","input":"SELECT s.sale_id, s.sale_date, s.total_amount, s.payment_method, c.customer_name, c.membership_level, e.employee_name, st.store_name, st.location, p.product_name, p.category, sd.quantity, sd.unit_price, sd.discount_amount, prom.promotion_name, prom.discount_percentage, tax.tax_amount, tax.tax_rate, del.delivery_status, del.delivery_date FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id WHERE s.sale_date BETWEEN '2023-06-01' AND '2023-12-31' AND s.total_amount > 200.00 AND s.payment_method IN ('credit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum') AND e.position = 'sales_associate' AND st.location LIKE '%mall%' AND p.category = 'electronics' AND sd.quantity > 2 AND prom.discount_percentage > 10.00 AND tax.tax_rate BETWEEN 0.08 AND 0.15 AND del.delivery_status = 'delivered' AND del.delivery_date IS NOT NULL ORDER BY s.total_amount DESC, s.sale_date DESC LIMIT 80 OFFSET 0","output":"SELECT s.sale_id, s.sale_date, s.total_amount, s.payment_method, c.customer_name, c.membership_level, e.employee_name, st.store_name, st.location, p.product_name, p.category, sd.quantity, sd.unit_price, sd.discount_amount, prom.promotion_name, prom.discount_percentage, tax.tax_amount, tax.tax_rate, del.delivery_status, del.delivery_date FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id WHERE s.sale_date BETWEEN '2023-06-01' AND '2023-12-31' AND s.total_amount > 200.00 AND s.payment_method IN ('credit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum') AND e.position = 'sales_associate' AND st.location LIKE '%mall%' AND p.category = 'electronics' AND sd.quantity > 2 AND prom.discount_percentage > 10.00 AND tax.tax_rate BETWEEN 0.08 AND 0.15 AND del.delivery_status = 'delivered' AND del.delivery_date IS NOT NULL ORDER BY s.total_amount DESC, s.sale_date DESC LIMIT 80"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, wh.warehouse_name, wh.location, wh.capacity, s.supplier_name, s.contact_email, cat.category_name, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id WHERE inv.current_stock < inv.min_stock_level AND inv.unit_cost > 25.00 AND wh.capacity > 1000 AND s.rating >= 4.0 AND cat.category_name = 'raw_materials' AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-01-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND inv.total_value > 5000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC LIMIT 55 OFFSET 0","output":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, wh.warehouse_name, wh.location, wh.capacity, s.supplier_name, s.contact_email, cat.category_name, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id WHERE inv.current_stock < inv.min_stock_level AND inv.unit_cost > 25.00 AND wh.capacity > 1000 AND s.rating >= 4.0 AND cat.category_name = 'raw_materials' AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-01-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND inv.total_value > 5000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC LIMIT 55"}
{"instruction":"Optimize the SQL query","input":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.status, c.customer_name, c.credit_score, e.employee_name, br.branch_name, pt.payment_term, sch.due_date, sch.amount_due, sch.paid_amount, coll.collection_status, coll.collection_date, coll.collection_amount, risk.risk_level, risk.risk_description, doc.document_name, doc.document_status, ins.insurance_amount, ins.insurance_provider FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id WHERE loan.amount > 50000.00 AND loan.interest_rate < 8.00 AND loan.start_date > '2022-01-01' AND loan.status = 'active' AND c.credit_score > 700 AND br.branch_region = 'northeast' AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-09-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > 0 AND ins.insurance_provider IS NOT NULL ORDER BY loan.amount DESC, loan.start_date ASC LIMIT 70 OFFSET 0","output":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.status, c.customer_name, c.credit_score, e.employee_name, br.branch_name, pt.payment_term, sch.due_date, sch.amount_due, sch.paid_amount, coll.collection_status, coll.collection_date, coll.collection_amount, risk.risk_level, risk.risk_description, doc.document_name, doc.document_status, ins.insurance_amount, ins.insurance_provider FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id WHERE loan.amount > 50000.00 AND loan.interest_rate < 8.00 AND loan.start_date > '2022-01-01' AND loan.status = 'active' AND c.credit_score > 700 AND br.branch_region = 'northeast' AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-09-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > 0 AND ins.insurance_provider IS NOT NULL ORDER BY loan.amount DESC, loan.start_date ASC LIMIT 70"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(username) = UPPER('john_doe') AND LENGTH(password) >= 8 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND is_active = TRUE AND email_verified = TRUE AND last_login > '2023-01-01' AND profile_complete = TRUE AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = TRUE AND two_factor_enabled = TRUE AND last_password_change > '2023-06-01'","output":"SELECT * FROM users WHERE username = 'john_doe' AND LENGTH(password) >= 8 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL AND is_active = true AND email_verified = true AND last_login > '2023-01-01' AND profile_complete = true AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = true AND two_factor_enabled = true AND last_password_change > '2023-06-01'"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75 OFFSET 0","output":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = TRUE AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100 OFFSET 0","output":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = true AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60 OFFSET 0","output":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(username) = UPPER('john_doe') AND LENGTH(password) >= 8 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND is_active = TRUE AND email_verified = TRUE AND last_login > '2023-01-01' AND profile_complete = TRUE AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = TRUE AND two_factor_enabled = TRUE AND last_password_change > '2023-06-01'","output":"SELECT * FROM users WHERE username = 'john_doe' AND LENGTH(password) >= 8 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL AND is_active = true AND email_verified = true AND last_login > '2023-01-01' AND profile_complete = true AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = true AND two_factor_enabled = true AND last_password_change > '2023-06-01'"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75 OFFSET 0","output":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60 OFFSET 0","output":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40"}
{"instruction":"Optimize the SQL query","input":"SELECT s.sale_id, s.sale_date, s.total_amount, s.payment_method, c.customer_name, c.membership_level, e.employee_name, st.store_name, st.location, p.product_name, p.category, sd.quantity, sd.unit_price, sd.discount_amount, prom.promotion_name, prom.discount_percentage, tax.tax_amount, tax.tax_rate, del.delivery_status, del.delivery_date FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id WHERE s.sale_date BETWEEN '2023-06-01' AND '2023-12-31' AND s.total_amount > 200.00 AND s.payment_method IN ('credit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum') AND e.position = 'sales_associate' AND st.location LIKE '%mall%' AND p.category = 'electronics' AND sd.quantity > 2 AND prom.discount_percentage > 10.00 AND tax.tax_rate BETWEEN 0.08 AND 0.15 AND del.delivery_status = 'delivered' AND del.delivery_date IS NOT NULL ORDER BY s.total_amount DESC, s.sale_date DESC LIMIT 80 OFFSET 0","output":"SELECT s.sale_id, s.sale_date, s.total_amount, s.payment_method, c.customer_name, c.membership_level, e.employee_name, st.store_name, st.location, p.product_name, p.category, sd.quantity, sd.unit_price, sd.discount_amount, prom.promotion_name, prom.discount_percentage, tax.tax_amount, tax.tax_rate, del.delivery_status, del.delery_date FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id WHERE s.sale_date BETWEEN '2023-06-01' AND '2023-12-31' AND s.total_amount > 200.00 AND s.payment_method IN ('credit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum') AND e.position = 'sales_associate' AND st.location LIKE '%mall%' AND p.category = 'electronics' AND sd.quantity > 2 AND prom.discount_percentage > 10.00 AND tax.tax_rate BETWEEN 0.08 AND 0.15 AND del.delivery_status = 'delivered' AND del.delivery_date IS NOT NULL ORDER BY s.total_amount DESC, s.sale_date DESC LIMIT 80"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, wh.warehouse_name, wh.location, wh.capacity, s.supplier_name, s.contact_email, cat.category_name, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id WHERE inv.current_stock < inv.min_stock_level AND inv.unit_cost > 25.00 AND wh.capacity > 1000 AND s.rating >= 4.0 AND cat.category_name = 'raw_materials' AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-01-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND inv.total_value > 5000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC LIMIT 55 OFFSET 0","output":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, wh.warehouse_name, wh.location, wh.capacity, s.supplier_name, s.contact_email, cat.category_name, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id WHERE inv.current_stock < inv.min_stock_level AND inv.unit_cost > 25.00 AND wh.capacity > 1000 AND s.rating >= 4.0 AND cat.category_name = 'raw_materials' AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-01-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND inv.total_value > 5000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC LIMIT 55"}
{"instruction":"Optimize the SQL query","input":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.status, c.customer_name, c.credit_score, e.employee_name, br.branch_name, pt.payment_term, sch.due_date, sch.amount_due, sch.paid_amount, coll.collection_status, coll.collection_date, coll.collection_amount, risk.risk_level, risk.risk_description, doc.document_name, doc.document_status, ins.insurance_amount, ins.insurance_provider FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id WHERE loan.amount > 50000.00 AND loan.interest_rate < 8.00 AND loan.start_date > '2022-01-01' AND loan.status = 'active' AND c.credit_score > 700 AND br.branch_region = 'northeast' AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-09-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > 0 AND ins.insurance_provider IS NOT NULL ORDER BY loan.amount DESC, loan.start_date ASC LIMIT 70 OFFSET 0","output":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.status, c.customer_name, c.credit_score, e.employee_name, br.branch_name, pt.payment_term, sch.due_date, sch.amount_due, sch.paid_amount, coll.collection_status, coll.collection_date, coll.collection_amount, risk.risk_level, risk.risk_description, doc.document_name, doc.document_status, ins.insurance_amount, ins.insurance_provider FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id WHERE loan.amount > 50000.00 AND loan.interest_rate < 8.00 AND loan.start_date > '2022-01-01' AND loan.status = 'active' AND c.credit_score > 700 AND br.branch_region = 'northeast' AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-09-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > 0 AND ins.insurance_provider IS NOT NULL ORDER BY loan.amount DESC, loan.start_date ASC LIMIT 70"}
{"instruction":"Optimize the SQL query","input":"SELECT emp.employee_id, emp.first_name, emp.last_name, emp.email, emp.department, emp.salary, emp.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name, t.team_name, per.performance_rating, per.review_date, sal.salary_amount, sal.effective_date, ben.benefit_type, ben.coverage_amount, att.attendance_date, att.hours_worked, att.overtime_hours, vac.vacation_days_used, vac.vacation_days_remaining FROM employees emp LEFT JOIN employees m ON emp.manager_id = m.employee_id JOIN departments d ON emp.department_id = d.department_id JOIN locations l ON emp.location_id = l.location_id JOIN employee_skills es ON emp.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON emp.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id JOIN teams t ON emp.team_id = t.team_id JOIN performance_reviews per ON emp.employee_id = per.employee_id JOIN salary_history sal ON emp.employee_id = sal.employee_id JOIN benefits ben ON emp.employee_id = ben.employee_id JOIN attendance_records att ON emp.employee_id = att.employee_id JOIN vacation_balances vac ON emp.employee_id = vac.employee_id WHERE emp.salary BETWEEN 70000 AND 150000 AND emp.hire_date > '2017-01-01' AND emp.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product Management') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND r.role_name IN ('Senior Developer', 'Architect', 'Team Lead') AND t.team_size > 8 AND per.performance_rating >= 4.0 AND sal.salary_amount > 75000 AND ben.coverage_amount > 100000 AND att.hours_worked > 160 AND vac.vacation_days_remaining > 5 ORDER BY emp.salary DESC, per.performance_rating DESC LIMIT 50 OFFSET 0","output":"SELECT emp.employee_id, emp.first_name, emp.last_name, emp.email, emp.department, emp.salary, emp.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name, t.team_name, per.performance_rating, per.review_date, sal.salary_amount, sal.effective_date, ben.benefit_type, ben.coverage_amount, att.attendance_date, att.hours_worked, att.overtime_hours, vac.vacation_days_used, vac.vacation_days_remaining FROM employees emp LEFT JOIN employees m ON emp.manager_id = m.employee_id JOIN departments d ON emp.department_id = d.department_id JOIN locations l ON emp.location_id = l.location_id JOIN employee_skills es ON emp.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON emp.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id JOIN teams t ON emp.team_id = t.team_id JOIN performance_reviews per ON emp.employee_id = per.employee_id JOIN salary_history sal ON emp.employee_id = sal.employee_id JOIN benefits ben ON emp.employee_id = ben.employee_id JOIN attendance_records att ON emp.employee_id = att.employee_id JOIN vacation_balances vac ON emp.employee_id = vac.employee_id WHERE emp.salary BETWEEN 70000 AND 150000 AND emp.hire_date > '2017-01-01' AND emp.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product Management') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND r.role_name IN ('Senior Developer', 'Architect', 'Team Lead') AND t.team_size > 8 AND per.performance_rating >= 4.0 AND sal.salary_amount > 75000 AND ben.coverage_amount > 100000 AND att.hours_worked > 160 AND vac.vacation_days_remaining > 5 ORDER BY emp.salary DESC, per.performance_rating DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, c.email, c.phone, c.membership_level, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, s.renewal_date, l.loyalty_tier, l.points_balance, l.reward_status, com.communication_type, com.communication_date, com.communication_status, fed.feedback_rating, fed.feedback_date, fed.feedback_comment, sup.support_ticket_id, sup.issue_type, sup.status AS support_status, pay.payment_method, pay.default_payment FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id LEFT JOIN customer_communications com ON c.customer_id = com.customer_id LEFT JOIN customer_feedback fed ON c.customer_id = fed.customer_id LEFT JOIN support_tickets sup ON c.customer_id = sup.customer_id LEFT JOIN payment_methods pay ON c.customer_id = pay.customer_id WHERE c.created_date > '2019-01-01' AND c.active = TRUE AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum', 'diamond') AND com.communication_status = 'delivered' AND fed.feedback_rating >= 4 AND sup.status = 'resolved' AND pay.default_payment = TRUE AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2021-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, c.membership_level, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, s.renewal_date, l.loyalty_tier, l.points_balance, l.reward_status, com.communication_type, com.communication_date, com.communication_status, fed.feedback_rating, fed.feedback_date, fed.feedback_comment, sup.support_ticket_id, sup.issue_type, sup.status, pay.payment_method, pay.default_payment HAVING COUNT(o.order_id) > 10 AND SUM(o.total_amount) > 5000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 75 OFFSET 0","output":"SELECT c.customer_id, c.customer_name, c.email, c.phone, c.membership_level, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, s.renewal_date, l.loyalty_tier, l.points_balance, l.reward_status, com.communication_type, com.communication_date, com.communication_status, fed.feedback_rating, fed.feedback_date, fed.feedback_comment, sup.support_ticket_id, sup.issue_type, sup.status AS support_status, pay.payment_method, pay.default_payment FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id LEFT JOIN customer_communications com ON c.customer_id = com.customer_id LEFT JOIN customer_feedback fed ON c.customer_id = fed.customer_id LEFT JOIN support_tickets sup ON c.customer_id = sup.customer_id LEFT JOIN payment_methods pay ON c.customer_id = pay.customer_id WHERE c.created_date > '2019-01-01' AND c.active = true AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum', 'diamond') AND com.communication_status = 'delivered' AND fed.feedback_rating >= 4 AND sup.status = 'resolved' AND pay.default_payment = true AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2021-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, c.membership_level, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, s.renewal_date, l.loyalty_tier, l.points_balance, l.reward_status, com.communication_type, com.communication_date, com.communication_status, fed.feedback_rating, fed.feedback_date, fed.feedback_comment, sup.support_ticket_id, sup.issue_type, sup.status, pay.payment_method, pay.default_payment HAVING COUNT(o.order_id) > 10 AND SUM(o.total_amount) > 5000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.sku, p.upc, p.weight, p.dimensions, p.warranty_period, p.release_date, p.discontinued, c.category_name, c.category_description, s.supplier_name, s.contact_name, s.contact_email, s.phone, s.country, b.brand_name, b.brand_website, inv.warehouse_name, inv.location, inv.current_stock, inv.min_stock_level, inv.max_stock_level, rev.review_rating, rev.review_count, rev.average_rating, sale.sale_price, sale.sale_start_date, sale.sale_end_date, img.image_url, img.image_type, doc.document_name, doc.document_type, rel.related_product_id, rel.relation_type FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id JOIN inventory_levels inv ON p.product_id = inv.product_id LEFT JOIN product_reviews rev ON p.product_id = rev.product_id LEFT JOIN product_sales sale ON p.product_id = sale.product_id LEFT JOIN product_images img ON p.product_id = img.product_id LEFT JOIN product_documents doc ON p.product_id = doc.product_id LEFT JOIN product_relationships rel ON p.product_id = rel.product_id WHERE p.price BETWEEN 25.00 AND 1000.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.brand_rating >= 4.0 AND inv.current_stock > inv.min_stock_level AND rev.review_rating >= 4.5 AND sale.sale_price IS NOT NULL AND img.image_type = 'main' AND doc.document_type = 'manual' AND rel.relation_type = 'accessory' AND p.weight < 10.0 AND p.warranty_period > 12 AND p.release_date > '2021-01-01' ORDER BY p.price DESC, rev.average_rating DESC LIMIT 60 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.sku, p.upc, p.weight, p.dimensions, p.warranty_period, p.release_date, p.discontinued, c.category_name, c.category_description, s.supplier_name, s.contact_name, s.contact_email, s.phone, s.country, b.brand_name, b.brand_website, inv.warehouse_name, inv.location, inv.current_stock, inv.min_stock_level, inv.max_stock_level, rev.review_rating, rev.review_count, rev.average_rating, sale.sale_price, sale.sale_start_date, sale.sale_end_date, img.image_url, img.image_type, doc.document_name, doc.document_type, rel.related_product_id, rel.relation_type FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id JOIN inventory_levels inv ON p.product_id = inv.product_id LEFT JOIN product_reviews rev ON p.product_id = rev.product_id LEFT JOIN product_sales sale ON p.product_id = sale.product_id LEFT JOIN product_images img ON p.product_id = img.product_id LEFT JOIN product_documents doc ON p.product_id = doc.product_id LEFT JOIN product_relationships rel ON p.product_id = rel.product_id WHERE p.price BETWEEN 25.00 AND 1000.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.brand_rating >= 4.0 AND inv.current_stock > inv.min_stock_level AND rev.review_rating >= 4.5 AND sale.sale_price IS NOT NULL AND img.image_type = 'main' AND doc.document_type = 'manual' AND rel.relation_type = 'accessory' AND p.weight < 10.0 AND p.warranty_period > 12 AND p.release_date > '2021-01-01' ORDER BY p.price DESC, rev.average_rating DESC LIMIT 60"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT u.user_id, u.username, u.email FROM users u WHERE u.user_id NOT IN (SELECT ul.user_id FROM user_logins ul WHERE ul.login_date > CURDATE() - INTERVAL 3 MONTH AND ul.login_type = 'mobile') AND u.created_at BETWEEN '2022-01-01' AND '2022-12-31' AND EXISTS (SELECT 1 FROM user_profiles up WHERE up.user_id = u.user_id AND up.preference = 'newsletter') AND u.status = 'active' ORDER BY u.username LIMIT 50 OFFSET 10;","output":"SELECT u.user_id, u.username, u.email FROM users AS u LEFT JOIN user_logins AS ul ON u.user_id = ul.user_id AND ul.login_date > CURDATE() - INTERVAL 3 MONTH AND ul.login_type = 'mobile' JOIN user_profiles AS up ON u.user_id = up.user_id WHERE u.created_at BETWEEN '2022-01-01' AND '2022-12-31' AND up.preference = 'newsletter' AND u.status = 'active' AND ul.user_id IS NULL ORDER BY u.username LIMIT 50 OFFSET 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_name, SUM(o.total_amount) AS total_spent, COUNT(o.order_id) AS total_orders FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id WHERE c.registration_date > '2021-01-01' AND o.order_date > '2022-01-01' AND o.total_amount IS NOT NULL AND c.customer_id IN (SELECT DISTINCT customer_id FROM loyalty_programs WHERE level = 'Gold') GROUP BY c.customer_name HAVING SUM(o.total_amount) > 1000 AND COUNT(o.order_id) >= 5 ORDER BY total_spent DESC LIMIT 20;","output":"SELECT c.customer_name, SUM(o.total_amount) AS total_spent, COUNT(o.order_id) AS total_orders FROM customers AS c LEFT JOIN orders AS o ON c.customer_id = o.customer_id JOIN loyalty_programs AS lp ON c.customer_id = lp.customer_id WHERE c.registration_date > '2021-01-01' AND o.order_date > '2022-01-01' AND o.total_amount IS NOT NULL AND lp.level = 'Gold' GROUP BY c.customer_name HAVING SUM(o.total_amount) > 1000 AND COUNT(o.order_id) >= 5 ORDER BY total_spent DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_name, p.price, (SELECT AVG(price) FROM products WHERE category_id = p.category_id) AS avg_category_price, (SELECT COUNT(DISTINCT customer_id) FROM order_items oi JOIN orders o ON oi.order_id = o.order_id WHERE oi.product_id = p.product_id AND o.order_date BETWEEN '2023-01-01' AND '2023-06-30') AS unique_buyers FROM products p WHERE p.category_id IN (SELECT category_id FROM categories WHERE category_name LIKE '%Electronic%') AND p.stock_quantity < 100 AND p.price > 500 ORDER BY unique_buyers DESC, p.price DESC LIMIT 15;","output":"WITH CategoryAvgPrice AS (SELECT category_id, AVG(price) AS avg_category_price FROM products GROUP BY category_id), UniqueBuyers AS (SELECT oi.product_id, COUNT(DISTINCT o.customer_id) AS unique_buyers FROM order_items AS oi JOIN orders AS o ON oi.order_id = o.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY oi.product_id) SELECT p.product_name, p.price, cap.avg_category_price, ub.unique_buyers FROM products AS p JOIN categories AS c ON p.category_id = c.category_id LEFT JOIN CategoryAvgPrice AS cap ON p.category_id = cap.category_id LEFT JOIN UniqueBuyers AS ub ON p.product_id = ub.product_id WHERE c.category_name LIKE '%Electronic%' AND p.stock_quantity < 100 AND p.price > 500 ORDER BY ub.unique_buyers DESC, p.price DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, d.department_name, (SELECT COUNT(*) FROM employee_projects ep WHERE ep.employee_id = e.employee_id) AS projects_count, (SELECT AVG(feedback_score) FROM project_feedback pf WHERE pf.project_id IN (SELECT project_id FROM employee_projects WHERE employee_id = e.employee_id)) AS avg_feedback FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE e.hire_date < '2020-01-01' AND e.salary > 70000 AND d.location = 'Headquarters' AND EXISTS (SELECT 1 FROM performance_reviews pr WHERE pr.employee_id = e.employee_id AND pr.review_date > '2023-01-01' AND pr.rating >= 4) ORDER BY projects_count DESC, avg_feedback DESC LIMIT 10;","output":"WITH EmployeeProjectsCount AS (SELECT employee_id, COUNT(*) AS projects_count FROM employee_projects GROUP BY employee_id), ProjectFeedbackAvg AS (SELECT ep.employee_id, AVG(pf.feedback_score) AS avg_feedback FROM employee_projects AS ep JOIN project_feedback AS pf ON ep.project_id = pf.project_id GROUP BY ep.employee_id) SELECT e.employee_id, e.first_name, e.last_name, d.department_name, epc.projects_count, pfa.avg_feedback FROM employees AS e JOIN departments AS d ON e.department_id = d.department_id LEFT JOIN EmployeeProjectsCount AS epc ON e.employee_id = epc.employee_id LEFT JOIN ProjectFeedbackAvg AS pfa ON e.employee_id = pfa.employee_id JOIN performance_reviews AS pr ON e.employee_id = pr.employee_id WHERE e.hire_date < '2020-01-01' AND e.salary > 70000 AND d.location = 'Headquarters' AND pr.review_date > '2023-01-01' AND pr.rating >= 4 ORDER BY epc.projects_count DESC, pfa.avg_feedback DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.student_name, s.student_email, c.course_name FROM students s JOIN enrollments en ON s.student_id = en.student_id JOIN courses c ON en.course_id = c.course_id WHERE s.graduation_year = 2025 AND s.major = 'Computer Science' AND c.course_credits > 3 AND c.course_id NOT IN (SELECT assignment_id FROM assignments WHERE grade < 60) AND EXISTS (SELECT 1 FROM student_awards sa WHERE sa.student_id = s.student_id AND sa.award_year = 2023) ORDER BY s.student_name ASC LIMIT 25;","output":"SELECT s.student_name, s.student_email, c.course_name FROM students AS s JOIN enrollments AS en ON s.student_id = en.student_id JOIN courses AS c ON en.course_id = c.course_id LEFT JOIN assignments AS a ON c.course_id = a.assignment_id AND a.grade < 60 JOIN student_awards AS sa ON s.student_id = sa.student_id WHERE s.graduation_year = 2025 AND s.major = 'Computer Science' AND c.course_credits > 3 AND a.assignment_id IS NULL AND sa.award_year = 2023 ORDER BY s.student_name ASC LIMIT 25;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.artist_name, COUNT(t.track_id) AS total_tracks, SUM(t.duration) AS total_duration FROM artists a LEFT JOIN albums al ON a.artist_id = al.artist_id LEFT JOIN tracks t ON al.album_id = t.album_id WHERE a.country = 'USA' AND al.release_year BETWEEN 2010 AND 2020 AND t.genre = 'Rock' AND a.artist_id NOT IN (SELECT artist_id FROM artist_awards WHERE award_year = 2023) GROUP BY a.artist_name HAVING COUNT(t.track_id) > 100 AND SUM(t.duration) > 3600 ORDER BY total_tracks DESC LIMIT 10;","output":"SELECT a.artist_name, COUNT(t.track_id) AS total_tracks, SUM(t.duration) AS total_duration FROM artists AS a LEFT JOIN albums AS al ON a.artist_id = al.artist_id LEFT JOIN tracks AS t ON al.album_id = t.album_id LEFT JOIN artist_awards AS aa ON a.artist_id = aa.artist_id AND aa.award_year = 2023 WHERE a.country = 'USA' AND al.release_year BETWEEN 2010 AND 2020 AND t.genre = 'Rock' AND aa.artist_id IS NULL GROUP BY a.artist_name HAVING COUNT(t.track_id) > 100 AND SUM(t.duration) > 3600 ORDER BY total_tracks DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, c.customer_name, p.product_name, oi.quantity FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE c.country = 'France' AND p.category_id IN (SELECT category_id FROM categories WHERE category_description LIKE '%Electronics%') AND o.order_date BETWEEN '2023-01-01' AND '2023-03-31' AND oi.price * oi.quantity > 500 ORDER BY o.order_date ASC, c.customer_name ASC LIMIT 50;","output":"SELECT o.order_id, c.customer_name, p.product_name, oi.quantity FROM orders AS o JOIN customers AS c ON o.customer_id = c.customer_id JOIN order_items AS oi ON o.order_id = oi.order_id JOIN products AS p ON oi.product_id = p.product_id JOIN categories AS cat ON p.category_id = cat.category_id WHERE c.country = 'France' AND cat.category_description LIKE '%Electronics%' AND o.order_date BETWEEN '2023-01-01' AND '2023-03-31' AND oi.price * oi.quantity > 500 ORDER BY o.order_date ASC, c.customer_name ASC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT t.ticket_id, t.subject, u.username AS reporter_name, a.username AS assignee_name FROM tickets t JOIN users u ON t.reporter_id = u.user_id LEFT JOIN users a ON t.assignee_id = a.user_id WHERE t.status = 'Open' AND t.priority IN ('High', 'Critical') AND t.created_at > CURDATE() - INTERVAL 7 DAY AND t.ticket_id NOT IN (SELECT comment_ticket_id FROM ticket_comments WHERE comment_date > CURDATE() - INTERVAL 1 DAY) ORDER BY t.priority DESC, t.created_at ASC LIMIT 20;","output":"SELECT t.ticket_id, t.subject, u.username AS reporter_name, a.username AS assignee_name FROM tickets AS t JOIN users AS u ON t.reporter_id = u.user_id LEFT JOIN users AS a ON t.assignee_id = a.user_id LEFT JOIN ticket_comments AS tc ON t.ticket_id = tc.comment_ticket_id AND tc.comment_date > CURDATE() - INTERVAL 1 DAY WHERE t.status = 'Open' AND t.priority IN ('High', 'Critical') AND t.created_at > CURDATE() - INTERVAL 7 DAY AND tc.comment_ticket_id IS NULL ORDER BY t.priority DESC, t.created_at ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT b.book_title, b.isbn, au.author_name FROM books b JOIN authors au ON b.author_id = au.author_id WHERE b.publication_year BETWEEN 2010 AND 2015 AND au.country = 'USA' AND EXISTS (SELECT 1 FROM book_reviews br WHERE br.book_id = b.book_id AND br.rating >= 4 AND br.review_date > '2023-01-01') AND b.genre IN ('Fiction', 'Science Fiction') ORDER BY b.publication_year DESC, b.book_title ASC LIMIT 30;","output":"SELECT b.book_title, b.isbn, au.author_name FROM books AS b JOIN authors AS au ON b.author_id = au.author_id JOIN book_reviews AS br ON b.book_id = br.book_id WHERE b.publication_year BETWEEN 2010 AND 2015 AND au.country = 'USA' AND br.rating >= 4 AND br.review_date > '2023-01-01' AND b.genre IN ('Fiction', 'Science Fiction') ORDER BY b.publication_year DESC, b.book_title ASC LIMIT 30;"}
{"instruction":"Optimize the SQL query","input":"SELECT s.store_name, s.city, SUM(t.sale_amount) AS total_sales, COUNT(t.transaction_id) AS total_transactions FROM stores s LEFT JOIN transactions t ON s.store_id = t.store_id WHERE s.region = 'East' AND t.transaction_date BETWEEN '2023-01-01' AND '2023-06-30' AND t.payment_method = 'Credit Card' AND s.store_id IN (SELECT store_id FROM store_employees WHERE employee_count > 50) GROUP BY s.store_name, s.city HAVING SUM(t.sale_amount) > 100000 AND COUNT(t.transaction_id) > 1000 ORDER BY total_sales DESC LIMIT 10;","output":"SELECT s.store_name, s.city, SUM(t.sale_amount) AS total_sales, COUNT(t.transaction_id) AS total_transactions FROM stores AS s LEFT JOIN transactions AS t ON s.store_id = t.store_id JOIN store_employees AS se ON s.store_id = se.store_id WHERE s.region = 'East' AND t.transaction_date BETWEEN '2023-01-01' AND '2023-06-30' AND t.payment_method = 'Credit Card' AND se.employee_count > 50 GROUP BY s.store_name, s.city HAVING SUM(t.sale_amount) > 100000 AND COUNT(t.transaction_id) > 1000 ORDER BY total_sales DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.company_name, c.industry, (SELECT COUNT(DISTINCT p.project_id) FROM projects p WHERE p.client_id = c.company_id AND p.status = 'Completed' AND p.end_date > '2022-01-01') AS completed_projects, (SELECT AVG(pr.rating) FROM project_reviews pr JOIN projects p ON pr.project_id = p.project_id WHERE p.client_id = c.company_id) AS avg_client_rating FROM companies c WHERE c.company_size > 100 AND c.industry IN ('Technology', 'Finance') AND EXISTS (SELECT 1 FROM company_partners cp WHERE cp.company_id = c.company_id AND cp.partnership_type = 'Strategic') ORDER BY completed_projects DESC, avg_client_rating DESC LIMIT 10;","output":"WITH CompletedProjects AS (SELECT p.client_id, COUNT(DISTINCT p.project_id) AS completed_projects FROM projects AS p WHERE p.status = 'Completed' AND p.end_date > '2022-01-01' GROUP BY p.client_id), AvgClientRating AS (SELECT p.client_id, AVG(pr.rating) AS avg_client_rating FROM project_reviews AS pr JOIN projects AS p ON pr.project_id = p.project_id GROUP BY p.client_id) SELECT c.company_name, c.industry, cp.completed_projects, acr.avg_client_rating FROM companies AS c LEFT JOIN CompletedProjects AS cp ON c.company_id = cp.client_id LEFT JOIN AvgClientRating AS acr ON c.company_id = acr.client_id JOIN company_partners AS cmp ON c.company_id = cmp.company_id WHERE c.company_size > 100 AND c.industry IN ('Technology', 'Finance') AND cmp.partnership_type = 'Strategic' ORDER BY completed_projects DESC, avg_client_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.username, u.registration_date FROM users u WHERE u.registration_date BETWEEN '2022-01-01' AND '2022-12-31' AND u.user_id NOT IN (SELECT DISTINCT a.user_id FROM user_activity a WHERE a.activity_type = 'post_created' AND a.activity_date > '2023-01-01') AND EXISTS (SELECT 1 FROM user_roles ur JOIN roles r ON ur.role_id = r.role_id WHERE ur.user_id = u.user_id AND r.role_name = 'Admin') ORDER BY u.registration_date DESC LIMIT 50;","output":"SELECT u.username, u.registration_date FROM users AS u LEFT JOIN user_activity AS a ON u.user_id = a.user_id AND a.activity_type = 'post_created' AND a.activity_date > '2023-01-01' JOIN user_roles AS ur ON u.user_id = ur.user_id JOIN roles AS r ON ur.role_id = r.role_id WHERE u.registration_date BETWEEN '2022-01-01' AND '2022-12-31' AND a.user_id IS NULL AND r.role_name = 'Admin' ORDER BY u.registration_date DESC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_name, c.category_name, s.supplier_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id WHERE p.price > 100 AND c.category_name NOT LIKE '%Food%' AND s.supplier_id IN (SELECT supplier_id FROM supplier_contracts WHERE contract_end_date > CURDATE()) AND p.stock_quantity < 500 ORDER BY p.price DESC, p.product_name ASC LIMIT 100;","output":"SELECT p.product_name, c.category_name, s.supplier_name FROM products AS p JOIN categories AS c ON p.category_id = c.category_id JOIN suppliers AS s ON p.supplier_id = s.supplier_id JOIN supplier_contracts AS sc ON s.supplier_id = sc.supplier_id WHERE p.price > 100 AND c.category_name NOT LIKE '%Food%' AND sc.contract_end_date > CURDATE() AND p.stock_quantity < 500 ORDER BY p.price DESC, p.product_name ASC LIMIT 100;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, c.customer_name FROM orders o JOIN customers c ON o.customer_id = c.customer_id WHERE o.order_date >= '2023-01-01' AND c.customer_id NOT IN (SELECT customer_id FROM customer_payments WHERE payment_status = 'Failed' AND payment_date > '2023-01-01') AND EXISTS (SELECT 1 FROM order_items oi WHERE oi.order_id = o.order_id AND oi.product_id IN (SELECT product_id FROM products WHERE product_type = 'Digital')) ORDER BY o.order_date DESC LIMIT 20;","output":"SELECT o.order_id, o.order_date, c.customer_name FROM orders AS o JOIN customers AS c ON o.customer_id = c.customer_id LEFT JOIN customer_payments AS cp ON c.customer_id = cp.customer_id AND cp.payment_status = 'Failed' AND cp.payment_date > '2023-01-01' JOIN order_items AS oi ON o.order_id = oi.order_id JOIN products AS p ON oi.product_id = p.product_id WHERE o.order_date >= '2023-01-01' AND cp.customer_id IS NULL AND p.product_type = 'Digital' ORDER BY o.order_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT e.employee_id, e.first_name, e.last_name FROM employees e WHERE e.department_id IN (SELECT department_id FROM departments WHERE location = 'London' OR location = 'Paris') AND e.hire_date BETWEEN '2018-01-01' AND '2022-12-31' AND e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id) AND EXISTS (SELECT 1 FROM employee_certifications ec WHERE ec.employee_id = e.employee_id AND ec.certification_date > '2023-01-01') ORDER BY e.last_name ASC, e.first_name ASC LIMIT 30;","output":"WITH DepartmentLocations AS (SELECT department_id FROM departments WHERE location = 'London' OR location = 'Paris'), AvgDeptSalary AS (SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id) SELECT e.employee_id, e.first_name, e.last_name FROM employees AS e JOIN DepartmentLocations AS dl ON e.department_id = dl.department_id JOIN AvgDeptSalary AS ads ON e.department_id = ads.department_id JOIN employee_certifications AS ec ON e.employee_id = ec.employee_id WHERE e.hire_date BETWEEN '2018-01-01' AND '2022-12-31' AND e.salary > ads.avg_salary AND ec.certification_date > '2023-01-01' ORDER BY e.last_name ASC, e.first_name ASC LIMIT 30;"}
{"instruction":"Optimize the SQL query","input":"SELECT t1.col1, t1.col2, t2.col3 FROM table1 t1 JOIN table2 t2 ON t1.id = t2.t1_id WHERE t1.col4 = 'Active' AND t2.col5 IN (SELECT col_x FROM another_table WHERE col_y > 100) AND t1.col6 LIKE '%pattern%' AND t2.col7 BETWEEN '2023-01-01' AND '2023-03-31' ORDER BY t1.col1 DESC, t2.col3 ASC LIMIT 100;","output":"SELECT t1.col1, t1.col2, t2.col3 FROM table1 AS t1 JOIN table2 AS t2 ON t1.id = t2.t1_id JOIN another_table AS at ON t2.col5 = at.col_x WHERE t1.col4 = 'Active' AND at.col_y > 100 AND t1.col6 LIKE '%pattern%' AND t2.col7 BETWEEN '2023-01-01' AND '2023-03-31' ORDER BY t1.col1 DESC, t2.col3 ASC LIMIT 100;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.username, COUNT(p.post_id) AS total_posts, AVG(c.comment_rating) AS avg_comment_rating FROM users u LEFT JOIN posts p ON u.user_id = p.user_id LEFT JOIN comments c ON p.post_id = c.post_id WHERE u.status = 'active' AND p.created_at > '2023-01-01' AND c.comment_text LIKE '%important%' GROUP BY u.username HAVING COUNT(p.post_id) > 5 AND AVG(c.comment_rating) > 3 ORDER BY total_posts DESC, avg_comment_rating DESC LIMIT 20;","output":"SELECT u.username, COUNT(p.post_id) AS total_posts, AVG(c.comment_rating) AS avg_comment_rating FROM users AS u LEFT JOIN posts AS p ON u.user_id = p.user_id LEFT JOIN comments AS c ON p.post_id = c.post_id WHERE u.status = 'active' AND p.created_at > '2023-01-01' AND c.comment_text LIKE '%important%' GROUP BY u.username HAVING COUNT(p.post_id) > 5 AND AVG(c.comment_rating) > 3 ORDER BY total_posts DESC, avg_comment_rating DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT product_name, manufacturer, price FROM products WHERE category_id = (SELECT category_id FROM categories WHERE category_name = 'Electronics') AND price > (SELECT AVG(price) FROM products WHERE manufacturer = 'Sony') AND stock_quantity > 0 AND EXISTS (SELECT 1 FROM product_reviews pr WHERE pr.product_id = products.product_id AND pr.rating = 5) ORDER BY price DESC LIMIT 20;","output":"WITH AvgSonyPrice AS (SELECT AVG(price) AS avg_price FROM products WHERE manufacturer = 'Sony') SELECT p.product_name, p.manufacturer, p.price FROM products AS p JOIN categories AS cat ON p.category_id = cat.category_id JOIN product_reviews AS pr ON p.product_id = pr.product_id, AvgSonyPrice AS asp WHERE cat.category_name = 'Electronics' AND p.price > asp.avg_price AND p.stock_quantity > 0 AND pr.rating = 5 ORDER BY p.price DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT l.location_name, l.city, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.location_id = l.location_id) AS employee_count FROM locations l WHERE l.region = 'West' AND l.location_id NOT IN (SELECT office_id FROM office_rentals WHERE rental_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM location_services ls WHERE ls.location_id = l.location_id AND ls.service_type = 'Premium') ORDER BY employee_count DESC LIMIT 15;","output":"SELECT l.location_name, l.city, COUNT(e.employee_id) AS employee_count FROM locations AS l LEFT JOIN employees AS e ON l.location_id = e.location_id LEFT JOIN office_rentals AS or ON l.location_id = or.office_id AND or.rental_end_date > CURDATE() JOIN location_services AS ls ON l.location_id = ls.location_id WHERE l.region = 'West' AND or.office_id IS NULL AND ls.service_type = 'Premium' GROUP BY l.location_name, l.city ORDER BY employee_count DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.agent_id, a.agent_name, COUNT(c.client_id) AS total_clients, SUM(t.transaction_amount) AS total_commissions FROM agents a LEFT JOIN clients c ON a.agent_id = c.agent_id LEFT JOIN transactions t ON c.client_id = t.client_id WHERE a.hire_date < '2015-01-01' AND c.client_status = 'Active' AND t.transaction_date BETWEEN '2023-01-01' AND '2023-12-31' AND a.agent_id NOT IN (SELECT agent_id FROM agent_warnings WHERE warning_date > '2023-01-01') GROUP BY a.agent_id, a.agent_name HAVING COUNT(c.client_id) > 10 AND SUM(t.transaction_amount) > 50000 ORDER BY total_commissions DESC LIMIT 10;","output":"SELECT a.agent_id, a.agent_name, COUNT(c.client_id) AS total_clients, SUM(t.transaction_amount) AS total_commissions FROM agents AS a LEFT JOIN clients AS c ON a.agent_id = c.agent_id LEFT JOIN transactions AS t ON c.client_id = t.client_id LEFT JOIN agent_warnings AS aw ON a.agent_id = aw.agent_id AND aw.warning_date > '2023-01-01' WHERE a.hire_date < '2015-01-01' AND c.client_status = 'Active' AND t.transaction_date BETWEEN '2023-01-01' AND '2023-12-31' AND aw.agent_id IS NULL GROUP BY a.agent_id, a.agent_name HAVING COUNT(c.client_id) > 10 AND SUM(t.transaction_amount) > 50000 ORDER BY total_commissions DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.store_id, s.store_name, s.address FROM stores s WHERE s.city = 'Houston' AND s.store_id IN (SELECT store_id FROM daily_sales ds WHERE ds.sale_date = CURDATE() AND ds.total_sales > 10000) AND EXISTS (SELECT 1 FROM store_feedback sf WHERE sf.store_id = s.store_id AND sf.feedback_score >= 4.5) AND s.store_type = 'Supermarket' ORDER BY s.store_name ASC LIMIT 10;","output":"SELECT s.store_id, s.store_name, s.address FROM stores AS s JOIN daily_sales AS ds ON s.store_id = ds.store_id JOIN store_feedback AS sf ON s.store_id = sf.store_id WHERE s.city = 'Houston' AND ds.sale_date = CURDATE() AND ds.total_sales > 10000 AND sf.feedback_score >= 4.5 AND s.store_type = 'Supermarket' ORDER BY s.store_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT d.department_name, AVG(e.salary) AS avg_dept_salary, COUNT(e.employee_id) AS num_employees FROM departments d JOIN employees e ON d.department_id = e.department_id WHERE e.hire_date BETWEEN '2020-01-01' AND '2022-12-31' AND e.position NOT LIKE '%Trainee%' AND d.department_id NOT IN (SELECT department_id FROM department_budgets WHERE budget_year = 2023 AND actual_spend > allocated_budget) GROUP BY d.department_name HAVING AVG(e.salary) > 60000 AND COUNT(e.employee_id) > 5 ORDER BY avg_dept_salary DESC LIMIT 10;","output":"SELECT d.department_name, AVG(e.salary) AS avg_dept_salary, COUNT(e.employee_id) AS num_employees FROM departments AS d JOIN employees AS e ON d.department_id = e.department_id LEFT JOIN department_budgets AS db ON d.department_id = db.department_id AND db.budget_year = 2023 AND db.actual_spend > db.allocated_budget WHERE e.hire_date BETWEEN '2020-01-01' AND '2022-12-31' AND e.position NOT LIKE '%Trainee%' AND db.department_id IS NULL GROUP BY d.department_name HAVING AVG(e.salary) > 60000 AND COUNT(e.employee_id) > 5 ORDER BY avg_dept_salary DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_name, c.start_date, c.end_date FROM campaigns c WHERE c.campaign_type = 'Email' AND c.status = 'Active' AND c.start_date > '2023-01-01' AND EXISTS (SELECT 1 FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.conversion_rate > 0.05 AND cm.cost_per_conversion < 10) AND c.campaign_id NOT IN (SELECT campaign_id FROM campaign_issues ci WHERE ci.issue_severity = 'Critical') ORDER BY c.start_date DESC LIMIT 20;","output":"SELECT c.campaign_name, c.start_date, c.end_date FROM campaigns AS c JOIN campaign_metrics AS cm ON c.campaign_id = cm.campaign_id LEFT JOIN campaign_issues AS ci ON c.campaign_id = ci.campaign_id AND ci.issue_severity = 'Critical' WHERE c.campaign_type = 'Email' AND c.status = 'Active' AND c.start_date > '2023-01-01' AND cm.conversion_rate > 0.05 AND cm.cost_per_conversion < 10 AND ci.campaign_id IS NULL ORDER BY c.start_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, COUNT(p.photo_id) AS total_photos, SUM(p.views) AS total_views FROM users u LEFT JOIN photos p ON u.user_id = p.user_id WHERE u.country = 'Canada' AND u.registration_date BETWEEN '2021-01-01' AND '2022-12-31' AND p.upload_date > '2023-01-01' AND p.photo_id NOT IN (SELECT flag_photo_id FROM flagged_photos WHERE flag_reason = 'Inappropriate') GROUP BY u.user_id, u.username HAVING COUNT(p.photo_id) > 10 AND SUM(p.views) > 10000 ORDER BY total_views DESC LIMIT 15;","output":"SELECT u.user_id, u.username, COUNT(p.photo_id) AS total_photos, SUM(p.views) AS total_views FROM users AS u LEFT JOIN photos AS p ON u.user_id = p.user_id LEFT JOIN flagged_photos AS fp ON p.photo_id = fp.flag_photo_id AND fp.flag_reason = 'Inappropriate' WHERE u.country = 'Canada' AND u.registration_date BETWEEN '2021-01-01' AND '2022-12-31' AND p.upload_date > '2023-01-01' AND fp.flag_photo_id IS NULL GROUP BY u.user_id, u.username HAVING COUNT(p.photo_id) > 10 AND SUM(p.views) > 10000 ORDER BY total_views DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, o.shipping_cost, o.tax_amount, o.discount_amount, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.payment_method, p.payment_status, p.transaction_id, s.shipping_method, s.tracking_number, s.carrier, s.estimated_delivery, s.actual_delivery_date, i.item_name, i.quantity, i.unit_price, i.discount_percentage, prom.promotion_name, prom.discount_type, tax.tax_rate, tax.tax_amount, ref.referral_source, ref.campaign_name FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id JOIN order_items i ON o.order_id = i.order_id LEFT JOIN promotions prom ON o.promotion_id = prom.promotion_id JOIN tax_calculations tax ON o.order_id = tax.order_id LEFT JOIN referral_sources ref ON o.referral_id = ref.referral_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 150.00 AND o.status IN ('completed', 'shipped', 'delivered') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX', 'FL', 'IL') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority', 'overnight') AND s.estimated_delivery > CURRENT_DATE - INTERVAL '30 days' AND i.quantity > 1 AND prom.discount_type = 'percentage' AND tax.tax_rate BETWEEN 0.05 AND 0.15 AND ref.campaign_name IS NOT NULL ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 100 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, o.shipping_cost, o.tax_amount, o.discount_amount, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.payment_method, p.payment_status, p.transaction_id, s.shipping_method, s.tracking_number, s.carrier, s.estimated_delivery, s.actual_delivery_date, i.item_name, i.quantity, i.unit_price, i.discount_percentage, prom.promotion_name, prom.discount_type, tax.tax_rate, tax.tax_amount, ref.referral_source, ref.campaign_name FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id JOIN order_items i ON o.order_id = i.order_id LEFT JOIN promotions prom ON o.promotion_id = prom.promotion_id JOIN tax_calculations tax ON o.order_id = tax.order_id LEFT JOIN referral_sources ref ON o.referral_id = ref.referral_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 150.00 AND o.status IN ('completed', 'shipped', 'delivered') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX', 'FL', 'IL') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority', 'overnight') AND s.estimated_delivery > CURRENT_DATE - INTERVAL '30 days' AND i.quantity > 1 AND prom.discount_type = 'percentage' AND tax.tax_rate BETWEEN 0.05 AND 0.15 AND ref.campaign_name IS NOT NULL ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.sku, inv.upc, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, inv.reorder_point, wh.warehouse_name, wh.location, wh.capacity, wh.manager_name, s.supplier_name, s.contact_email, s.phone, s.rating, cat.category_name, cat.category_description, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, aud.auditor_name, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery, sup.supply_cost, sup.lead_time, qua.quality_score, qua.inspection_date FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id LEFT JOIN supply_costs sup ON inv.supplier_id = sup.supplier_id LEFT JOIN quality_controls qua ON inv.inventory_id = qua.inventory_id WHERE inv.current_stock < inv.reorder_point AND inv.unit_cost > 20.00 AND wh.capacity > 5000 AND s.rating >= 4.2 AND cat.category_name IN ('raw_materials', 'components', 'finished_goods') AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-03-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND sup.lead_time < 14 AND qua.quality_score >= 90 AND inv.total_value > 3000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC, sup.lead_time ASC LIMIT 80 OFFSET 0","output":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.sku, inv.upc, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, inv.reorder_point, wh.warehouse_name, wh.location, wh.capacity, wh.manager_name, s.supplier_name, s.contact_email, s.phone, s.rating, cat.category_name, cat.category_description, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, aud.auditor_name, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery, sup.supply_cost, sup.lead_time, qua.quality_score, qua.inspection_date FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id LEFT JOIN supply_costs sup ON inv.supplier_id = sup.supplier_id LEFT JOIN quality_controls qua ON inv.inventory_id = qua.inventory_id WHERE inv.current_stock < inv.reorder_point AND inv.unit_cost > 20.00 AND wh.capacity > 5000 AND s.rating >= 4.2 AND cat.category_name IN ('raw_materials', 'components', 'finished_goods') AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-03-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND sup.lead_time < 14 AND qua.quality_score >= 90 AND inv.total_value > 3000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC, sup.lead_time ASC LIMIT 80"}
{"instruction":"Optimize the SQL query","input":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.term_months, loan.status, loan.purpose, c.customer_name, c.credit_score, c.annual_income, c.employment_status, e.employee_name, e.department, br.branch_name, br.branch_region, pt.payment_term, pt.number_of_payments, sch.due_date, sch.amount_due, sch.paid_amount, sch.payment_status, coll.collection_status, coll.collection_date, coll.collection_amount, coll.collector_name, risk.risk_level, risk.risk_score, risk.risk_description, doc.document_name, doc.document_status, doc.verification_date, ins.insurance_amount, ins.insurance_provider, ins.policy_number, g.guarantor_name, g.guarantor_relationship, g.guarantor_income FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id LEFT JOIN guarantors g ON loan.loan_id = g.loan_id WHERE loan.amount > 30000.00 AND loan.interest_rate < 7.50 AND loan.start_date > '2021-01-01' AND loan.status = 'active' AND c.credit_score > 720 AND c.annual_income > 75000 AND e.department = 'lending' AND br.branch_region IN ('northeast', 'midwest') AND pt.number_of_payments > 24 AND sch.due_date BETWEEN '2023-10-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > loan.amount * 0.8 AND g.guarantor_income > 50000 ORDER BY loan.amount DESC, loan.interest_rate ASC, c.credit_score DESC LIMIT 65 OFFSET 0","output":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.term_months, loan.status, loan.purpose, c.customer_name, c.credit_score, c.annual_income, c.employment_status, e.employee_name, e.department, br.branch_name, br.branch_region, pt.payment_term, pt.number_of_payments, sch.due_date, sch.amount_due, sch.paid_amount, sch.payment_status, coll.collection_status, coll.collection_date, coll.collection_amount, coll.collector_name, risk.risk_level, risk.risk_score, risk.risk_description, doc.document_name, doc.document_status, doc.verification_date, ins.insurance_amount, ins.insurance_provider, ins.policy_number, g.guarantor_name, g.guarantor_relationship, g.guarantor_income FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id LEFT JOIN guarantors g ON loan.loan_id = g.loan_id WHERE loan.amount > 30000.00 AND loan.interest_rate < 7.50 AND loan.start_date > '2021-01-01' AND loan.status = 'active' AND c.credit_score > 720 AND c.annual_income > 75000 AND e.department = 'lending' AND br.branch_region IN ('northeast', 'midwest') AND pt.number_of_payments > 24 AND sch.due_date BETWEEN '2023-10-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > loan.amount * 0.8 AND g.guarantor_income > 50000 ORDER BY loan.amount DESC, loan.interest_rate ASC, c.credit_score DESC LIMIT 65"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.estimated_profit, p.status, p.priority, c.client_name, c.industry, c.client_rating, m.first_name AS manager_first, m.last_name AS manager_last, m.email AS manager_email, d.department_name, d.department_budget, t.team_name, t.team_size, t.team_location, r.risk_level, r.risk_description, r.impact_level, r.mitigation_plan, de.deliverable_name, de.description AS deliverable_desc, de.status AS deliverable_status, de.due_date, res.resource_name, res.resource_type, res.cost_rate, res.availability, times.hours_worked, times.overtime_hours, times.entry_date, exp.expense_type, exp.amount, exp.expense_date, mil.milestone_name, mil.completion_date, mil.status AS milestone_status FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id LEFT JOIN project_expenses exp ON p.project_id = exp.project_id LEFT JOIN project_milestones mil ON p.project_id = mil.project_id WHERE p.start_date > '2021-06-01' AND p.budget > 75000.00 AND p.status IN ('in_progress', 'planning') AND c.industry IN ('Technology', 'Finance', 'Healthcare', 'Manufacturing') AND c.client_rating >= 4.0 AND d.department_name = 'R&D' AND t.team_size > 6 AND r.risk_level IN ('medium', 'high') AND de.status = 'in_progress' AND res.resource_type = 'human' AND res.cost_rate > 45.00 AND times.hours_worked > 30 AND times.entry_date > '2023-02-01' AND exp.amount > 1000.00 AND mil.status = 'completed' ORDER BY p.budget DESC, p.priority ASC, p.start_date ASC LIMIT 45 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.estimated_profit, p.status, p.priority, c.client_name, c.industry, c.client_rating, m.first_name AS manager_first, m.last_name AS manager_last, m.email AS manager_email, d.department_name, d.department_budget, t.team_name, t.team_size, t.team_location, r.risk_level, r.risk_description, r.impact_level, r.mitigation_plan, de.deliverable_name, de.description AS deliverable_desc, de.status AS deliverable_status, de.due_date, res.resource_name, res.resource_type, res.cost_rate, res.availability, times.hours_worked, times.overtime_hours, times.entry_date, exp.expense_type, exp.amount, exp.expense_date, mil.milestone_name, mil.completion_date, mil.status AS milestone_status FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id LEFT JOIN project_expenses exp ON p.project_id = exp.project_id LEFT JOIN project_milestones mil ON p.project_id = mil.project_id WHERE p.start_date > '2021-06-01' AND p.budget > 75000.00 AND p.status IN ('in_progress', 'planning') AND c.industry IN ('Technology', 'Finance', 'Healthcare', 'Manufacturing') AND c.client_rating >= 4.0 AND d.department_name = 'R&D' AND t.team_size > 6 AND r.risk_level IN ('medium', 'high') AND de.status = 'in_progress' AND res.resource_type = 'human' AND res.cost_rate > 45.00 AND times.hours_worked > 30 AND times.entry_date > '2023-02-01' AND exp.amount > 1000.00 AND mil.status = 'completed' ORDER BY p.budget DESC, p.priority ASC, p.start_date ASC LIMIT 45"}
{"instruction":"Optimize the SQL query","input":"SELECT s.sale_id, s.sale_date, s.total_amount, s.tax_amount, s.discount_amount, s.shipping_cost, s.payment_method, s.transaction_id, c.customer_name, c.membership_level, c.loyalty_points, e.employee_name, e.department, st.store_name, st.location, st.store_size, p.product_name, p.category, p.brand, sd.quantity, sd.unit_price, sd.discount_percentage, prom.promotion_name, prom.discount_type, prom.start_date AS promo_start, prom.end_date AS promo_end, tax.tax_rate, tax.tax_amount, del.delivery_status, del.carrier, del.tracking_number, del.estimated_delivery, del.actual_delivery_date, ret.return_reason, ret.return_status, ret.refund_amount, pay.payment_status, pay.authorization_code, inv.inventory_level, sup.supplier_name FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id LEFT JOIN returns ret ON s.sale_id = ret.sale_id JOIN payments pay ON s.sale_id = pay.sale_id JOIN inventory_levels inv ON p.product_id = inv.product_id JOIN suppliers sup ON p.supplier_id = sup.supplier_id WHERE s.sale_date BETWEEN '2023-07-01' AND '2023-12-31' AND s.total_amount > 250.00 AND s.payment_method IN ('credit_card', 'debit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum', 'diamond') AND e.department = 'sales' AND st.location LIKE '%shopping%' AND p.category = 'electronics' AND sd.quantity > 1 AND prom.discount_type = 'percentage' AND tax.tax_rate BETWEEN 0.06 AND 0.12 AND del.delivery_status = 'delivered' AND pay.payment_status = 'completed' AND inv.inventory_level > 10 AND sup.supplier_rating >= 4.3 ORDER BY s.total_amount DESC, s.sale_date DESC, c.loyalty_points DESC LIMIT 90 OFFSET 0","output":"SELECT s.sale_id, s.sale_date, s.total_amount, s.tax_amount, s.discount_amount, s.shipping_cost, s.payment_method, s.transaction_id, c.customer_name, c.membership_level, c.loyalty_points, e.employee_name, e.department, st.store_name, st.location, st.store_size, p.product_name, p.category, p.brand, sd.quantity, sd.unit_price, sd.discount_percentage, prom.promotion_name, prom.discount_type, prom.start_date AS promo_start, prom.end_date AS promo_end, tax.tax_rate, tax.tax_amount, del.delivery_status, del.carrier, del.tracking_number, del.estimated_delivery, del.actual_delivery_date, ret.return_reason, ret.return_status, ret.refund_amount, pay.payment_status, pay.authorization_code, inv.inventory_level, sup.supplier_name FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id LEFT JOIN returns ret ON s.sale_id = ret.sale_id JOIN payments pay ON s.sale_id = pay.sale_id JOIN inventory_levels inv ON p.product_id = inv.product_id JOIN suppliers sup ON p.supplier_id = sup.supplier_id WHERE s.sale_date BETWEEN '2023-07-01' AND '2023-12-31' AND s.total_amount > 250.00 AND s.payment_method IN ('credit_card', 'debit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum', 'diamond') AND e.department = 'sales' AND st.location LIKE '%shopping%' AND p.category = 'electronics' AND sd.quantity > 1 AND prom.discount_type = 'percentage' AND tax.tax_rate BETWEEN 0.06 AND 0.12 AND del.delivery_status = 'delivered' AND pay.payment_status = 'completed' AND inv.inventory_level > 10 AND sup.supplier_rating >= 4.3 ORDER BY s.total_amount DESC, s.sale_date DESC, c.loyalty_points DESC LIMIT 90"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.store_id, s.store_name FROM stores s WHERE s.region = 'North' AND s.store_id IN (SELECT DISTINCT sales.store_id FROM sales WHERE sales.sale_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY sales.store_id HAVING SUM(sales.amount) > 100000) AND EXISTS (SELECT 1 FROM store_feedback sf WHERE sf.store_id = s.store_id AND sf.rating = 5 AND sf.feedback_date > '2023-01-01') AND s.establishment_date < '2010-01-01' ORDER BY s.store_name ASC LIMIT 10;","output":"SELECT s.store_id, s.store_name FROM stores AS s JOIN (SELECT store_id FROM sales WHERE sale_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY store_id HAVING SUM(amount) > 100000) AS recent_high_sales ON s.store_id = recent_high_sales.store_id JOIN store_feedback AS sf ON s.store_id = sf.store_id WHERE s.region = 'North' AND sf.rating = 5 AND sf.feedback_date > '2023-01-01' AND s.establishment_date < '2010-01-01' ORDER BY s.store_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_name, p.price, (SELECT COUNT(oi.order_item_id) FROM order_items oi WHERE oi.product_id = p.product_id) AS total_sold_items FROM products p WHERE p.category_id = (SELECT c.category_id FROM categories c WHERE c.category_name = 'Books') AND p.price > 20 AND p.stock_quantity > 0 ORDER BY total_sold_items DESC, p.price DESC LIMIT 20;","output":"SELECT p.product_name, p.price, COALESCE(SUM(oi.order_item_id) OVER (PARTITION BY p.product_id), 0) AS total_sold_items FROM products AS p JOIN categories AS c ON p.category_id = c.category_id LEFT JOIN order_items AS oi ON p.product_id = oi.product_id WHERE c.category_name = 'Books' AND p.price > 20 AND p.stock_quantity > 0 ORDER BY total_sold_items DESC, p.price DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, d.department_name, (SELECT MAX(pa.performance_score) FROM performance_appraisals pa WHERE pa.employee_id = e.employee_id AND pa.appraisal_date > '2023-01-01') AS latest_score FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE e.hire_date BETWEEN '2018-01-01' AND '2022-12-31' AND e.status = 'active' AND d.department_name NOT IN ('HR', 'Legal') ORDER BY latest_score DESC, e.last_name ASC LIMIT 15;","output":"SELECT e.employee_id, e.first_name, e.last_name, d.department_name, MAX(pa.performance_score) AS latest_score FROM employees AS e JOIN departments AS d ON e.department_id = d.department_id LEFT JOIN performance_appraisals AS pa ON e.employee_id = pa.employee_id WHERE e.hire_date BETWEEN '2018-01-01' AND '2022-12-31' AND e.status = 'active' AND d.department_name NOT IN ('HR', 'Legal') AND pa.appraisal_date > '2023-01-01' GROUP BY e.employee_id, e.first_name, e.last_name, d.department_name ORDER BY latest_score DESC, e.last_name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, SUM(o.total_amount) AS total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id WHERE c.registration_date > '2020-01-01' AND o.order_date > '2022-01-01' AND c.customer_id IN (SELECT customer_id FROM customer_preferences cp WHERE cp.marketing_opt_in = TRUE) GROUP BY c.customer_id, c.customer_name HAVING SUM(o.total_amount) > 5000 AND COUNT(o.order_id) >= 3 ORDER BY total_spent DESC LIMIT 25 OFFSET 5;","output":"SELECT c.customer_id, c.customer_name, SUM(o.total_amount) AS total_spent FROM customers AS c JOIN orders AS o ON c.customer_id = o.customer_id JOIN customer_preferences AS cp ON c.customer_id = cp.customer_id WHERE c.registration_date > '2020-01-01' AND o.order_date > '2022-01-01' AND cp.marketing_opt_in = TRUE GROUP BY c.customer_id, c.customer_name HAVING SUM(o.total_amount) > 5000 AND COUNT(o.order_id) >= 3 ORDER BY total_spent DESC LIMIT 25 OFFSET 5;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.airport_name, a.city, (SELECT COUNT(f.flight_id) FROM flights f WHERE f.departure_airport_id = a.airport_id AND f.flight_date = CURDATE()) AS daily_departures, (SELECT COUNT(f2.flight_id) FROM flights f2 WHERE f2.arrival_airport_id = a.airport_id AND f2.flight_date = CURDATE()) AS daily_arrivals FROM airports a WHERE a.country = 'USA' AND a.airport_id NOT IN (SELECT r.airport_id FROM runway_issues r WHERE r.issue_date = CURDATE()) ORDER BY daily_departures DESC, daily_arrivals DESC LIMIT 10;","output":"WITH DailyDepartures AS (SELECT departure_airport_id AS airport_id, COUNT(flight_id) AS daily_departures FROM flights WHERE flight_date = CURDATE() GROUP BY departure_airport_id), DailyArrivals AS (SELECT arrival_airport_id AS airport_id, COUNT(flight_id) AS daily_arrivals FROM flights WHERE flight_date = CURDATE() GROUP BY arrival_airport_id) SELECT a.airport_name, a.city, COALESCE(dd.daily_departures, 0) AS daily_departures, COALESCE(da.daily_arrivals, 0) AS daily_arrivals FROM airports AS a LEFT JOIN DailyDepartures AS dd ON a.airport_id = dd.airport_id LEFT JOIN DailyArrivals AS da ON a.airport_id = da.airport_id LEFT JOIN runway_issues AS ri ON a.airport_id = ri.airport_id AND ri.issue_date = CURDATE() WHERE a.country = 'USA' AND ri.airport_id IS NULL ORDER BY daily_departures DESC, daily_arrivals DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.station_name, s.location, (SELECT AVG(CAST(pm.temperature AS DECIMAL(5,2))) FROM weather_readings pm WHERE pm.station_id = s.station_id AND pm.reading_date BETWEEN '2023-07-01' AND '2023-07-31') AS avg_july_temp, (SELECT MAX(pm2.humidity) FROM weather_readings pm2 WHERE pm2.station_id = s.station_id AND pm2.reading_date BETWEEN '2023-07-01' AND '2023-07-31') AS max_july_humidity FROM weather_stations s WHERE s.elevation > 1000 AND s.station_type = 'Automated' ORDER BY avg_july_temp DESC, max_july_humidity DESC LIMIT 10;","output":"WITH JulyReadings AS (SELECT station_id, AVG(CAST(temperature AS DECIMAL(5,2))) AS avg_july_temp, MAX(humidity) AS max_july_humidity FROM weather_readings WHERE reading_date BETWEEN '2023-07-01' AND '2023-07-31' GROUP BY station_id) SELECT s.station_name, s.location, jr.avg_july_temp, jr.max_july_humidity FROM weather_stations AS s JOIN JulyReadings AS jr ON s.station_id = jr.station_id WHERE s.elevation > 1000 AND s.station_type = 'Automated' ORDER BY jr.avg_july_temp DESC, jr.max_july_humidity DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, COUNT(DISTINCT l.log_id) AS total_logins, SUM(l.duration_seconds) AS total_time_spent FROM users u LEFT JOIN user_logs l ON u.user_id = l.user_id WHERE u.status = 'active' AND l.log_date > '2023-01-01' AND l.log_type = 'session' AND u.user_id NOT IN (SELECT user_id FROM user_bans WHERE ban_end_date > CURDATE()) GROUP BY u.user_id, u.username HAVING COUNT(DISTINCT l.log_id) > 50 AND SUM(l.duration_seconds) > 36000 ORDER BY total_time_spent DESC LIMIT 20;","output":"SELECT u.user_id, u.username, COUNT(DISTINCT l.log_id) AS total_logins, SUM(l.duration_seconds) AS total_time_spent FROM users AS u LEFT JOIN user_logs AS l ON u.user_id = l.user_id LEFT JOIN user_bans AS ub ON u.user_id = ub.user_id AND ub.ban_end_date > CURDATE() WHERE u.status = 'active' AND l.log_date > '2023-01-01' AND l.log_type = 'session' AND ub.user_id IS NULL GROUP BY u.user_id, u.username HAVING COUNT(DISTINCT l.log_id) > 50 AND SUM(l.duration_seconds) > 36000 ORDER BY total_time_spent DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.policy_id, p.policy_holder_name, p.premium_amount FROM policies p WHERE p.policy_status = 'Active' AND p.issue_date BETWEEN '2020-01-01' AND '2023-12-31' AND p.policy_type = 'Life Insurance' AND p.policy_id IN (SELECT cl.policy_id FROM claims cl WHERE cl.claim_status = 'Approved' AND cl.claim_date > '2023-01-01') AND EXISTS (SELECT 1 FROM policy_renewals pr WHERE pr.policy_id = p.policy_id AND pr.renewal_date = '2024-01-01') ORDER BY p.premium_amount DESC LIMIT 10;","output":"SELECT p.policy_id, p.policy_holder_name, p.premium_amount FROM policies AS p JOIN claims AS cl ON p.policy_id = cl.policy_id JOIN policy_renewals AS pr ON p.policy_id = pr.policy_id WHERE p.policy_status = 'Active' AND p.issue_date BETWEEN '2020-01-01' AND '2023-12-31' AND p.policy_type = 'Life Insurance' AND cl.claim_status = 'Approved' AND cl.claim_date > '2023-01-01' AND pr.renewal_date = '2024-01-01' ORDER BY p.premium_amount DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT d.drug_name, d.manufacturer, SUM(s.quantity_sold) AS total_quantity_sold FROM drugs d JOIN sales s ON d.drug_id = s.drug_id WHERE d.is_prescription_required = TRUE AND s.sale_date BETWEEN '2023-01-01' AND '2023-06-30' AND d.drug_id NOT IN (SELECT rd.drug_id FROM drug_recalls rd WHERE rd.recall_date > '2023-01-01') GROUP BY d.drug_name, d.manufacturer HAVING SUM(s.quantity_sold) > 10000 ORDER BY total_quantity_sold DESC LIMIT 10;","output":"SELECT d.drug_name, d.manufacturer, SUM(s.quantity_sold) AS total_quantity_sold FROM drugs AS d JOIN sales AS s ON d.drug_id = s.drug_id LEFT JOIN drug_recalls AS dr ON d.drug_id = dr.drug_id AND dr.recall_date > '2023-01-01' WHERE d.is_prescription_required = TRUE AND s.sale_date BETWEEN '2023-01-01' AND '2023-06-30' AND dr.drug_id IS NULL GROUP BY d.drug_name, d.manufacturer HAVING SUM(s.quantity_sold) > 10000 ORDER BY total_quantity_sold DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT f.fund_name, f.fund_manager FROM funds f WHERE f.fund_type = 'Equity' AND f.inception_date < '2015-01-01' AND EXISTS (SELECT 1 FROM fund_performance fp WHERE fp.fund_id = f.fund_id AND fp.performance_year = 2023 AND fp.return_percentage > 10) AND f.fund_id NOT IN (SELECT ia.fund_id FROM investment_alerts ia WHERE ia.alert_type = 'High Risk' AND ia.alert_date > '2023-01-01') ORDER BY f.fund_name ASC LIMIT 15;","output":"SELECT f.fund_name, f.fund_manager FROM funds AS f JOIN fund_performance AS fp ON f.fund_id = fp.fund_id LEFT JOIN investment_alerts AS ia ON f.fund_id = ia.fund_id AND ia.alert_type = 'High Risk' AND ia.alert_date > '2023-01-01' WHERE f.fund_type = 'Equity' AND f.inception_date < '2015-01-01' AND fp.performance_year = 2023 AND fp.return_percentage > 10 AND ia.fund_id IS NULL ORDER BY f.fund_name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.author_name, COUNT(b.book_id) AS total_books, AVG(b.rating) AS avg_book_rating FROM authors a LEFT JOIN books b ON a.author_id = b.author_id WHERE a.country = 'UK' AND b.publication_year BETWEEN 2000 AND 2020 AND b.genre IN ('Fantasy', 'Mystery') AND a.author_id NOT IN (SELECT pa.author_id FROM author_penalties pa WHERE pa.penalty_date > '2023-01-01') GROUP BY a.author_name HAVING COUNT(b.book_id) > 5 AND AVG(b.rating) > 4.0 ORDER BY total_books DESC, avg_book_rating DESC LIMIT 10;","output":"SELECT a.author_name, COUNT(b.book_id) AS total_books, AVG(b.rating) AS avg_book_rating FROM authors AS a LEFT JOIN books AS b ON a.author_id = b.author_id LEFT JOIN author_penalties AS ap ON a.author_id = ap.author_id AND ap.penalty_date > '2023-01-01' WHERE a.country = 'UK' AND b.publication_year BETWEEN 2000 AND 2020 AND b.genre IN ('Fantasy', 'Mystery') AND ap.author_id IS NULL GROUP BY a.author_name HAVING COUNT(b.book_id) > 5 AND AVG(b.rating) > 4.0 ORDER BY total_books DESC, avg_book_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.course_name, c.course_code, (SELECT COUNT(e.enrollment_id) FROM enrollments e WHERE e.course_id = c.course_id AND e.enrollment_date > '2023-01-01') AS recent_enrollments, (SELECT AVG(s.score) FROM student_scores s WHERE s.course_id = c.course_id) AS avg_score FROM courses c WHERE c.department = 'Computer Science' AND c.credits >= 3 AND c.course_id NOT IN (SELECT r.course_id FROM course_reviews r WHERE r.review_rating < 3 AND r.review_date > '2023-01-01') ORDER BY recent_enrollments DESC, avg_score DESC LIMIT 10;","output":"WITH RecentEnrollments AS (SELECT course_id, COUNT(enrollment_id) AS recent_enrollments FROM enrollments WHERE enrollment_date > '2023-01-01' GROUP BY course_id), AvgScores AS (SELECT course_id, AVG(score) AS avg_score FROM student_scores GROUP BY course_id) SELECT c.course_name, c.course_code, COALESCE(re.recent_enrollments, 0) AS recent_enrollments, COALESCE(asc.avg_score, 0) AS avg_score FROM courses AS c LEFT JOIN RecentEnrollments AS re ON c.course_id = re.course_id LEFT JOIN AvgScores AS asc ON c.course_id = asc.course_id LEFT JOIN course_reviews AS cr ON c.course_id = cr.course_id AND cr.review_rating < 3 AND cr.review_date > '2023-01-01' WHERE c.department = 'Computer Science' AND c.credits >= 3 AND cr.course_id IS NULL ORDER BY recent_enrollments DESC, avg_score DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT l.library_name, l.city, (SELECT COUNT(b.book_id) FROM books b WHERE b.library_id = l.library_id AND b.publication_year = 2023) AS new_books_2023 FROM libraries l WHERE l.region = 'South' AND l.library_id NOT IN (SELECT bl.library_id FROM blocked_libraries bl WHERE bl.block_reason = 'Overdue Fines' AND bl.block_date > '2023-01-01') AND EXISTS (SELECT 1 FROM library_events le WHERE le.library_id = l.library_id AND le.event_type = 'Reading Club' AND le.event_date > '2023-06-01') ORDER BY new_books_2023 DESC, l.library_name ASC LIMIT 10;","output":"SELECT l.library_name, l.city, COALESCE(COUNT(b.book_id) OVER (PARTITION BY l.library_id), 0) AS new_books_2023 FROM libraries AS l LEFT JOIN books AS b ON l.library_id = b.library_id AND b.publication_year = 2023 LEFT JOIN blocked_libraries AS bl ON l.library_id = bl.library_id AND bl.block_reason = 'Overdue Fines' AND bl.block_date > '2023-01-01' JOIN library_events AS le ON l.library_id = le.library_id WHERE l.region = 'South' AND bl.library_id IS NULL AND le.event_type = 'Reading Club' AND le.event_date > '2023-06-01' GROUP BY l.library_name, l.city ORDER BY new_books_2023 DESC, l.library_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.item_name, inv.quantity_on_hand, inv.last_restock_date FROM inventory inv WHERE inv.warehouse_id = (SELECT w.warehouse_id FROM warehouses w WHERE w.location = 'Central') AND inv.quantity_on_hand < 50 AND inv.item_id NOT IN (SELECT oi.item_id FROM outdated_items oi WHERE oi.obsolete_date < CURDATE()) AND EXISTS (SELECT 1 FROM item_suppliers isu WHERE isu.item_id = inv.item_id AND isu.supplier_name = 'MegaCorp') ORDER BY inv.quantity_on_hand ASC, inv.last_restock_date DESC LIMIT 20;","output":"SELECT inv.item_name, inv.quantity_on_hand, inv.last_restock_date FROM inventory AS inv JOIN warehouses AS w ON inv.warehouse_id = w.warehouse_id LEFT JOIN outdated_items AS oi ON inv.item_id = oi.item_id AND oi.obsolete_date < CURDATE() JOIN item_suppliers AS isu ON inv.item_id = isu.item_id WHERE w.location = 'Central' AND inv.quantity_on_hand < 50 AND oi.item_id IS NULL AND isu.supplier_name = 'MegaCorp' ORDER BY inv.quantity_on_hand ASC, inv.last_restock_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.trainer_name, tr.specialty, COUNT(cl.client_id) AS total_clients, AVG(cl.sessions_completed) AS avg_sessions FROM trainers tr LEFT JOIN clients cl ON tr.trainer_id = cl.trainer_id WHERE tr.experience_years > 5 AND tr.specialty IN ('Weightlifting', 'Cardio') AND cl.start_date > '2023-01-01' AND tr.trainer_id NOT IN (SELECT ta.trainer_id FROM trainer_absences ta WHERE ta.absence_date BETWEEN '2023-01-01' AND '2023-12-31') GROUP BY tr.trainer_name, tr.specialty HAVING COUNT(cl.client_id) > 10 AND AVG(cl.sessions_completed) > 20 ORDER BY total_clients DESC, avg_sessions DESC LIMIT 10;","output":"SELECT tr.trainer_name, tr.specialty, COUNT(cl.client_id) AS total_clients, AVG(cl.sessions_completed) AS avg_sessions FROM trainers AS tr LEFT JOIN clients AS cl ON tr.trainer_id = cl.trainer_id LEFT JOIN trainer_absences AS ta ON tr.trainer_id = ta.trainer_id AND ta.absence_date BETWEEN '2023-01-01' AND '2023-12-31' WHERE tr.experience_years > 5 AND tr.specialty IN ('Weightlifting', 'Cardio') AND cl.start_date > '2023-01-01' AND ta.trainer_id IS NULL GROUP BY tr.trainer_name, tr.specialty HAVING COUNT(cl.client_id) > 10 AND AVG(cl.sessions_completed) > 20 ORDER BY total_clients DESC, avg_sessions DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT m.movie_title, m.release_year, d.director_name FROM movies m JOIN directors d ON m.director_id = d.director_id WHERE m.genre = 'Drama' AND m.release_year BETWEEN 2010 AND 2020 AND m.movie_id NOT IN (SELECT ur.movie_id FROM user_ratings ur WHERE ur.rating < 3 AND ur.rating_date > '2023-01-01') AND EXISTS (SELECT 1 FROM movie_awards ma WHERE ma.movie_id = m.movie_id AND ma.award_type = 'Oscar') ORDER BY m.release_year DESC, m.movie_title ASC LIMIT 15;","output":"SELECT m.movie_title, m.release_year, d.director_name FROM movies AS m JOIN directors AS d ON m.director_id = d.director_id LEFT JOIN user_ratings AS ur ON m.movie_id = ur.movie_id AND ur.rating < 3 AND ur.rating_date > '2023-01-01' JOIN movie_awards AS ma ON m.movie_id = ma.movie_id WHERE m.genre = 'Drama' AND m.release_year BETWEEN 2010 AND 2020 AND ur.movie_id IS NULL AND ma.award_type = 'Oscar' ORDER BY m.release_year DESC, m.movie_title ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT v.vendor_name, v.contact_person FROM vendors v WHERE v.vendor_status = 'Approved' AND v.country = 'Germany' AND v.vendor_id IN (SELECT po.vendor_id FROM purchase_orders po WHERE po.order_date > '2023-01-01' AND po.total_amount > 5000) AND EXISTS (SELECT 1 FROM vendor_ratings vr WHERE vr.vendor_id = v.vendor_id AND vr.average_rating > 4.0) ORDER BY v.vendor_name ASC LIMIT 10;","output":"SELECT v.vendor_name, v.contact_person FROM vendors AS v JOIN purchase_orders AS po ON v.vendor_id = po.vendor_id JOIN vendor_ratings AS vr ON v.vendor_id = vr.vendor_id WHERE v.vendor_status = 'Approved' AND v.country = 'Germany' AND po.order_date > '2023-01-01' AND po.total_amount > 5000 AND vr.average_rating > 4.0 ORDER BY v.vendor_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT ev.event_name, ev.event_date, ev.location FROM events ev WHERE ev.event_type = 'Conference' AND ev.event_date BETWEEN '2023-09-01' AND '2023-12-31' AND ev.event_id NOT IN (SELECT ec.event_id FROM event_cancellations ec WHERE ec.cancellation_date > '2023-09-01') AND EXISTS (SELECT 1 FROM event_sponsors es WHERE es.event_id = ev.event_id AND es.sponsor_level = 'Platinum') ORDER BY ev.event_date ASC LIMIT 10;","output":"SELECT ev.event_name, ev.event_date, ev.location FROM events AS ev LEFT JOIN event_cancellations AS ec ON ev.event_id = ec.event_id AND ec.cancellation_date > '2023-09-01' JOIN event_sponsors AS es ON ev.event_id = es.event_id WHERE ev.event_type = 'Conference' AND ev.event_date BETWEEN '2023-09-01' AND '2023-12-31' AND ec.event_id IS NULL AND es.sponsor_level = 'Platinum' ORDER BY ev.event_date ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT cl.class_name, cl.class_code, t.teacher_name FROM classes cl JOIN teachers t ON cl.teacher_id = t.teacher_id WHERE cl.semester = 'Fall 2023' AND t.department = 'Mathematics' AND cl.class_id IN (SELECT en.class_id FROM enrollments en WHERE en.enrollment_date > '2023-08-01' AND en.status = 'Enrolled') AND EXISTS (SELECT 1 FROM class_rooms cr WHERE cr.class_id = cl.class_id AND cr.capacity > 30) ORDER BY cl.class_name ASC LIMIT 15;","output":"SELECT cl.class_name, cl.class_code, t.teacher_name FROM classes AS cl JOIN teachers AS t ON cl.teacher_id = t.teacher_id JOIN enrollments AS en ON cl.class_id = en.class_id JOIN class_rooms AS cr ON cl.class_id = cr.class_id WHERE cl.semester = 'Fall 2023' AND t.department = 'Mathematics' AND en.enrollment_date > '2023-08-01' AND en.status = 'Enrolled' AND cr.capacity > 30 ORDER BY cl.class_name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT u.user_id, u.username, u.email, (SELECT COUNT(l.log_id) FROM user_logs l WHERE l.user_id = u.user_id AND l.log_type = 'login' AND l.log_date > '2023-01-01') AS logins_2023, (SELECT MAX(l.log_date) FROM user_logs l WHERE l.user_id = u.user_id AND l.log_type = 'login') AS last_login FROM users u WHERE u.status = 'active' AND u.registration_date BETWEEN '2020-01-01' AND '2021-12-31' AND u.user_id NOT IN (SELECT DISTINCT ub.user_id FROM user_bans ub WHERE ub.ban_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM user_subscriptions us WHERE us.user_id = u.user_id AND us.subscription_status = 'active' AND us.plan_type = 'Premium') ORDER BY logins_2023 DESC, last_login DESC LIMIT 20;","output":"WITH UserLoginCounts AS (SELECT user_id, COUNT(log_id) AS logins_2023, MAX(log_date) AS last_login FROM user_logs WHERE log_type = 'login' AND log_date > '2023-01-01' GROUP BY user_id) SELECT u.user_id, u.username, u.email, COALESCE(ulc.logins_2023, 0) AS logins_2023, ulc.last_login FROM users AS u LEFT JOIN UserLoginCounts AS ulc ON u.user_id = ulc.user_id LEFT JOIN user_bans AS ub ON u.user_id = ub.user_id AND ub.ban_end_date > CURDATE() JOIN user_subscriptions AS us ON u.user_id = us.user_id WHERE u.status = 'active' AND u.registration_date BETWEEN '2020-01-01' AND '2021-12-31' AND ub.user_id IS NULL AND us.subscription_status = 'active' AND us.plan_type = 'Premium' ORDER BY logins_2023 DESC, last_login DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, c.customer_name, o.order_date, SUM(oi.quantity * p.price) AS total_order_value FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-03-31' AND c.country = 'Germany' AND p.category_id IN (SELECT category_id FROM categories WHERE category_name LIKE '%Electronic%') AND o.customer_id IN (SELECT customer_id FROM customer_segments WHERE segment_type = 'High-Value') GROUP BY o.order_id, c.customer_name, o.order_date HAVING SUM(oi.quantity * p.price) > 500 AND COUNT(oi.order_item_id) > 1 ORDER BY total_order_value DESC, o.order_date ASC LIMIT 30;","output":"SELECT o.order_id, c.customer_name, o.order_date, SUM(oi.quantity * p.price) AS total_order_value FROM orders AS o JOIN customers AS c ON o.customer_id = c.customer_id JOIN order_items AS oi ON o.order_id = oi.order_id JOIN products AS p ON oi.product_id = p.product_id JOIN categories AS cat ON p.category_id = cat.category_id JOIN customer_segments AS cs ON c.customer_id = cs.customer_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-03-31' AND c.country = 'Germany' AND cat.category_name LIKE '%Electronic%' AND cs.segment_type = 'High-Value' GROUP BY o.order_id, c.customer_name, o.order_date HAVING SUM(oi.quantity * p.price) > 500 AND COUNT(oi.order_item_id) > 1 ORDER BY total_order_value DESC, o.order_date ASC LIMIT 30;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT e.employee_id, e.first_name, e.last_name, d.department_name, (SELECT COUNT(pr.project_id) FROM employee_projects pr WHERE pr.employee_id = e.employee_id AND pr.project_status = 'Completed' AND pr.end_date > '2023-01-01') AS completed_projects_2023, (SELECT AVG(pr.duration_days) FROM employee_projects pr WHERE pr.employee_id = e.employee_id) AS avg_project_duration FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE e.hire_date BETWEEN '2015-01-01' AND '2020-12-31' AND e.salary > 80000 AND d.location = 'New York' AND e.employee_id NOT IN (SELECT ex.employee_id FROM employee_exits ex WHERE ex.exit_date > '2023-01-01') AND EXISTS (SELECT 1 FROM employee_roles er JOIN roles r ON er.role_id = r.role_id WHERE er.employee_id = e.employee_id AND r.role_name = 'Senior Engineer') ORDER BY completed_projects_2023 DESC, avg_project_duration DESC LIMIT 25;","output":"WITH CompletedProjects AS (SELECT employee_id, COUNT(project_id) AS completed_projects_2023, AVG(duration_days) AS avg_project_duration FROM employee_projects WHERE project_status = 'Completed' AND end_date > '2023-01-01' GROUP BY employee_id) SELECT e.employee_id, e.first_name, e.last_name, d.department_name, COALESCE(cp.completed_projects_2023, 0) AS completed_projects_2023, COALESCE(cp.avg_project_duration, 0) AS avg_project_duration FROM employees AS e JOIN departments AS d ON e.department_id = d.department_id LEFT JOIN CompletedProjects AS cp ON e.employee_id = cp.employee_id LEFT JOIN employee_exits AS ex ON e.employee_id = ex.employee_id AND ex.exit_date > '2023-01-01' JOIN employee_roles AS er ON e.employee_id = er.employee_id JOIN roles AS r ON er.role_id = r.role_id WHERE e.hire_date BETWEEN '2015-01-01' AND '2020-12-31' AND e.salary > 80000 AND d.location = 'New York' AND ex.employee_id IS NULL AND r.role_name = 'Senior Engineer' ORDER BY completed_projects_2023 DESC, avg_project_duration DESC LIMIT 25;"}
{"instruction":"Optimize the SQL query","input":"SELECT product_name, manufacturer, price, (SELECT AVG(price) FROM products WHERE category_id = p.category_id) AS avg_category_price, (SELECT COUNT(DISTINCT customer_id) FROM order_items oi JOIN orders o ON oi.order_id = o.order_id WHERE oi.product_id = p.product_id AND o.order_date BETWEEN '2023-07-01' AND '2023-09-30') AS Q3_unique_buyers, (SELECT SUM(oi.quantity) FROM order_items oi WHERE oi.product_id = p.product_id AND oi.order_id IN (SELECT order_id FROM orders WHERE order_date BETWEEN '2023-07-01' AND '2023-09-30')) AS Q3_total_sold FROM products p WHERE p.stock_quantity < 50 AND p.price > 100 AND p.category_id IN (SELECT category_id FROM categories WHERE category_name NOT LIKE '%Food%') AND EXISTS (SELECT 1 FROM product_reviews pr WHERE pr.product_id = p.product_id AND pr.rating >= 4 AND pr.review_date > '2023-01-01') ORDER BY Q3_unique_buyers DESC, Q3_total_sold DESC LIMIT 20;","output":"WITH CategoryAvgPrice AS (SELECT category_id, AVG(price) AS avg_category_price FROM products GROUP BY category_id), Q3Sales AS (SELECT oi.product_id, COUNT(DISTINCT o.customer_id) AS Q3_unique_buyers, SUM(oi.quantity) AS Q3_total_sold FROM order_items AS oi JOIN orders AS o ON oi.order_id = o.order_id WHERE o.order_date BETWEEN '2023-07-01' AND '2023-09-30' GROUP BY oi.product_id) SELECT p.product_name, p.manufacturer, p.price, cap.avg_category_price, COALESCE(qs.Q3_unique_buyers, 0) AS Q3_unique_buyers, COALESCE(qs.Q3_total_sold, 0) AS Q3_total_sold FROM products AS p JOIN categories AS cat ON p.category_id = cat.category_id LEFT JOIN CategoryAvgPrice AS cap ON p.category_id = cap.category_id LEFT JOIN Q3Sales AS qs ON p.product_id = qs.product_id JOIN product_reviews AS pr ON p.product_id = pr.product_id WHERE p.stock_quantity < 50 AND p.price > 100 AND cat.category_name NOT LIKE '%Food%' AND pr.rating >= 4 AND pr.review_date > '2023-01-01' ORDER BY Q3_unique_buyers DESC, Q3_total_sold DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT a.artist_name, a.country, (SELECT COUNT(al.album_id) FROM albums al WHERE al.artist_id = a.artist_id AND al.release_year > 2020) AS recent_albums_count, (SELECT AVG(t.duration) FROM tracks t JOIN albums al ON t.album_id = al.album_id WHERE al.artist_id = a.artist_id AND t.genre = 'Pop') AS avg_pop_track_duration FROM artists a WHERE a.genre_preference = 'Rock' AND a.artist_id NOT IN (SELECT DISTINCT aa.artist_id FROM artist_awards aa WHERE aa.award_year = 2023 AND aa.award_type = 'Grammy') AND EXISTS (SELECT 1 FROM artist_social_media asm WHERE asm.artist_id = a.artist_id AND asm.platform = 'Instagram' AND asm.followers > 100000) ORDER BY recent_albums_count DESC, avg_pop_track_duration DESC LIMIT 15;","output":"WITH RecentAlbums AS (SELECT artist_id, COUNT(album_id) AS recent_albums_count FROM albums WHERE release_year > 2020 GROUP BY artist_id), AvgPopTrackDuration AS (SELECT al.artist_id, AVG(t.duration) AS avg_pop_track_duration FROM tracks AS t JOIN albums AS al ON t.album_id = al.album_id WHERE t.genre = 'Pop' GROUP BY al.artist_id) SELECT a.artist_name, a.country, COALESCE(ra.recent_albums_count, 0) AS recent_albums_count, COALESCE(apt.avg_pop_track_duration, 0) AS avg_pop_track_duration FROM artists AS a LEFT JOIN RecentAlbums AS ra ON a.artist_id = ra.artist_id LEFT JOIN AvgPopTrackDuration AS apt ON a.artist_id = apt.artist_id LEFT JOIN artist_awards AS aa ON a.artist_id = aa.artist_id AND aa.award_year = 2023 AND aa.award_type = 'Grammy' JOIN artist_social_media AS asm ON a.artist_id = asm.artist_id WHERE a.genre_preference = 'Rock' AND aa.artist_id IS NULL AND asm.platform = 'Instagram' AND asm.followers > 100000 ORDER BY recent_albums_count DESC, avg_pop_track_duration DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.office_name, o.city, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.office_id = o.office_id AND e.status = 'active') AS active_employees, (SELECT AVG(p.power_consumption_kwh) FROM office_power_usage p WHERE p.office_id = o.office_id AND p.reading_date BETWEEN '2023-01-01' AND '2023-12-31') AS avg_annual_power FROM offices o WHERE o.country = 'USA' AND o.square_footage > 5000 AND o.office_id NOT IN (SELECT DISTINCT ir.office_id FROM incident_reports ir WHERE ir.incident_date > '2023-01-01' AND ir.severity = 'High') AND EXISTS (SELECT 1 FROM office_amenities oa WHERE oa.office_id = o.office_id AND oa.amenity_type = 'Gym') ORDER BY active_employees DESC, avg_annual_power ASC LIMIT 10;","output":"WITH ActiveEmployees AS (SELECT office_id, COUNT(employee_id) AS active_employees FROM employees WHERE status = 'active' GROUP BY office_id), AnnualPowerUsage AS (SELECT office_id, AVG(power_consumption_kwh) AS avg_annual_power FROM office_power_usage WHERE reading_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY office_id) SELECT o.office_name, o.city, COALESCE(ae.active_employees, 0) AS active_employees, COALESCE(apu.avg_annual_power, 0) AS avg_annual_power FROM offices AS o LEFT JOIN ActiveEmployees AS ae ON o.office_id = ae.office_id LEFT JOIN AnnualPowerUsage AS apu ON o.office_id = apu.office_id LEFT JOIN incident_reports AS ir ON o.office_id = ir.office_id AND ir.incident_date > '2023-01-01' AND ir.severity = 'High' JOIN office_amenities AS oa ON o.office_id = oa.office_id WHERE o.country = 'USA' AND o.square_footage > 5000 AND ir.office_id IS NULL AND oa.amenity_type = 'Gym' ORDER BY active_employees DESC, avg_annual_power ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.continent_name, c.population, (SELECT AVG(gdp_per_capita) FROM countries co WHERE co.continent_id = c.continent_id) AS avg_gdp_continent, (SELECT MAX(life_expectancy) FROM countries co WHERE co.continent_id = c.continent_id) AS max_life_expectancy_continent FROM continents c WHERE c.area_sq_km > 10000000 AND c.continent_id NOT IN (SELECT DISTINCT dc.continent_id FROM disaster_events dc WHERE dc.event_date > '2023-01-01' AND dc.severity = 'High') ORDER BY avg_gdp_continent DESC, max_life_expectancy_continent DESC LIMIT 5;","output":"WITH ContinentStats AS (SELECT continent_id, AVG(gdp_per_capita) AS avg_gdp_continent, MAX(life_expectancy) AS max_life_expectancy_continent FROM countries GROUP BY continent_id) SELECT c.continent_name, c.population, cs.avg_gdp_continent, cs.max_life_expectancy_continent FROM continents AS c LEFT JOIN ContinentStats AS cs ON c.continent_id = cs.continent_id LEFT JOIN disaster_events AS de ON c.continent_id = de.continent_id AND de.event_date > '2023-01-01' AND de.severity = 'High' WHERE c.area_sq_km > 10000000 AND de.continent_id IS NULL ORDER BY avg_gdp_continent DESC, max_life_expectancy_continent DESC LIMIT 5;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.server_name, s.ip_address, (SELECT COUNT(l.log_id) FROM server_logs l WHERE l.server_id = s.server_id AND l.log_level = 'ERROR' AND l.log_timestamp > CURDATE() - INTERVAL 1 DAY) AS daily_errors, (SELECT MAX(m.cpu_usage) FROM server_metrics m WHERE m.server_id = s.server_id AND m.metric_timestamp > CURDATE() - INTERVAL 1 DAY) AS daily_max_cpu FROM servers s WHERE s.status = 'Online' AND s.location = 'Datacenter A' AND s.server_id NOT IN (SELECT d.server_id FROM server_downtime d WHERE d.downtime_start > CURDATE() - INTERVAL 7 DAY) AND EXISTS (SELECT 1 FROM server_configs sc WHERE sc.server_id = s.server_id AND sc.config_version = '2.1') ORDER BY daily_errors DESC, daily_max_cpu DESC LIMIT 10;","output":"WITH DailyErrors AS (SELECT server_id, COUNT(log_id) AS daily_errors FROM server_logs WHERE log_level = 'ERROR' AND log_timestamp > CURDATE() - INTERVAL 1 DAY GROUP BY server_id), DailyMaxCpu AS (SELECT server_id, MAX(cpu_usage) AS daily_max_cpu FROM server_metrics WHERE metric_timestamp > CURDATE() - INTERVAL 1 DAY GROUP BY server_id) SELECT s.server_name, s.ip_address, COALESCE(de.daily_errors, 0) AS daily_errors, COALESCE(dmc.daily_max_cpu, 0) AS daily_max_cpu FROM servers AS s LEFT JOIN DailyErrors AS de ON s.server_id = de.server_id LEFT JOIN DailyMaxCpu AS dmc ON s.server_id = dmc.server_id LEFT JOIN server_downtime AS sd ON s.server_id = sd.server_id AND sd.downtime_start > CURDATE() - INTERVAL 7 DAY JOIN server_configs AS sc ON s.server_id = sc.server_id WHERE s.status = 'Online' AND s.location = 'Datacenter A' AND sd.server_id IS NULL AND sc.config_version = '2.1' ORDER BY daily_errors DESC, daily_max_cpu DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT t.task_id, t.task_name, t.due_date, p.project_name FROM tasks t JOIN projects p ON t.project_id = p.project_id WHERE t.status = 'Pending' AND p.status = 'Active' AND t.due_date < CURDATE() + INTERVAL 7 DAY AND t.assigned_to_user_id IN (SELECT user_id FROM users WHERE department_id = (SELECT department_id FROM departments WHERE department_name = 'Development')) AND t.task_id NOT IN (SELECT sub.parent_task_id FROM subtasks sub WHERE sub.status = 'Blocked') ORDER BY t.due_date ASC, t.task_name ASC LIMIT 20;","output":"SELECT t.task_id, t.task_name, t.due_date, p.project_name FROM tasks AS t JOIN projects AS p ON t.project_id = p.project_id JOIN users AS u ON t.assigned_to_user_id = u.user_id JOIN departments AS d ON u.department_id = d.department_id LEFT JOIN subtasks AS sub ON t.task_id = sub.parent_task_id AND sub.status = 'Blocked' WHERE t.status = 'Pending' AND p.status = 'Active' AND t.due_date < CURDATE() + INTERVAL 7 DAY AND d.department_name = 'Development' AND sub.parent_task_id IS NULL ORDER BY t.due_date ASC, t.task_name ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.student_id, s.student_name, s.major, (SELECT COUNT(e.enrollment_id) FROM enrollments e WHERE e.student_id = s.student_id AND e.enrollment_date > '2022-09-01') AS recent_enrollments, (SELECT AVG(g.grade_value) FROM grades g WHERE g.student_id = s.student_id AND g.grade_date > '2022-09-01') AS avg_recent_grade FROM students s WHERE s.graduation_year = 2024 AND s.student_status = 'Active' AND s.student_id NOT IN (SELECT sd.student_id FROM student_disciplinary_actions sd WHERE sd.action_date > '2023-01-01' AND sd.severity = 'High') AND EXISTS (SELECT 1 FROM student_scholarships ss WHERE ss.student_id = s.student_id AND ss.scholarship_amount > 1000) ORDER BY recent_enrollments DESC, avg_recent_grade DESC LIMIT 15;","output":"WITH RecentEnrollments AS (SELECT student_id, COUNT(enrollment_id) AS recent_enrollments FROM enrollments WHERE enrollment_date > '2022-09-01' GROUP BY student_id), AvgRecentGrade AS (SELECT student_id, AVG(grade_value) AS avg_recent_grade FROM grades WHERE grade_date > '2022-09-01' GROUP BY student_id) SELECT s.student_id, s.student_name, s.major, COALESCE(re.recent_enrollments, 0) AS recent_enrollments, COALESCE(arg.avg_recent_grade, 0) AS avg_recent_grade FROM students AS s LEFT JOIN RecentEnrollments AS re ON s.student_id = re.student_id LEFT JOIN AvgRecentGrade AS arg ON s.student_id = arg.student_id LEFT JOIN student_disciplinary_actions AS sda ON s.student_id = sda.student_id AND sda.action_date > '2023-01-01' AND sda.severity = 'High' JOIN student_scholarships AS ss ON s.student_id = ss.student_id WHERE s.graduation_year = 2024 AND s.student_status = 'Active' AND sda.student_id IS NULL AND ss.scholarship_amount > 1000 ORDER BY recent_enrollments DESC, avg_recent_grade DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT p.patient_id, p.first_name, p.last_name, (SELECT MAX(va.visit_date) FROM patient_visits va WHERE va.patient_id = p.patient_id) AS last_visit_date, (SELECT COUNT(t.test_id) FROM medical_tests t WHERE t.patient_id = p.patient_id AND t.test_date > '2023-01-01' AND t.result = 'Abnormal') AS recent_abnormal_tests FROM patients p WHERE p.gender = 'Female' AND p.date_of_birth BETWEEN '1960-01-01' AND '1980-12-31' AND p.patient_id NOT IN (SELECT ad.patient_id FROM admission_details ad WHERE ad.admission_date > '2023-01-01' AND ad.diagnosis_code = 'C50') AND EXISTS (SELECT 1 FROM patient_medications pm WHERE pm.patient_id = p.patient_id AND pm.medication_status = 'Active') ORDER BY last_visit_date DESC, recent_abnormal_tests DESC LIMIT 10;","output":"WITH LastVisit AS (SELECT patient_id, MAX(visit_date) AS last_visit_date FROM patient_visits GROUP BY patient_id), RecentAbnormalTests AS (SELECT patient_id, COUNT(test_id) AS recent_abnormal_tests FROM medical_tests WHERE test_date > '2023-01-01' AND result = 'Abnormal' GROUP BY patient_id) SELECT p.patient_id, p.first_name, p.last_name, lv.last_visit_date, COALESCE(rat.recent_abnormal_tests, 0) AS recent_abnormal_tests FROM patients AS p LEFT JOIN LastVisit AS lv ON p.patient_id = lv.patient_id LEFT JOIN RecentAbnormalTests AS rat ON p.patient_id = rat.patient_id LEFT JOIN admission_details AS ad ON p.patient_id = ad.patient_id AND ad.admission_date > '2023-01-01' AND ad.diagnosis_code = 'C50' JOIN patient_medications AS pm ON p.patient_id = pm.patient_id WHERE p.gender = 'Female' AND p.date_of_birth BETWEEN '1960-01-01' AND '1980-12-31' AND ad.patient_id IS NULL AND pm.medication_status = 'Active' ORDER BY last_visit_date DESC, recent_abnormal_tests DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT h.hotel_name, h.city, (SELECT AVG(r.rating_score) FROM reviews r WHERE r.hotel_id = h.hotel_id AND r.review_date > '2023-01-01') AS avg_recent_rating, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id AND b.check_in_date BETWEEN '2023-10-01' AND '2023-12-31') AS Q4_bookings FROM hotels h WHERE h.star_rating = 5 AND h.country = 'France' AND h.hotel_id NOT IN (SELECT co.hotel_id FROM hotel_closures co WHERE co.closure_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM hotel_amenities ha WHERE ha.hotel_id = h.hotel_id AND ha.amenity_type = 'Swimming Pool') ORDER BY avg_recent_rating DESC, Q4_bookings DESC LIMIT 10;","output":"WITH RecentRatings AS (SELECT hotel_id, AVG(rating_score) AS avg_recent_rating FROM reviews WHERE review_date > '2023-01-01' GROUP BY hotel_id), Q4Bookings AS (SELECT hotel_id, COUNT(booking_id) AS Q4_bookings FROM bookings WHERE check_in_date BETWEEN '2023-10-01' AND '2023-12-31' GROUP BY hotel_id) SELECT h.hotel_name, h.city, COALESCE(rr.avg_recent_rating, 0) AS avg_recent_rating, COALESCE(qb.Q4_bookings, 0) AS Q4_bookings FROM hotels AS h LEFT JOIN RecentRatings AS rr ON h.hotel_id = rr.hotel_id LEFT JOIN Q4Bookings AS qb ON h.hotel_id = qb.hotel_id LEFT JOIN hotel_closures AS hc ON h.hotel_id = hc.hotel_id AND hc.closure_end_date > CURDATE() JOIN hotel_amenities AS ha ON h.hotel_id = ha.hotel_id WHERE h.star_rating = 5 AND h.country = 'France' AND hc.hotel_id IS NULL AND ha.amenity_type = 'Swimming Pool' ORDER BY avg_recent_rating DESC, Q4_bookings DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT v.vehicle_make, v.vehicle_model, v.model_year, (SELECT COUNT(s.service_id) FROM service_records s WHERE s.vehicle_id = v.vehicle_id AND s.service_date > '2023-01-01') AS recent_services, (SELECT AVG(r.repair_cost) FROM repair_records r WHERE r.vehicle_id = v.vehicle_id AND r.repair_date > '2023-01-01') AS avg_recent_repair_cost FROM vehicles v WHERE v.mileage < 50000 AND v.vehicle_type = 'Sedan' AND v.model_year BETWEEN 2018 AND 2022 AND v.vehicle_id NOT IN (SELECT rr.vehicle_id FROM recall_records rr WHERE rr.recall_date > '2023-01-01') AND EXISTS (SELECT 1 FROM vehicle_owners vo WHERE vo.vehicle_id = v.vehicle_id AND vo.owner_type = 'First Owner') ORDER BY recent_services DESC, avg_recent_repair_cost DESC LIMIT 10;","output":"WITH RecentServices AS (SELECT vehicle_id, COUNT(service_id) AS recent_services FROM service_records WHERE service_date > '2023-01-01' GROUP BY vehicle_id), AvgRecentRepairCost AS (SELECT vehicle_id, AVG(repair_cost) AS avg_recent_repair_cost FROM repair_records WHERE repair_date > '2023-01-01' GROUP BY vehicle_id) SELECT v.vehicle_make, v.vehicle_model, v.model_year, COALESCE(rs.recent_services, 0) AS recent_services, COALESCE(arrc.avg_recent_repair_cost, 0) AS avg_recent_repair_cost FROM vehicles AS v LEFT JOIN RecentServices AS rs ON v.vehicle_id = rs.vehicle_id LEFT JOIN AvgRecentRepairCost AS arrc ON v.vehicle_id = arrc.vehicle_id LEFT JOIN recall_records AS rr ON v.vehicle_id = rr.vehicle_id AND rr.recall_date > '2023-01-01' JOIN vehicle_owners AS vo ON v.vehicle_id = vo.vehicle_id WHERE v.mileage < 50000 AND v.vehicle_type = 'Sedan' AND v.model_year BETWEEN 2018 AND 2022 AND rr.vehicle_id IS NULL AND vo.owner_type = 'First Owner' ORDER BY recent_services DESC, avg_recent_repair_cost DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.investor_name, inv.country, (SELECT SUM(t.amount) FROM transactions t WHERE t.investor_id = inv.investor_id AND t.transaction_type = 'Buy' AND t.transaction_date > '2023-01-01') AS total_buy_2023, (SELECT SUM(t.amount) FROM transactions t WHERE t.investor_id = inv.investor_id AND t.transaction_type = 'Sell' AND t.transaction_date > '2023-01-01') AS total_sell_2023 FROM investors inv WHERE inv.investment_strategy = 'Growth' AND inv.registration_date < '2020-01-01' AND inv.investor_id NOT IN (SELECT bl.investor_id FROM blacklist_investors bl WHERE bl.reason = 'Fraud') AND EXISTS (SELECT 1 FROM investor_portfolios ip WHERE ip.investor_id = inv.investor_id AND ip.asset_class = 'Stocks') ORDER BY total_buy_2023 DESC, total_sell_2023 DESC LIMIT 10;","output":"WITH InvestorBuys AS (SELECT investor_id, SUM(amount) AS total_buy_2023 FROM transactions WHERE transaction_type = 'Buy' AND transaction_date > '2023-01-01' GROUP BY investor_id), InvestorSells AS (SELECT investor_id, SUM(amount) AS total_sell_2023 FROM transactions WHERE transaction_type = 'Sell' AND transaction_date > '2023-01-01' GROUP BY investor_id) SELECT inv.investor_name, inv.country, COALESCE(ib.total_buy_2023, 0) AS total_buy_2023, COALESCE(is.total_sell_2023, 0) AS total_sell_2023 FROM investors AS inv LEFT JOIN InvestorBuys AS ib ON inv.investor_id = ib.investor_id LEFT JOIN InvestorSells AS is ON inv.investor_id = is.investor_id LEFT JOIN blacklist_investors AS bl ON inv.investor_id = bl.investor_id AND bl.reason = 'Fraud' JOIN investor_portfolios AS ip ON inv.investor_id = ip.investor_id WHERE inv.investment_strategy = 'Growth' AND inv.registration_date < '2020-01-01' AND bl.investor_id IS NULL AND ip.asset_class = 'Stocks' ORDER BY total_buy_2023 DESC, total_sell_2023 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.sensor_id, s.sensor_type, s.location, (SELECT AVG(d.reading_value) FROM sensor_data d WHERE d.sensor_id = s.sensor_id AND d.reading_date > CURDATE() - INTERVAL 1 DAY) AS avg_daily_reading, (SELECT MAX(d.reading_value) FROM sensor_data d WHERE d.sensor_id = s.sensor_id AND d.reading_date > CURDATE() - INTERVAL 1 DAY) AS max_daily_reading FROM sensors s WHERE s.status = 'Operational' AND s.deployment_date < '2023-01-01' AND s.sensor_id NOT IN (SELECT al.sensor_id FROM sensor_alerts al WHERE al.alert_level = 'Critical' AND al.alert_date > CURDATE() - INTERVAL 7 DAY) AND EXISTS (SELECT 1 FROM sensor_maintenance sm WHERE sm.sensor_id = s.sensor_id AND sm.maintenance_type = 'Calibration' AND sm.next_maintenance_date < CURDATE() + INTERVAL 30 DAY) ORDER BY avg_daily_reading DESC, max_daily_reading DESC LIMIT 10;","output":"WITH DailyReadings AS (SELECT sensor_id, AVG(reading_value) AS avg_daily_reading, MAX(reading_value) AS max_daily_reading FROM sensor_data WHERE reading_date > CURDATE() - INTERVAL 1 DAY GROUP BY sensor_id) SELECT s.sensor_id, s.sensor_type, s.location, COALESCE(dr.avg_daily_reading, 0) AS avg_daily_reading, COALESCE(dr.max_daily_reading, 0) AS max_daily_reading FROM sensors AS s LEFT JOIN DailyReadings AS dr ON s.sensor_id = dr.sensor_id LEFT JOIN sensor_alerts AS sa ON s.sensor_id = sa.sensor_id AND sa.alert_level = 'Critical' AND sa.alert_date > CURDATE() - INTERVAL 7 DAY JOIN sensor_maintenance AS sm ON s.sensor_id = sm.sensor_id WHERE s.status = 'Operational' AND s.deployment_date < '2023-01-01' AND sa.sensor_id IS NULL AND sm.maintenance_type = 'Calibration' AND sm.next_maintenance_date < CURDATE() + INTERVAL 30 DAY ORDER BY avg_daily_reading DESC, max_daily_reading DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_id, c.campaign_name, c.start_date, (SELECT SUM(cm.clicks) FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-06-30') AS Q2_clicks, (SELECT AVG(cm.conversion_rate) FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-06-30') AS Q2_avg_conversion_rate FROM campaigns c WHERE c.campaign_type = 'Social Media' AND c.status = 'Completed' AND c.budget > 10000 AND c.campaign_id NOT IN (SELECT fr.campaign_id FROM fraud_reports fr WHERE fr.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM campaign_goals cg WHERE cg.campaign_id = c.campaign_id AND cg.goal_met = TRUE) ORDER BY Q2_clicks DESC, Q2_avg_conversion_rate DESC LIMIT 10;","output":"WITH Q2Metrics AS (SELECT campaign_id, SUM(clicks) AS Q2_clicks, AVG(conversion_rate) AS Q2_avg_conversion_rate FROM campaign_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY campaign_id) SELECT c.campaign_id, c.campaign_name, c.start_date, COALESCE(qm.Q2_clicks, 0) AS Q2_clicks, COALESCE(qm.Q2_avg_conversion_rate, 0) AS Q2_avg_conversion_rate FROM campaigns AS c LEFT JOIN Q2Metrics AS qm ON c.campaign_id = qm.campaign_id LEFT JOIN fraud_reports AS fr ON c.campaign_id = fr.campaign_id AND fr.report_date > '2023-01-01' JOIN campaign_goals AS cg ON c.campaign_id = cg.campaign_id WHERE c.campaign_type = 'Social Media' AND c.status = 'Completed' AND c.budget > 10000 AND fr.campaign_id IS NULL AND cg.goal_met = TRUE ORDER BY Q2_clicks DESC, Q2_avg_conversion_rate DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, u.registration_date, COUNT(p.post_id) AS total_posts, AVG(p.likes) AS avg_likes_per_post FROM users u LEFT JOIN posts p ON u.user_id = p.user_id WHERE u.status = 'active' AND u.registration_date > '2022-01-01' AND p.created_at > '2023-01-01' AND u.user_id NOT IN (SELECT sp.user_id FROM suspended_users sp WHERE sp.suspension_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM user_roles ur JOIN roles r ON ur.role_id = r.role_id WHERE ur.user_id = u.user_id AND r.role_name = 'Content Creator') GROUP BY u.user_id, u.username, u.registration_date HAVING COUNT(p.post_id) > 10 AND AVG(p.likes) > 50 ORDER BY total_posts DESC, avg_likes_per_post DESC LIMIT 20;","output":"SELECT u.user_id, u.username, u.registration_date, COUNT(p.post_id) AS total_posts, AVG(p.likes) AS avg_likes_per_post FROM users AS u LEFT JOIN posts AS p ON u.user_id = p.user_id LEFT JOIN suspended_users AS su ON u.user_id = su.user_id AND su.suspension_end_date > CURDATE() JOIN user_roles AS ur ON u.user_id = ur.user_id JOIN roles AS r ON ur.role_id = r.role_id WHERE u.status = 'active' AND u.registration_date > '2022-01-01' AND p.created_at > '2023-01-01' AND su.user_id IS NULL AND r.role_name = 'Content Creator' GROUP BY u.user_id, u.username, u.registration_date HAVING COUNT(p.post_id) > 10 AND AVG(p.likes) > 50 ORDER BY total_posts DESC, avg_likes_per_post DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.price, p.stock_quantity, c.category_name, (SELECT AVG(pr.rating) FROM product_reviews pr WHERE pr.product_id = p.product_id) AS average_rating, (SELECT COUNT(oi.order_item_id) FROM order_items oi WHERE oi.product_id = p.product_id AND oi.order_id IN (SELECT order_id FROM orders WHERE order_date > '2023-01-01')) AS sales_2023 FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50 AND p.stock_quantity > 0 AND c.category_name IN ('Electronics', 'Home Goods') AND p.product_id NOT IN (SELECT cp.product_id FROM discontinued_products cp WHERE cp.discontinuation_date > '2023-01-01') ORDER BY average_rating DESC, sales_2023 DESC LIMIT 25;","output":"WITH ProductRatings AS (SELECT product_id, AVG(rating) AS average_rating FROM product_reviews GROUP BY product_id), Sales2023 AS (SELECT oi.product_id, COUNT(oi.order_item_id) AS sales_2023 FROM order_items AS oi JOIN orders AS o ON oi.order_id = o.order_id WHERE o.order_date > '2023-01-01' GROUP BY oi.product_id) SELECT p.product_id, p.product_name, p.price, p.stock_quantity, c.category_name, COALESCE(pr.average_rating, 0) AS average_rating, COALESCE(s23.sales_2023, 0) AS sales_2023 FROM products AS p JOIN categories AS c ON p.category_id = c.category_id LEFT JOIN ProductRatings AS pr ON p.product_id = pr.product_id LEFT JOIN Sales2023 AS s23 ON p.product_id = s23.product_id LEFT JOIN discontinued_products AS dp ON p.product_id = dp.product_id AND dp.discontinuation_date > '2023-01-01' WHERE p.price > 50 AND p.stock_quantity > 0 AND c.category_name IN ('Electronics', 'Home Goods') AND dp.product_id IS NULL ORDER BY average_rating DESC, sales_2023 DESC LIMIT 25;"}
{"instruction":"Optimize the SQL query","input":"SELECT e.event_id, e.event_name, e.event_date, e.location, COUNT(t.ticket_id) AS total_tickets_sold, SUM(t.price) AS total_revenue FROM events e LEFT JOIN tickets t ON e.event_id = t.event_id WHERE e.event_date BETWEEN '2024-01-01' AND '2024-06-30' AND e.event_type = 'Concert' AND e.event_id NOT IN (SELECT ce.event_id FROM cancelled_events ce WHERE ce.cancellation_date < CURDATE()) AND EXISTS (SELECT 1 FROM event_performers ep JOIN performers p ON ep.performer_id = p.performer_id WHERE ep.event_id = e.event_id AND p.genre = 'Rock') GROUP BY e.event_id, e.event_name, e.event_date, e.location HAVING COUNT(t.ticket_id) > 100 AND SUM(t.price) > 5000 ORDER BY total_revenue DESC, total_tickets_sold DESC LIMIT 15;","output":"SELECT e.event_id, e.event_name, e.event_date, e.location, COUNT(t.ticket_id) AS total_tickets_sold, SUM(t.price) AS total_revenue FROM events AS e LEFT JOIN tickets AS t ON e.event_id = t.event_id LEFT JOIN cancelled_events AS ce ON e.event_id = ce.event_id AND ce.cancellation_date < CURDATE() JOIN event_performers AS ep ON e.event_id = ep.event_id JOIN performers AS p ON ep.performer_id = p.performer_id WHERE e.event_date BETWEEN '2024-01-01' AND '2024-06-30' AND e.event_type = 'Concert' AND ce.event_id IS NULL AND p.genre = 'Rock' GROUP BY e.event_id, e.event_name, e.event_date, e.location HAVING COUNT(t.ticket_id) > 100 AND SUM(t.price) > 5000 ORDER BY total_revenue DESC, total_tickets_sold DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT d.drug_id, d.drug_name, d.manufacturer, d.expiration_date FROM drugs d WHERE d.is_controlled = TRUE AND d.stock_quantity < 100 AND d.expiration_date BETWEEN CURDATE() AND CURDATE() + INTERVAL 6 MONTH AND d.drug_id IN (SELECT DISTINCT rs.drug_id FROM drug_reorder_suggestions rs WHERE rs.suggestion_date > CURDATE() - INTERVAL 30 DAY AND rs.priority = 'High') AND NOT EXISTS (SELECT 1 FROM drug_approvals da WHERE da.drug_id = d.drug_id AND da.approval_status = 'Pending') ORDER BY d.expiration_date ASC, d.drug_name ASC LIMIT 20;","output":"SELECT d.drug_id, d.drug_name, d.manufacturer, d.expiration_date FROM drugs AS d JOIN drug_reorder_suggestions AS drs ON d.drug_id = drs.drug_id LEFT JOIN drug_approvals AS da ON d.drug_id = da.drug_id WHERE d.is_controlled = TRUE AND d.stock_quantity < 100 AND d.expiration_date BETWEEN CURDATE() AND CURDATE() + INTERVAL 6 MONTH AND drs.suggestion_date > CURDATE() - INTERVAL 30 DAY AND drs.priority = 'High' AND (da.drug_id IS NULL OR da.approval_status != 'Pending') ORDER BY d.expiration_date ASC, d.drug_name ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT f.flight_number, f.departure_airport_code, f.arrival_airport_code, f.departure_time, (SELECT COUNT(p.passenger_id) FROM bookings b JOIN passengers p ON b.passenger_id = p.passenger_id WHERE b.flight_id = f.flight_id AND b.booking_status = 'Confirmed') AS confirmed_passengers, (SELECT AVG(pr.price) FROM prices pr WHERE pr.flight_id = f.flight_id AND pr.price_date = CURDATE()) AS current_avg_price FROM flights f WHERE f.flight_date = CURDATE() + INTERVAL 7 DAY AND f.status = 'Scheduled' AND f.airline_id IN (SELECT airline_id FROM airlines WHERE airline_country = 'USA') AND f.flight_id NOT IN (SELECT dl.flight_id FROM delayed_flights dl WHERE dl.delay_reason = 'Technical') ORDER BY confirmed_passengers DESC, current_avg_price DESC LIMIT 15;","output":"WITH ConfirmedPassengers AS (SELECT b.flight_id, COUNT(p.passenger_id) AS confirmed_passengers FROM bookings AS b JOIN passengers AS p ON b.passenger_id = p.passenger_id WHERE b.booking_status = 'Confirmed' GROUP BY b.flight_id), CurrentAvgPrice AS (SELECT flight_id, AVG(price) AS current_avg_price FROM prices WHERE price_date = CURDATE() GROUP BY flight_id) SELECT f.flight_number, f.departure_airport_code, f.arrival_airport_code, f.departure_time, COALESCE(cp.confirmed_passengers, 0) AS confirmed_passengers, COALESCE(cap.current_avg_price, 0) AS current_avg_price FROM flights AS f LEFT JOIN ConfirmedPassengers AS cp ON f.flight_id = cp.flight_id LEFT JOIN CurrentAvgPrice AS cap ON f.flight_id = cap.flight_id JOIN airlines AS al ON f.airline_id = al.airline_id LEFT JOIN delayed_flights AS df ON f.flight_id = df.flight_id AND df.delay_reason = 'Technical' WHERE f.flight_date = CURDATE() + INTERVAL 7 DAY AND f.status = 'Scheduled' AND al.airline_country = 'USA' AND df.flight_id IS NULL ORDER BY confirmed_passengers DESC, current_avg_price DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT ch.chapter_title, ch.chapter_number, b.book_title, b.author FROM chapters ch JOIN books b ON ch.book_id = b.book_id WHERE b.publication_year BETWEEN 2010 AND 2020 AND b.genre = 'Fantasy' AND ch.chapter_id NOT IN (SELECT pr.chapter_id FROM problem_reports pr WHERE pr.report_date > '2023-01-01' AND pr.severity = 'High') AND EXISTS (SELECT 1 FROM chapter_keywords ck WHERE ck.chapter_id = ch.chapter_id AND ck.keyword = 'Magic') ORDER BY ch.chapter_number ASC, b.book_title ASC LIMIT 20;","output":"SELECT ch.chapter_title, ch.chapter_number, b.book_title, b.author FROM chapters AS ch JOIN books AS b ON ch.book_id = b.book_id LEFT JOIN problem_reports AS pr ON ch.chapter_id = pr.chapter_id AND pr.report_date > '2023-01-01' AND pr.severity = 'High' JOIN chapter_keywords AS ck ON ch.chapter_id = ck.chapter_id WHERE b.publication_year BETWEEN 2010 AND 2020 AND b.genre = 'Fantasy' AND pr.chapter_id IS NULL AND ck.keyword = 'Magic' ORDER BY ch.chapter_number ASC, b.book_title ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT d.device_name, d.device_type, d.last_seen FROM devices d WHERE d.status = 'Online' AND d.location = 'Server Room 1' AND d.device_id NOT IN (SELECT ir.device_id FROM incident_reports ir WHERE ir.incident_date > '2023-01-01' AND ir.impact = 'Critical') AND EXISTS (SELECT 1 FROM device_firmware df WHERE df.device_id = d.device_id AND df.firmware_version = '1.2.0') AND d.last_seen > CURDATE() - INTERVAL 1 HOUR ORDER BY d.last_seen DESC, d.device_name ASC LIMIT 10;","output":"SELECT d.device_name, d.device_type, d.last_seen FROM devices AS d LEFT JOIN incident_reports AS ir ON d.device_id = ir.device_id AND ir.incident_date > '2023-01-01' AND ir.impact = 'Critical' JOIN device_firmware AS df ON d.device_id = df.device_id WHERE d.status = 'Online' AND d.location = 'Server Room 1' AND df.firmware_version = '1.2.0' AND d.last_seen > CURDATE() - INTERVAL 1 HOUR AND ir.device_id IS NULL ORDER BY d.last_seen DESC, d.device_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.sensor_id, s.sensor_type, s.deployment_date FROM sensors s WHERE s.status = 'Active' AND s.location = 'Outdoor' AND s.sensor_id IN (SELECT md.sensor_id FROM measurement_data md WHERE md.measurement_value > 100 AND md.measurement_date > '2023-01-01' GROUP BY md.sensor_id HAVING COUNT(md.data_id) > 1000) AND EXISTS (SELECT 1 FROM sensor_alerts sa WHERE sa.sensor_id = s.sensor_id AND sa.alert_type = 'High Value' AND sa.alert_date > '2023-01-01') ORDER BY s.deployment_date ASC, s.sensor_type ASC LIMIT 15;","output":"SELECT s.sensor_id, s.sensor_type, s.deployment_date FROM sensors AS s JOIN (SELECT sensor_id FROM measurement_data WHERE measurement_value > 100 AND measurement_date > '2023-01-01' GROUP BY sensor_id HAVING COUNT(data_id) > 1000) AS high_value_sensors ON s.sensor_id = high_value_sensors.sensor_id JOIN sensor_alerts AS sa ON s.sensor_id = sa.sensor_id WHERE s.status = 'Active' AND s.location = 'Outdoor' AND sa.alert_type = 'High Value' AND sa.alert_date > '2023-01-01' ORDER BY s.deployment_date ASC, s.sensor_type ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT t.team_name, t.team_lead, (SELECT COUNT(p.player_id) FROM players p WHERE p.team_id = t.team_id AND p.status = 'Active') AS active_players_count, (SELECT AVG(p.skill_rating) FROM players p WHERE p.team_id = t.team_id) AS avg_team_skill_rating FROM teams t WHERE t.league = 'Premier League' AND t.founding_year < 2000 AND t.team_id NOT IN (SELECT fp.team_id FROM financial_penalties fp WHERE fp.penalty_date > '2023-01-01' AND fp.penalty_amount > 10000) ORDER BY active_players_count DESC, avg_team_skill_rating DESC LIMIT 10;","output":"WITH TeamStats AS (SELECT team_id, COUNT(player_id) AS active_players_count, AVG(skill_rating) AS avg_team_skill_rating FROM players WHERE status = 'Active' GROUP BY team_id) SELECT t.team_name, t.team_lead, COALESCE(ts.active_players_count, 0) AS active_players_count, COALESCE(ts.avg_team_skill_rating, 0) AS avg_team_skill_rating FROM teams AS t LEFT JOIN TeamStats AS ts ON t.team_id = ts.team_id LEFT JOIN financial_penalties AS fp ON t.team_id = fp.team_id AND fp.penalty_date > '2023-01-01' AND fp.penalty_amount > 10000 WHERE t.league = 'Premier League' AND t.founding_year < 2000 AND fp.team_id IS NULL ORDER BY active_players_count DESC, avg_team_skill_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT f.forum_name, f.category, (SELECT COUNT(th.thread_id) FROM forum_threads th WHERE th.forum_id = f.forum_id AND th.created_date > '2023-01-01') AS new_threads_2023, (SELECT MAX(th.last_post_date) FROM forum_threads th WHERE th.forum_id = f.forum_id) AS last_activity_date FROM forums f WHERE f.status = 'Active' AND f.creation_date < '2020-01-01' AND f.forum_id NOT IN (SELECT fa.forum_id FROM forum_abuse_reports fa WHERE fa.report_date > '2023-01-01' AND fa.severity = 'High') AND EXISTS (SELECT 1 FROM forum_moderators fm WHERE fm.forum_id = f.forum_id AND fm.moderator_level = 'Admin') ORDER BY new_threads_2023 DESC, last_activity_date DESC LIMIT 10;","output":"WITH ForumThreadStats AS (SELECT forum_id, COUNT(thread_id) AS new_threads_2023, MAX(last_post_date) AS last_activity_date FROM forum_threads WHERE created_date > '2023-01-01' GROUP BY forum_id) SELECT f.forum_name, f.category, COALESCE(fts.new_threads_2023, 0) AS new_threads_2023, fts.last_activity_date FROM forums AS f LEFT JOIN ForumThreadStats AS fts ON f.forum_id = fts.forum_id LEFT JOIN forum_abuse_reports AS far ON f.forum_id = far.forum_id AND far.report_date > '2023-01-01' AND far.severity = 'High' JOIN forum_moderators AS fm ON f.forum_id = fm.forum_id WHERE f.status = 'Active' AND f.creation_date < '2020-01-01' AND far.forum_id IS NULL AND fm.moderator_level = 'Admin' ORDER BY new_threads_2023 DESC, last_activity_date DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.playlist_name, p.creation_date, u.username FROM playlists p JOIN users u ON p.user_id = u.user_id WHERE p.is_public = TRUE AND u.country = 'USA' AND p.creation_date > '2023-01-01' AND p.playlist_id IN (SELECT pt.playlist_id FROM playlist_tracks pt WHERE pt.track_id IN (SELECT t.track_id FROM tracks t WHERE t.genre = 'Electronic' AND t.duration > 300)) AND NOT EXISTS (SELECT 1 FROM playlist_reports pr WHERE pr.playlist_id = p.playlist_id AND pr.report_type = 'Copyright Infringement') ORDER BY p.creation_date DESC, p.playlist_name ASC LIMIT 10;","output":"SELECT p.playlist_name, p.creation_date, u.username FROM playlists AS p JOIN users AS u ON p.user_id = u.user_id JOIN playlist_tracks AS pt ON p.playlist_id = pt.playlist_id JOIN tracks AS t ON pt.track_id = t.track_id LEFT JOIN playlist_reports AS pr ON p.playlist_id = pr.playlist_id AND pr.report_type = 'Copyright Infringement' WHERE p.is_public = TRUE AND u.country = 'USA' AND p.creation_date > '2023-01-01' AND t.genre = 'Electronic' AND t.duration > 300 AND pr.playlist_id IS NULL ORDER BY p.creation_date DESC, p.playlist_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, u.email, u.first_name, u.last_name, u.registration_date, u.last_login, u.account_status, p.phone_number, p.phone_type, a.address_line1, a.address_line2, a.city, a.state, a.postal_code, a.country, pref.preference_name, pref.preference_value, sub.subscription_type, sub.subscription_status, sub.renewal_date, pay.payment_method, pay.card_last_four, pay.expiry_date, ord.order_count, ord.total_spent, ord.last_order_date, rev.review_count, rev.average_rating, sup.support_tickets, sup.last_ticket_date, not.notification_preferences, not.marketing_consent FROM users u LEFT JOIN user_phones p ON u.user_id = p.user_id LEFT JOIN user_addresses a ON u.user_id = a.user_id LEFT JOIN user_preferences pref ON u.user_id = pref.user_id LEFT JOIN user_subscriptions sub ON u.user_id = sub.user_id LEFT JOIN user_payment_methods pay ON u.user_id = pay.user_id LEFT JOIN (SELECT user_id, COUNT(*) as order_count, SUM(total_amount) as total_spent, MAX(order_date) as last_order_date FROM orders GROUP BY user_id) ord ON u.user_id = ord.user_id LEFT JOIN (SELECT user_id, COUNT(*) as review_count, AVG(rating) as average_rating FROM reviews GROUP BY user_id) rev ON u.user_id = rev.user_id LEFT JOIN (SELECT user_id, COUNT(*) as support_tickets, MAX(created_date) as last_ticket_date FROM support_tickets GROUP BY user_id) sup ON u.user_id = sup.user_id LEFT JOIN user_notifications not ON u.user_id = not.user_id WHERE u.registration_date > '2022-01-01' AND u.account_status = 'active' AND u.last_login > '2023-06-01' AND sub.subscription_status = 'active' AND pay.payment_method IS NOT NULL AND ord.order_count > 5 AND ord.total_spent > 1000 AND rev.average_rating >= 4.0 AND sup.support_tickets < 3 AND not.marketing_consent = TRUE ORDER BY ord.total_spent DESC, u.registration_date DESC LIMIT 50 OFFSET 0","output":"SELECT u.user_id, u.username, u.email, u.first_name, u.last_name, u.registration_date, u.last_login, u.account_status, p.phone_number, p.phone_type, a.address_line1, a.address_line2, a.city, a.state, a.postal_code, a.country, pref.preference_name, pref.preference_value, sub.subscription_type, sub.subscription_status, sub.renewal_date, pay.payment_method, pay.card_last_four, pay.expiry_date, ord.order_count, ord.total_spent, ord.last_order_date, rev.review_count, rev.average_rating, sup.support_tickets, sup.last_ticket_date, not.notification_preferences, not.marketing_consent FROM users u LEFT JOIN user_phones p ON u.user_id = p.user_id LEFT JOIN user_addresses a ON u.user_id = a.user_id LEFT JOIN user_preferences pref ON u.user_id = pref.user_id LEFT JOIN user_subscriptions sub ON u.user_id = sub.user_id LEFT JOIN user_payment_methods pay ON u.user_id = pay.user_id LEFT JOIN (SELECT user_id, COUNT(*) as order_count, SUM(total_amount) as total_spent, MAX(order_date) as last_order_date FROM orders GROUP BY user_id) ord ON u.user_id = ord.user_id LEFT JOIN (SELECT user_id, COUNT(*) as review_count, AVG(rating) as average_rating FROM reviews GROUP BY user_id) rev ON u.user_id = rev.user_id LEFT JOIN (SELECT user_id, COUNT(*) as support_tickets, MAX(created_date) as last_ticket_date FROM support_tickets GROUP BY user_id) sup ON u.user_id = sup.user_id LEFT JOIN user_notifications not ON u.user_id = not.user_id WHERE u.registration_date > '2022-01-01' AND u.account_status = 'active' AND u.last_login > '2023-06-01' AND sub.subscription_status = 'active' AND pay.payment_method IS NOT NULL AND ord.order_count > 5 AND ord.total_spent > 1000 AND rev.average_rating >= 4.0 AND sup.support_tickets < 3 AND not.marketing_consent = true ORDER BY ord.total_spent DESC, u.registration_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT emp.employee_id, emp.first_name, emp.last_name, emp.email, emp.department, emp.position, emp.salary, emp.hire_date, emp.employment_type, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, d.department_head, l.office_name, l.city, l.country, s.skill_name, s.skill_level, p.project_name, p.project_status, r.role_name, r.responsibilities, t.team_name, t.team_leader, per.performance_rating, per.review_date, per.reviewer_name, sal.salary_amount, sal.effective_date, sal.salary_type, ben.benefit_name, ben.coverage_amount, ben.provider, att.attendance_date, att.hours_worked, att.overtime_hours, att.absence_reason, vac.vacation_days_used, vac.vacation_days_remaining, vac.sick_days_used, train.training_name, train.completion_date, train.certification_status FROM employees emp LEFT JOIN employees m ON emp.manager_id = m.employee_id JOIN departments d ON emp.department_id = d.department_id JOIN locations l ON emp.location_id = l.location_id JOIN employee_skills es ON emp.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON emp.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id JOIN teams t ON emp.team_id = t.team_id JOIN performance_reviews per ON emp.employee_id = per.employee_id JOIN salary_history sal ON emp.employee_id = sal.employee_id JOIN benefits ben ON emp.employee_id = ben.employee_id JOIN attendance_records att ON emp.employee_id = att.employee_id JOIN vacation_balances vac ON emp.employee_id = vac.employee_id JOIN training_records train ON emp.employee_id = train.employee_id WHERE emp.salary > 80000 AND emp.hire_date > '2019-01-01' AND emp.employment_type = 'full_time' AND d.department_name IN ('Engineering', 'Data Science', 'Product', 'UX/UI') AND l.country = 'USA' AND s.skill_level >= 4 AND p.project_status = 'active' AND r.role_name IN ('Senior', 'Lead', 'Architect', 'Manager') AND t.team_size > 5 AND per.performance_rating >= 4.2 AND sal.salary_amount > 85000 AND ben.coverage_amount > 50000 AND att.hours_worked > 160 AND vac.vacation_days_remaining > 7 AND train.certification_status = 'completed' ORDER BY emp.salary DESC, per.performance_rating DESC, emp.hire_date DESC LIMIT 40 OFFSET 0","output":"SELECT emp.employee_id, emp.first_name, emp.last_name, emp.email, emp.department, emp.position, emp.salary, emp.hire_date, emp.employment_type, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, d.department_head, l.office_name, l.city, l.country, s.skill_name, s.skill_level, p.project_name, p.project_status, r.role_name, r.responsibilities, t.team_name, t.team_leader, per.performance_rating, per.review_date, per.reviewer_name, sal.salary_amount, sal.effective_date, sal.salary_type, ben.benefit_name, ben.coverage_amount, ben.provider, att.attendance_date, att.hours_worked, att.overtime_hours, att.absence_reason, vac.vacation_days_used, vac.vacation_days_remaining, vac.sick_days_used, train.training_name, train.completion_date, train.certification_status FROM employees emp LEFT JOIN employees m ON emp.manager_id = m.employee_id JOIN departments d ON emp.department_id = d.department_id JOIN locations l ON emp.location_id = l.location_id JOIN employee_skills es ON emp.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON emp.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id JOIN teams t ON emp.team_id = t.team_id JOIN performance_reviews per ON emp.employee_id = per.employee_id JOIN salary_history sal ON emp.employee_id = sal.employee_id JOIN benefits ben ON emp.employee_id = ben.employee_id JOIN attendance_records att ON emp.employee_id = att.employee_id JOIN vacation_balances vac ON emp.employee_id = vac.employee_id JOIN training_records train ON emp.employee_id = train.employee_id WHERE emp.salary > 80000 AND emp.hire_date > '2019-01-01' AND emp.employment_type = 'full_time' AND d.department_name IN ('Engineering', 'Data Science', 'Product', 'UX/UI') AND l.country = 'USA' AND s.skill_level >= 4 AND p.project_status = 'active' AND r.role_name IN ('Senior', 'Lead', 'Architect', 'Manager') AND t.team_size > 5 AND per.performance_rating >= 4.2 AND sal.salary_amount > 85000 AND ben.coverage_amount > 50000 AND att.hours_worked > 160 AND vac.vacation_days_remaining > 7 AND train.certification_status = 'completed' ORDER BY emp.salary DESC, per.performance_rating DESC, emp.hire_date DESC LIMIT 40"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.sku, inv.upc_code, inv.current_quantity, inv.min_quantity, inv.max_quantity, inv.unit_cost, inv.total_value, inv.reorder_point, wh.warehouse_name, wh.location, wh.capacity_sqft, wh.manager_name, s.supplier_name, s.contact_person, s.contact_email, s.phone_number, s.supplier_rating, cat.category_name, cat.category_description, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reference_number, emp.employee_name, aud.audit_date, aud.audit_result, aud.auditor_name, ord.po_number, ord.order_quantity, ord.order_date, ord.expected_delivery, sup.unit_cost AS supply_cost, sup.min_order_quantity, sup.lead_time_days, qua.quality_score, qua.inspection_date, qua.inspector_name, ser.service_history, ser.last_service_date, ser.next_service_date, war.warranty_period, war.warranty_status, war.warranty_expiry FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN purchase_orders ord ON inv.inventory_id = ord.inventory_id LEFT JOIN supplier_costs sup ON inv.supplier_id = sup.supplier_id LEFT JOIN quality_controls qua ON inv.inventory_id = qua.inventory_id LEFT JOIN service_history ser ON inv.inventory_id = ser.inventory_id LEFT JOIN warranty_info war ON inv.inventory_id = war.inventory_id WHERE inv.current_quantity < inv.reorder_point AND inv.unit_cost > 15.00 AND wh.capacity_sqft > 10000 AND s.supplier_rating >= 4.5 AND cat.category_name IN ('Electronics', 'Mechanical', 'Electrical') AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-04-01' AND aud.audit_result = 'passed' AND ord.order_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND sup.lead_time_days < 10 AND qua.quality_score >= 95 AND ser.next_service_date > CURRENT_DATE AND war.warranty_status = 'active' ORDER BY inv.current_quantity ASC, inv.unit_cost DESC, sup.lead_time_days ASC LIMIT 70 OFFSET 0","output":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.sku, inv.upc_code, inv.current_quantity, inv.min_quantity, inv.max_quantity, inv.unit_cost, inv.total_value, inv.reorder_point, wh.warehouse_name, wh.location, wh.capacity_sqft, wh.manager_name, s.supplier_name, s.contact_person, s.contact_email, s.phone_number, s.supplier_rating, cat.category_name, cat.category_description, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reference_number, emp.employee_name, aud.audit_date, aud.audit_result, aud.auditor_name, ord.po_number, ord.order_quantity, ord.order_date, ord.expected_delivery, sup.unit_cost AS supply_cost, sup.min_order_quantity, sup.lead_time_days, qua.quality_score, qua.inspection_date, qua.inspector_name, ser.service_history, ser.last_service_date, ser.next_service_date, war.warranty_period, war.warranty_status, war.warranty_expiry FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN purchase_orders ord ON inv.inventory_id = ord.inventory_id LEFT JOIN supplier_costs sup ON inv.supplier_id = sup.supplier_id LEFT JOIN quality_controls qua ON inv.inventory_id = qua.inventory_id LEFT JOIN service_history ser ON inv.inventory_id = ser.inventory_id LEFT JOIN warranty_info war ON inv.inventory_id = war.inventory_id WHERE inv.current_quantity < inv.reorder_point AND inv.unit_cost > 15.00 AND wh.capacity_sqft > 10000 AND s.supplier_rating >= 4.5 AND cat.category_name IN ('Electronics', 'Mechanical', 'Electrical') AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-04-01' AND aud.audit_result = 'passed' AND ord.order_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND sup.lead_time_days < 10 AND qua.quality_score >= 95 AND ser.next_service_date > CURRENT_DATE AND war.warranty_status = 'active' ORDER BY inv.current_quantity ASC, inv.unit_cost DESC, sup.lead_time_days ASC LIMIT 70"}
{"instruction":"Optimize the SQL query","input":"SELECT loan.loan_id, loan.loan_amount, loan.interest_rate, loan.start_date, loan.end_date, loan.term_months, loan.loan_purpose, loan.loan_status, c.customer_id, c.customer_name, c.credit_score, c.annual_income, c.employment_status, c.years_at_current_job, e.employee_id, e.employee_name, e.department, br.branch_id, br.branch_name, br.branch_region, pt.payment_terms, pt.number_of_payments, pt.payment_frequency, sch.due_date, sch.amount_due, sch.principal_amount, sch.interest_amount, sch.payment_status, coll.collection_stage, coll.collection_status, coll.collection_amount, coll.collector_name, risk.risk_level, risk.risk_score, risk.probability_of_default, doc.document_name, doc.document_status, doc.verification_date, ins.insurance_coverage, ins.insurance_provider, ins.policy_number, g.guarantor_name, g.guarantor_relationship, g.guarantor_income, g.guarantor_credit_score, sec.collateral_type, sec.collateral_value, sec.collateral_description FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.loan_officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_terms_id = pt.terms_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id LEFT JOIN guarantors g ON loan.loan_id = g.loan_id LEFT JOIN security_collateral sec ON loan.loan_id = sec.loan_id WHERE loan.loan_amount > 40000.00 AND loan.interest_rate < 6.75 AND loan.start_date > '2020-07-01' AND loan.loan_status = 'active' AND c.credit_score > 750 AND c.annual_income > 85000 AND e.department = 'consumer_lending' AND br.branch_region IN ('west', 'southwest') AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-11-01' AND '2024-02-29' AND coll.collection_status = 'in_progress' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_coverage > loan.loan_amount * 0.9 AND g.guarantor_credit_score > 700 AND sec.collateral_value > loan.loan_amount * 1.2 ORDER BY loan.loan_amount DESC, loan.interest_rate ASC, c.credit_score DESC LIMIT 55 OFFSET 0","output":"SELECT loan.loan_id, loan.loan_amount, loan.interest_rate, loan.start_date, loan.end_date, loan.term_months, loan.loan_purpose, loan.loan_status, c.customer_id, c.customer_name, c.credit_score, c.annual_income, c.employment_status, c.years_at_current_job, e.employee_id, e.employee_name, e.department, br.branch_id, br.branch_name, br.branch_region, pt.payment_terms, pt.number_of_payments, pt.payment_frequency, sch.due_date, sch.amount_due, sch.principal_amount, sch.interest_amount, sch.payment_status, coll.collection_stage, coll.collection_status, coll.collection_amount, coll.collector_name, risk.risk_level, risk.risk_score, risk.probability_of_default, doc.document_name, doc.document_status, doc.verification_date, ins.insurance_coverage, ins.insurance_provider, ins.policy_number, g.guarantor_name, g.guarantor_relationship, g.guarantor_income, g.guarantor_credit_score, sec.collateral_type, sec.collateral_value, sec.collateral_description FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.loan_officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_terms_id = pt.terms_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id LEFT JOIN guarantors g ON loan.loan_id = g.loan_id LEFT JOIN security_collateral sec ON loan.loan_id = sec.loan_id WHERE loan.loan_amount > 40000.00 AND loan.interest_rate < 6.75 AND loan.start_date > '2020-07-01' AND loan.loan_status = 'active' AND c.credit_score > 750 AND c.annual_income > 85000 AND e.department = 'consumer_lending' AND br.branch_region IN ('west', 'southwest') AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-11-01' AND '2024-02-29' AND coll.collection_status = 'in_progress' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_coverage > loan.loan_amount * 0.9 AND g.guarantor_credit_score > 700 AND sec.collateral_value > loan.loan_amount * 1.2 ORDER BY loan.loan_amount DESC, loan.interest_rate ASC, c.credit_score DESC LIMIT 55"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.project_description, p.start_date, p.end_date, p.estimated_budget, p.actual_cost, p.estimated_profit, p.project_status, p.priority_level, c.client_id, c.client_name, c.industry_sector, c.client_rating, m.employee_id AS manager_id, m.first_name AS manager_first, m.last_name AS manager_last, d.department_id, d.department_name, d.department_budget, t.team_id, t.team_name, t.team_size, r.risk_id, r.risk_description, r.impact_level, r.likelihood, r.mitigation_strategy, del.deliverable_id, del.deliverable_name, del.deliverable_status, del.due_date, res.resource_id, res.resource_name, res.resource_type, res.hourly_rate, times.time_entry_id, times.hours_logged, times.overtime_hours, times.work_date, exp.expense_id, exp.expense_description, exp.amount, exp.expense_date, mil.milestone_id, mil.milestone_name, mil.completion_date, mil.milestone_status, sta.stakeholder_id, sta.stakeholder_name, sta.influence_level, sta.interest_level FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.project_manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables del ON p.project_id = del.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id LEFT JOIN project_expenses exp ON p.project_id = exp.project_id LEFT JOIN project_milestones mil ON p.project_id = mil.project_id LEFT JOIN project_stakeholders sta ON p.project_id = sta.project_id WHERE p.start_date > '2021-09-01' AND p.estimated_budget > 125000.00 AND p.project_status IN ('execution', 'monitoring') AND c.industry_sector IN ('Technology', 'Finance', 'Healthcare', 'Energy') AND c.client_rating >= 4.3 AND d.department_name = 'Innovation' AND t.team_size > 7 AND r.impact_level IN ('high', 'medium') AND del.deliverable_status = 'in_progress' AND res.resource_type = 'external' AND res.hourly_rate > 65.00 AND times.hours_logged > 25 AND times.work_date > '2023-05-01' AND exp.amount > 2500.00 AND mil.milestone_status = 'completed' AND sta.influence_level = 'high' ORDER BY p.estimated_budget DESC, p.priority_level ASC, p.start_date ASC LIMIT 35 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.project_description, p.start_date, p.end_date, p.estimated_budget, p.actual_cost, p.estimated_profit, p.project_status, p.priority_level, c.client_id, c.client_name, c.industry_sector, c.client_rating, m.employee_id AS manager_id, m.first_name AS manager_first, m.last_name AS manager_last, d.department_id, d.department_name, d.department_budget, t.team_id, t.team_name, t.team_size, r.risk_id, r.risk_description, r.impact_level, r.likelihood, r.mitigation_strategy, del.deliverable_id, del.deliverable_name, del.deliverable_status, del.due_date, res.resource_id, res.resource_name, res.resource_type, res.hourly_rate, times.time_entry_id, times.hours_logged, times.overtime_hours, times.work_date, exp.expense_id, exp.expense_description, exp.amount, exp.expense_date, mil.milestone_id, mil.milestone_name, mil.completion_date, mil.milestone_status, sta.stakeholder_id, sta.stakeholder_name, sta.influence_level, sta.interest_level FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.project_manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables del ON p.project_id = del.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id LEFT JOIN project_expenses exp ON p.project_id = exp.project_id LEFT JOIN project_milestones mil ON p.project_id = mil.project_id LEFT JOIN project_stakeholders sta ON p.project_id = sta.project_id WHERE p.start_date > '2021-09-01' AND p.estimated_budget > 125000.00 AND p.project_status IN ('execution', 'monitoring') AND c.industry_sector IN ('Technology', 'Finance', 'Healthcare', 'Energy') AND c.client_rating >= 4.3 AND d.department_name = 'Innovation' AND t.team_size > 7 AND r.impact_level IN ('high', 'medium') AND del.deliverable_status = 'in_progress' AND res.resource_type = 'external' AND res.hourly_rate > 65.00 AND times.hours_logged > 25 AND times.work_date > '2023-05-01' AND exp.amount > 2500.00 AND mil.milestone_status = 'completed' AND sta.influence_level = 'high' ORDER BY p.estimated_budget DESC, p.priority_level ASC, p.start_date ASC LIMIT 35"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, u.email, (SELECT COUNT(DISTINCT p.post_id) FROM posts p WHERE p.user_id = u.user_id AND p.created_at > '2023-01-01') AS posts_count_2023, (SELECT AVG(c.rating) FROM comments c JOIN posts p ON c.post_id = p.post_id WHERE p.user_id = u.user_id AND c.created_at > '2023-01-01') AS avg_comment_rating_2023 FROM users u WHERE u.registration_date BETWEEN '2022-01-01' AND '2022-12-31' AND u.status = 'active' AND u.user_id NOT IN (SELECT bl.user_id FROM blacklist_users bl WHERE bl.reason = 'Spamming') AND EXISTS (SELECT 1 FROM user_groups ug JOIN groups g ON ug.group_id = g.group_id WHERE ug.user_id = u.user_id AND g.group_type = 'Premium') ORDER BY posts_count_2023 DESC, avg_comment_rating_2023 DESC LIMIT 15;","output":"WITH UserPostStats AS (SELECT p.user_id, COUNT(DISTINCT p.post_id) AS posts_count_2023, AVG(c.rating) AS avg_comment_rating_2023 FROM posts AS p LEFT JOIN comments AS c ON p.post_id = c.post_id WHERE p.created_at > '2023-01-01' AND c.created_at > '2023-01-01' GROUP BY p.user_id) SELECT u.user_id, u.username, u.email, COALESCE(ups.posts_count_2023, 0) AS posts_count_2023, COALESCE(ups.avg_comment_rating_2023, 0) AS avg_comment_rating_2023 FROM users AS u LEFT JOIN UserPostStats AS ups ON u.user_id = ups.user_id LEFT JOIN blacklist_users AS bl ON u.user_id = bl.user_id AND bl.reason = 'Spamming' JOIN user_groups AS ug ON u.user_id = ug.user_id JOIN groups AS g ON ug.group_id = g.group_id WHERE u.registration_date BETWEEN '2022-01-01' AND '2022-12-31' AND u.status = 'active' AND bl.user_id IS NULL AND g.group_type = 'Premium' ORDER BY posts_count_2023 DESC, avg_comment_rating_2023 DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT p.product_id, p.product_name, p.price, (SELECT COUNT(oi.order_item_id) FROM order_items oi WHERE oi.product_id = p.product_id AND oi.order_id IN (SELECT order_id FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-06-30')) AS total_sales_H1_2023, (SELECT AVG(rr.rating) FROM product_reviews rr WHERE rr.product_id = p.product_id AND rr.review_date > '2023-01-01') AS avg_review_score FROM products p WHERE p.category_id = (SELECT c.category_id FROM categories c WHERE c.category_name = 'Electronics') AND p.stock_quantity > 10 AND p.price > 100 AND p.product_id NOT IN (SELECT dp.product_id FROM discontinued_products dp WHERE dp.discontinuation_date > '2023-01-01') ORDER BY total_sales_H1_2023 DESC, avg_review_score DESC LIMIT 20;","output":"WITH H1Sales AS (SELECT oi.product_id, COUNT(oi.order_item_id) AS total_sales_H1_2023 FROM order_items AS oi JOIN orders AS o ON oi.order_id = o.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY oi.product_id), ReviewScores AS (SELECT product_id, AVG(rating) AS avg_review_score FROM product_reviews WHERE review_date > '2023-01-01' GROUP BY product_id) SELECT p.product_id, p.product_name, p.price, COALESCE(hs.total_sales_H1_2023, 0) AS total_sales_H1_2023, COALESCE(rs.avg_review_score, 0) AS avg_review_score FROM products AS p JOIN categories AS cat ON p.category_id = cat.category_id LEFT JOIN H1Sales AS hs ON p.product_id = hs.product_id LEFT JOIN ReviewScores AS rs ON p.product_id = rs.product_id LEFT JOIN discontinued_products AS dp ON p.product_id = dp.product_id AND dp.discontinuation_date > '2023-01-01' WHERE cat.category_name = 'Electronics' AND p.stock_quantity > 10 AND p.price > 100 AND dp.product_id IS NULL ORDER BY total_sales_H1_2023 DESC, avg_review_score DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.company_id, c.company_name, c.industry, (SELECT COUNT(DISTINCT pr.project_id) FROM projects pr WHERE pr.client_company_id = c.company_id AND pr.status = 'Completed' AND pr.end_date BETWEEN '2022-01-01' AND '2023-12-31') AS completed_projects_last_2_years, (SELECT AVG(pr.budget) FROM projects pr WHERE pr.client_company_id = c.company_id AND pr.status = 'Completed') AS avg_project_budget FROM companies c WHERE c.company_size = 'Large' AND c.founded_year < 2000 AND c.company_id NOT IN (SELECT bp.company_id FROM bankrupt_companies bp WHERE bp.bankruptcy_date > '2023-01-01') AND EXISTS (SELECT 1 FROM company_partnerships cp WHERE cp.company_id = c.company_id AND cp.partnership_type = 'Strategic Alliance') ORDER BY completed_projects_last_2_years DESC, avg_project_budget DESC LIMIT 10;","output":"WITH ProjectStats AS (SELECT client_company_id AS company_id, COUNT(DISTINCT project_id) AS completed_projects_last_2_years, AVG(budget) AS avg_project_budget FROM projects WHERE status = 'Completed' AND end_date BETWEEN '2022-01-01' AND '2023-12-31' GROUP BY client_company_id) SELECT c.company_id, c.company_name, c.industry, COALESCE(ps.completed_projects_last_2_years, 0) AS completed_projects_last_2_years, COALESCE(ps.avg_project_budget, 0) AS avg_project_budget FROM companies AS c LEFT JOIN ProjectStats AS ps ON c.company_id = ps.company_id LEFT JOIN bankrupt_companies AS bc ON c.company_id = bc.company_id AND bc.bankruptcy_date > '2023-01-01' JOIN company_partnerships AS cp ON c.company_id = cp.company_id WHERE c.company_size = 'Large' AND c.founded_year < 2000 AND bc.company_id IS NULL AND cp.partnership_type = 'Strategic Alliance' ORDER BY completed_projects_last_2_years DESC, avg_project_budget DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.station_id, s.station_name, s.city, (SELECT AVG(r.temperature) FROM weather_readings r WHERE r.station_id = s.station_id AND r.reading_date BETWEEN '2023-01-01' AND '2023-01-31') AS avg_jan_temp, (SELECT MAX(r.wind_speed) FROM weather_readings r WHERE r.station_id = s.station_id AND r.reading_date BETWEEN '2023-01-01' AND '2023-01-31') AS max_jan_wind_speed FROM weather_stations s WHERE s.country = 'Germany' AND s.elevation > 500 AND s.station_id NOT IN (SELECT ff.station_id FROM equipment_failures ff WHERE ff.failure_date BETWEEN '2023-01-01' AND '2023-06-30') AND EXISTS (SELECT 1 FROM station_sensors ss WHERE ss.station_id = s.station_id AND ss.sensor_type = 'Anemometer') ORDER BY avg_jan_temp DESC, max_jan_wind_speed DESC LIMIT 10;","output":"WITH JanWeatherStats AS (SELECT station_id, AVG(temperature) AS avg_jan_temp, MAX(wind_speed) AS max_jan_wind_speed FROM weather_readings WHERE reading_date BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY station_id) SELECT s.station_id, s.station_name, s.city, COALESCE(jws.avg_jan_temp, 0) AS avg_jan_temp, COALESCE(jws.max_jan_wind_speed, 0) AS max_jan_wind_speed FROM weather_stations AS s LEFT JOIN JanWeatherStats AS jws ON s.station_id = jws.station_id LEFT JOIN equipment_failures AS ef ON s.station_id = ef.station_id AND ef.failure_date BETWEEN '2023-01-01' AND '2023-06-30' JOIN station_sensors AS ss ON s.station_id = ss.station_id WHERE s.country = 'Germany' AND s.elevation > 500 AND ef.station_id IS NULL AND ss.sensor_type = 'Anemometer' ORDER BY avg_jan_temp DESC, max_jan_wind_speed DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.playlist_id, p.playlist_name, u.username, (SELECT COUNT(pt.track_id) FROM playlist_tracks pt WHERE pt.playlist_id = p.playlist_id) AS total_tracks, (SELECT SUM(t.duration_seconds) FROM playlist_tracks pt JOIN tracks t ON pt.track_id = t.track_id WHERE pt.playlist_id = p.playlist_id) AS total_duration_seconds FROM playlists p JOIN users u ON p.user_id = u.user_id WHERE p.is_public = TRUE AND u.country = 'USA' AND p.creation_date BETWEEN '2022-01-01' AND '2022-12-31' AND p.playlist_id NOT IN (SELECT DISTINCT rp.playlist_id FROM reported_playlists rp WHERE rp.report_type = 'Inappropriate Content') ORDER BY total_tracks DESC, total_duration_seconds DESC LIMIT 10;","output":"WITH PlaylistStats AS (SELECT pt.playlist_id, COUNT(pt.track_id) AS total_tracks, SUM(t.duration_seconds) AS total_duration_seconds FROM playlist_tracks AS pt JOIN tracks AS t ON pt.track_id = t.track_id GROUP BY pt.playlist_id) SELECT p.playlist_id, p.playlist_name, u.username, COALESCE(ps.total_tracks, 0) AS total_tracks, COALESCE(ps.total_duration_seconds, 0) AS total_duration_seconds FROM playlists AS p JOIN users AS u ON p.user_id = u.user_id LEFT JOIN PlaylistStats AS ps ON p.playlist_id = ps.playlist_id LEFT JOIN reported_playlists AS rp ON p.playlist_id = rp.playlist_id AND rp.report_type = 'Inappropriate Content' WHERE p.is_public = TRUE AND u.country = 'USA' AND p.creation_date BETWEEN '2022-01-01' AND '2022-12-31' AND rp.playlist_id IS NULL ORDER BY total_tracks DESC, total_duration_seconds DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT a.article_id, a.title, au.author_name, a.publication_date, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.article_id = a.article_id) AS total_comments, (SELECT AVG(r.rating_score) FROM article_ratings r WHERE r.article_id = a.article_id) AS avg_rating FROM articles a JOIN authors au ON a.author_id = au.author_id WHERE a.category = 'Technology' AND a.publication_date BETWEEN '2023-01-01' AND '2023-06-30' AND a.article_id NOT IN (SELECT pr.article_id FROM flagged_articles pr WHERE pr.flag_reason = 'Misinformation') AND EXISTS (SELECT 1 FROM article_tags at JOIN tags t ON at.tag_id = t.tag_id WHERE at.article_id = a.article_id AND t.tag_name = 'AI') ORDER BY total_comments DESC, avg_rating DESC LIMIT 15;","output":"WITH ArticleStats AS (SELECT a.article_id, COUNT(c.comment_id) AS total_comments, AVG(r.rating_score) AS avg_rating FROM articles AS a LEFT JOIN comments AS c ON a.article_id = c.article_id LEFT JOIN article_ratings AS r ON a.article_id = r.article_id GROUP BY a.article_id) SELECT a.article_id, a.title, au.author_name, a.publication_date, COALESCE(aps.total_comments, 0) AS total_comments, COALESCE(aps.avg_rating, 0) AS avg_rating FROM articles AS a JOIN authors AS au ON a.author_id = au.author_id LEFT JOIN ArticleStats AS aps ON a.article_id = aps.article_id LEFT JOIN flagged_articles AS fa ON a.article_id = fa.article_id AND fa.flag_reason = 'Misinformation' JOIN article_tags AS at ON a.article_id = at.article_id JOIN tags AS t ON at.tag_id = t.tag_id WHERE a.category = 'Technology' AND a.publication_date BETWEEN '2023-01-01' AND '2023-06-30' AND fa.article_id IS NULL AND t.tag_name = 'AI' ORDER BY total_comments DESC, avg_rating DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT v.vendor_id, v.vendor_name, v.country, (SELECT SUM(po.total_amount) FROM purchase_orders po WHERE po.vendor_id = v.vendor_id AND po.order_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_purchase_amount, (SELECT AVG(dr.delivery_time_days) FROM delivery_records dr WHERE dr.vendor_id = v.vendor_id AND dr.delivery_date > '2023-01-01') AS avg_delivery_time FROM vendors v WHERE v.vendor_status = 'Preferred' AND v.contract_start_date < '2020-01-01' AND v.vendor_id NOT IN (SELECT lp.vendor_id FROM late_payments lp WHERE lp.payment_date > '2023-01-01') AND EXISTS (SELECT 1 FROM vendor_certifications vc WHERE vc.vendor_id = v.vendor_id AND vc.certification_type = 'ISO 9001') ORDER BY annual_purchase_amount DESC, avg_delivery_time ASC LIMIT 10;","output":"WITH VendorPurchaseStats AS (SELECT vendor_id, SUM(total_amount) AS annual_purchase_amount FROM purchase_orders WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY vendor_id), VendorDeliveryStats AS (SELECT vendor_id, AVG(delivery_time_days) AS avg_delivery_time FROM delivery_records WHERE delivery_date > '2023-01-01' GROUP BY vendor_id) SELECT v.vendor_id, v.vendor_name, v.country, COALESCE(vps.annual_purchase_amount, 0) AS annual_purchase_amount, COALESCE(vds.avg_delivery_time, 0) AS avg_delivery_time FROM vendors AS v LEFT JOIN VendorPurchaseStats AS vps ON v.vendor_id = vps.vendor_id LEFT JOIN VendorDeliveryStats AS vds ON v.vendor_id = vds.vendor_id LEFT JOIN late_payments AS lp ON v.vendor_id = lp.vendor_id AND lp.payment_date > '2023-01-01' JOIN vendor_certifications AS vc ON v.vendor_id = vc.vendor_id WHERE v.vendor_status = 'Preferred' AND v.contract_start_date < '2020-01-01' AND lp.vendor_id IS NULL AND vc.certification_type = 'ISO 9001' ORDER BY annual_purchase_amount DESC, avg_delivery_time ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT h.hospital_id, h.hospital_name, h.city, (SELECT COUNT(p.patient_id) FROM patients p WHERE p.hospital_id = h.hospital_id AND p.admission_date > '2023-01-01') AS patients_admitted_2023, (SELECT AVG(s.satisfaction_score) FROM patient_surveys s WHERE s.hospital_id = h.hospital_id AND s.survey_date > '2023-01-01') AS avg_patient_satisfaction FROM hospitals h WHERE h.hospital_type = 'General' AND h.number_of_beds > 200 AND h.hospital_id NOT IN (SELECT ci.hospital_id FROM critical_incidents ci WHERE ci.incident_date > '2023-01-01' AND ci.severity = 'High') AND EXISTS (SELECT 1 FROM hospital_accreditations ha WHERE ha.hospital_id = h.hospital_id AND ha.accreditation_body = 'JCI') ORDER BY patients_admitted_2023 DESC, avg_patient_satisfaction DESC LIMIT 10;","output":"WITH HospitalPatientStats AS (SELECT hospital_id, COUNT(patient_id) AS patients_admitted_2023 FROM patients WHERE admission_date > '2023-01-01' GROUP BY hospital_id), PatientSatisfaction AS (SELECT hospital_id, AVG(satisfaction_score) AS avg_patient_satisfaction FROM patient_surveys WHERE survey_date > '2023-01-01' GROUP BY hospital_id) SELECT h.hospital_id, h.hospital_name, h.city, COALESCE(hps.patients_admitted_2023, 0) AS patients_admitted_2023, COALESCE(ps.avg_patient_satisfaction, 0) AS avg_patient_satisfaction FROM hospitals AS h LEFT JOIN HospitalPatientStats AS hps ON h.hospital_id = hps.hospital_id LEFT JOIN PatientSatisfaction AS ps ON h.hospital_id = ps.hospital_id LEFT JOIN critical_incidents AS ci ON h.hospital_id = ci.hospital_id AND ci.incident_date > '2023-01-01' AND ci.severity = 'High' JOIN hospital_accreditations AS ha ON h.hospital_id = ha.hospital_id WHERE h.hospital_type = 'General' AND h.number_of_beds > 200 AND ci.hospital_id IS NULL AND ha.accreditation_body = 'JCI' ORDER BY patients_admitted_2023 DESC, avg_patient_satisfaction DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.software_id, s.software_name, s.version, (SELECT COUNT(il.installation_id) FROM installations il WHERE il.software_id = s.software_id AND il.installation_date > '2023-01-01') AS installations_2023, (SELECT AVG(ur.usability_score) FROM user_reviews ur WHERE ur.software_id = s.software_id AND ur.review_date > '2023-01-01') AS avg_usability_score FROM software s WHERE s.software_type = 'Productivity' AND s.release_date < '2022-01-01' AND s.software_id NOT IN (SELECT vd.software_id FROM vulnerability_reports vd WHERE vd.report_date > '2023-01-01' AND vd.severity = 'Critical') AND EXISTS (SELECT 1 FROM software_licenses sl WHERE sl.software_id = s.software_id AND sl.license_type = 'Enterprise') ORDER BY installations_2023 DESC, avg_usability_score DESC LIMIT 10;","output":"WITH SoftwareStats AS (SELECT il.software_id, COUNT(il.installation_id) AS installations_2023, AVG(ur.usability_score) AS avg_usability_score FROM installations AS il LEFT JOIN user_reviews AS ur ON il.software_id = ur.software_id WHERE il.installation_date > '2023-01-01' AND ur.review_date > '2023-01-01' GROUP BY il.software_id) SELECT s.software_id, s.software_name, s.version, COALESCE(ss.installations_2023, 0) AS installations_2023, COALESCE(ss.avg_usability_score, 0) AS avg_usability_score FROM software AS s LEFT JOIN SoftwareStats AS ss ON s.software_id = ss.software_id LEFT JOIN vulnerability_reports AS vr ON s.software_id = vr.software_id AND vr.report_date > '2023-01-01' AND vr.severity = 'Critical' JOIN software_licenses AS sl ON s.software_id = sl.software_id WHERE s.software_type = 'Productivity' AND s.release_date < '2022-01-01' AND vr.software_id IS NULL AND sl.license_type = 'Enterprise' ORDER BY installations_2023 DESC, avg_usability_score DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT f.firm_id, f.firm_name, f.city, (SELECT COUNT(cl.client_id) FROM clients cl WHERE cl.firm_id = f.firm_id AND cl.onboarding_date > '2023-01-01') AS new_clients_2023, (SELECT AVG(fb.satisfaction_score) FROM client_feedback fb WHERE fb.firm_id = f.firm_id AND fb.feedback_date > '2023-01-01') AS avg_client_satisfaction FROM firms f WHERE f.firm_type = 'Legal' AND f.founding_year < 1990 AND f.firm_id NOT IN (SELECT lr.firm_id FROM lawsuit_records lr WHERE lr.case_status = 'Lost' AND lr.case_date > '2023-01-01') AND EXISTS (SELECT 1 FROM firm_specialties fs WHERE fs.firm_id = f.firm_id AND fs.specialty_area = 'Corporate Law') ORDER BY new_clients_2023 DESC, avg_client_satisfaction DESC LIMIT 10;","output":"WITH FirmClientStats AS (SELECT cl.firm_id, COUNT(cl.client_id) AS new_clients_2023, AVG(fb.satisfaction_score) AS avg_client_satisfaction FROM clients AS cl LEFT JOIN client_feedback AS fb ON cl.firm_id = fb.firm_id WHERE cl.onboarding_date > '2023-01-01' AND fb.feedback_date > '2023-01-01' GROUP BY cl.firm_id) SELECT f.firm_id, f.firm_name, f.city, COALESCE(fcs.new_clients_2023, 0) AS new_clients_2023, COALESCE(fcs.avg_client_satisfaction, 0) AS avg_client_satisfaction FROM firms AS f LEFT JOIN FirmClientStats AS fcs ON f.firm_id = fcs.firm_id LEFT JOIN lawsuit_records AS lr ON f.firm_id = lr.firm_id AND lr.case_status = 'Lost' AND lr.case_date > '2023-01-01' JOIN firm_specialties AS fs ON f.firm_id = fs.firm_id WHERE f.firm_type = 'Legal' AND f.founding_year < 1990 AND lr.firm_id IS NULL AND fs.specialty_area = 'Corporate Law' ORDER BY new_clients_2023 DESC, avg_client_satisfaction DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT uni.university_id, uni.university_name, uni.city, (SELECT COUNT(st.student_id) FROM students st WHERE st.university_id = uni.university_id AND st.enrollment_date > '2023-01-01') AS new_enrollments_2023, (SELECT AVG(pr.research_citations) FROM professors pr WHERE pr.university_id = uni.university_id) AS avg_prof_citations FROM universities uni WHERE uni.country = 'USA' AND uni.ranking <= 50 AND uni.university_id NOT IN (SELECT ap.university_id FROM academic_penalties ap WHERE ap.penalty_date > '2023-01-01') AND EXISTS (SELECT 1 FROM university_programs up WHERE up.university_id = uni.university_id AND up.program_type = 'Doctorate') ORDER BY new_enrollments_2023 DESC, avg_prof_citations DESC LIMIT 10;","output":"WITH UniversityStats AS (SELECT st.university_id, COUNT(st.student_id) AS new_enrollments_2023 FROM students AS st WHERE st.enrollment_date > '2023-01-01' GROUP BY st.university_id), ProfessorCitations AS (SELECT university_id, AVG(research_citations) AS avg_prof_citations FROM professors GROUP BY university_id) SELECT uni.university_id, uni.university_name, uni.city, COALESCE(us.new_enrollments_2023, 0) AS new_enrollments_2023, COALESCE(pc.avg_prof_citations, 0) AS avg_prof_citations FROM universities AS uni LEFT JOIN UniversityStats AS us ON uni.university_id = us.university_id LEFT JOIN ProfessorCitations AS pc ON uni.university_id = pc.university_id LEFT JOIN academic_penalties AS ap ON uni.university_id = ap.university_id AND ap.penalty_date > '2023-01-01' JOIN university_programs AS up ON uni.university_id = up.university_id WHERE uni.country = 'USA' AND uni.ranking <= 50 AND ap.university_id IS NULL AND up.program_type = 'Doctorate' ORDER BY new_enrollments_2023 DESC, avg_prof_citations DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.sensor_id, s.sensor_type, s.location, (SELECT AVG(d.value) FROM sensor_data d WHERE d.sensor_id = s.sensor_id AND d.timestamp BETWEEN '2023-01-01' AND '2023-01-31') AS avg_jan_value, (SELECT COUNT(a.alert_id) FROM sensor_alerts a WHERE a.sensor_id = s.sensor_id AND a.alert_date BETWEEN '2023-01-01' AND '2023-01-31') AS jan_alerts FROM sensors s WHERE s.status = 'Operational' AND s.deployment_date < '2022-01-01' AND s.sensor_id NOT IN (SELECT ce.sensor_id FROM sensor_critical_errors ce WHERE ce.error_date > '2023-01-01') AND EXISTS (SELECT 1 FROM sensor_calibration sc WHERE sc.sensor_id = s.sensor_id AND sc.last_calibration_date > '2023-01-01') ORDER BY jan_alerts DESC, avg_jan_value DESC LIMIT 10;","output":"WITH JanSensorStats AS (SELECT sensor_id, AVG(value) AS avg_jan_value, COUNT(alert_id) AS jan_alerts FROM sensor_data AS sd LEFT JOIN sensor_alerts AS sa ON sd.sensor_id = sa.sensor_id AND sa.alert_date BETWEEN '2023-01-01' AND '2023-01-31' WHERE sd.timestamp BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY sensor_id) SELECT s.sensor_id, s.sensor_type, s.location, COALESCE(jss.avg_jan_value, 0) AS avg_jan_value, COALESCE(jss.jan_alerts, 0) AS jan_alerts FROM sensors AS s LEFT JOIN JanSensorStats AS jss ON s.sensor_id = jss.sensor_id LEFT JOIN sensor_critical_errors AS sce ON s.sensor_id = sce.sensor_id AND sce.error_date > '2023-01-01' JOIN sensor_calibration AS sc ON s.sensor_id = sc.sensor_id WHERE s.status = 'Operational' AND s.deployment_date < '2022-01-01' AND sce.sensor_id IS NULL AND sc.last_calibration_date > '2023-01-01' ORDER BY jan_alerts DESC, avg_jan_value DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_name, c.start_date, c.end_date, (SELECT SUM(cm.spend) FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_spend, (SELECT AVG(cm.roi) FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_roi FROM campaigns c WHERE c.campaign_type = 'Digital' AND c.status = 'Active' AND c.budget > 5000 AND c.campaign_id NOT IN (SELECT fr.campaign_id FROM fraud_reports fr WHERE fr.report_date > '2023-01-01' AND fr.severity = 'High') AND EXISTS (SELECT 1 FROM campaign_creatives cc WHERE cc.campaign_id = c.campaign_id AND cc.creative_type = 'Video Ad') ORDER BY Q1_spend DESC, Q1_avg_roi DESC LIMIT 10;","output":"WITH Q1CampaignMetrics AS (SELECT campaign_id, SUM(spend) AS Q1_spend, AVG(roi) AS Q1_avg_roi FROM campaign_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY campaign_id) SELECT c.campaign_name, c.start_date, c.end_date, COALESCE(qcm.Q1_spend, 0) AS Q1_spend, COALESCE(qcm.Q1_avg_roi, 0) AS Q1_avg_roi FROM campaigns AS c LEFT JOIN Q1CampaignMetrics AS qcm ON c.campaign_id = qcm.campaign_id LEFT JOIN fraud_reports AS fr ON c.campaign_id = fr.campaign_id AND fr.report_date > '2023-01-01' AND fr.severity = 'High' JOIN campaign_creatives AS cc ON c.campaign_id = cc.campaign_id WHERE c.campaign_type = 'Digital' AND c.status = 'Active' AND c.budget > 5000 AND fr.campaign_id IS NULL AND cc.creative_type = 'Video Ad' ORDER BY Q1_spend DESC, Q1_avg_roi DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.ad_id, a.ad_title, a.platform, (SELECT SUM(am.impressions) FROM ad_metrics am WHERE am.ad_id = a.ad_id AND am.metric_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_impressions, (SELECT AVG(am.ctr) FROM ad_metrics am WHERE am.ad_id = a.ad_id AND am.metric_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_ctr FROM ads a WHERE a.campaign_id = (SELECT cm.campaign_id FROM campaigns cm WHERE cm.campaign_name = 'Summer Sale 2023') AND a.status = 'Active' AND a.ad_type = 'Banner' AND a.ad_id NOT IN (SELECT ar.ad_id FROM ad_rejections ar WHERE ar.rejection_date > '2023-01-01') ORDER BY H1_impressions DESC, H1_avg_ctr DESC LIMIT 20;","output":"WITH H1AdMetrics AS (SELECT ad_id, SUM(impressions) AS H1_impressions, AVG(ctr) AS H1_avg_ctr FROM ad_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY ad_id) SELECT a.ad_id, a.ad_title, a.platform, COALESCE(ham.H1_impressions, 0) AS H1_impressions, COALESCE(ham.H1_avg_ctr, 0) AS H1_avg_ctr FROM ads AS a JOIN campaigns AS cm ON a.campaign_id = cm.campaign_id LEFT JOIN H1AdMetrics AS ham ON a.ad_id = ham.ad_id LEFT JOIN ad_rejections AS ar ON a.ad_id = ar.ad_id AND ar.rejection_date > '2023-01-01' WHERE cm.campaign_name = 'Summer Sale 2023' AND a.status = 'Active' AND a.ad_type = 'Banner' AND ar.ad_id IS NULL ORDER BY H1_impressions DESC, H1_avg_ctr DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT l.location_id, l.location_name, l.city, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.location_id = l.location_id AND e.hire_date > '2023-01-01') AS new_hires_2023, (SELECT AVG(r.rating) FROM office_reviews r WHERE r.location_id = l.location_id) AS avg_office_rating FROM locations l WHERE l.country = 'Canada' AND l.location_type = 'Office' AND l.location_id NOT IN (SELECT co.location_id FROM construction_projects co WHERE co.end_date > CURDATE()) AND EXISTS (SELECT 1 FROM location_amenities la WHERE la.location_id = l.location_id AND la.amenity_type = 'Cafeteria') ORDER BY new_hires_2023 DESC, avg_office_rating DESC LIMIT 10;","output":"WITH LocationEmployeeStats AS (SELECT e.location_id, COUNT(e.employee_id) AS new_hires_2023 FROM employees AS e WHERE e.hire_date > '2023-01-01' GROUP BY e.location_id), OfficeRatings AS (SELECT location_id, AVG(rating) AS avg_office_rating FROM office_reviews GROUP BY location_id) SELECT l.location_id, l.location_name, l.city, COALESCE(les.new_hires_2023, 0) AS new_hires_2023, COALESCE(ors.avg_office_rating, 0) AS avg_office_rating FROM locations AS l LEFT JOIN LocationEmployeeStats AS les ON l.location_id = les.location_id LEFT JOIN OfficeRatings AS ors ON l.location_id = ors.location_id LEFT JOIN construction_projects AS cp ON l.location_id = cp.location_id AND cp.end_date > CURDATE() JOIN location_amenities AS la ON l.location_id = la.location_id WHERE l.country = 'Canada' AND l.location_type = 'Office' AND cp.location_id IS NULL AND la.amenity_type = 'Cafeteria' ORDER BY new_hires_2023 DESC, avg_office_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT m.membership_id, m.member_name, m.membership_level, (SELECT COUNT(a.activity_id) FROM member_activities a WHERE a.membership_id = m.membership_id AND a.activity_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_activities, (SELECT MAX(a.activity_date) FROM member_activities a WHERE a.membership_id = m.membership_id) AS last_activity FROM memberships m WHERE m.status = 'Active' AND m.join_date < '2022-01-01' AND m.membership_id NOT IN (SELECT fp.membership_id FROM membership_violations fp WHERE fp.violation_date > '2023-01-01' AND fp.severity = 'High') AND EXISTS (SELECT 1 FROM member_benefits mb JOIN benefits b ON mb.benefit_id = b.benefit_id WHERE mb.membership_id = m.membership_id AND b.benefit_type = 'Exclusive Access') ORDER BY annual_activities DESC, last_activity DESC LIMIT 15;","output":"WITH MemberActivityStats AS (SELECT membership_id, COUNT(activity_id) AS annual_activities, MAX(activity_date) AS last_activity FROM member_activities WHERE activity_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY membership_id) SELECT m.membership_id, m.member_name, m.membership_level, COALESCE(mas.annual_activities, 0) AS annual_activities, mas.last_activity FROM memberships AS m LEFT JOIN MemberActivityStats AS mas ON m.membership_id = mas.membership_id LEFT JOIN membership_violations AS mv ON m.membership_id = mv.membership_id AND mv.violation_date > '2023-01-01' AND mv.severity = 'High' JOIN member_benefits AS mb ON m.membership_id = mb.membership_id JOIN benefits AS b ON mb.benefit_id = b.benefit_id WHERE m.status = 'Active' AND m.join_date < '2022-01-01' AND mv.membership_id IS NULL AND b.benefit_type = 'Exclusive Access' ORDER BY annual_activities DESC, last_activity DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.supplier_id, s.supplier_name, s.country, (SELECT SUM(po.total_amount) FROM purchase_orders po WHERE po.supplier_id = s.supplier_id AND po.order_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_purchase_amount, (SELECT AVG(dp.delivery_rating) FROM delivery_performance dp WHERE dp.supplier_id = s.supplier_id AND dp.rating_date > '2023-01-01') AS avg_delivery_rating FROM suppliers s WHERE s.supplier_status = 'Approved' AND s.contract_start_date < '2021-01-01' AND s.supplier_id NOT IN (SELECT qr.supplier_id FROM quality_reports qr WHERE qr.report_date > '2023-01-01' AND qr.issue_type = 'Major') AND EXISTS (SELECT 1 FROM supplier_products sp WHERE sp.supplier_id = s.supplier_id AND sp.product_category = 'Raw Materials') ORDER BY H1_purchase_amount DESC, avg_delivery_rating DESC LIMIT 10;","output":"WITH SupplierPurchaseStats AS (SELECT supplier_id, SUM(total_amount) AS H1_purchase_amount FROM purchase_orders WHERE order_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY supplier_id), DeliveryRatings AS (SELECT supplier_id, AVG(delivery_rating) AS avg_delivery_rating FROM delivery_performance WHERE rating_date > '2023-01-01' GROUP BY supplier_id) SELECT s.supplier_id, s.supplier_name, s.country, COALESCE(sps.H1_purchase_amount, 0) AS H1_purchase_amount, COALESCE(dr.avg_delivery_rating, 0) AS avg_delivery_rating FROM suppliers AS s LEFT JOIN SupplierPurchaseStats AS sps ON s.supplier_id = sps.supplier_id LEFT JOIN DeliveryRatings AS dr ON s.supplier_id = dr.supplier_id LEFT JOIN quality_reports AS qr ON s.supplier_id = qr.supplier_id AND qr.report_date > '2023-01-01' AND qr.issue_type = 'Major' JOIN supplier_products AS sp ON s.supplier_id = sp.supplier_id WHERE s.supplier_status = 'Approved' AND s.contract_start_date < '2021-01-01' AND qr.supplier_id IS NULL AND sp.product_category = 'Raw Materials' ORDER BY H1_purchase_amount DESC, avg_delivery_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT v.vessel_id, v.vessel_name, v.vessel_type, (SELECT MAX(sp.speed_knots) FROM voyage_segments vs JOIN speed_readings sp ON vs.segment_id = sp.segment_id WHERE vs.vessel_id = v.vessel_id AND vs.voyage_date > '2023-01-01') AS max_recent_speed, (SELECT AVG(fc.fuel_consumption_per_hour) FROM voyage_segments vs JOIN fuel_logs fc ON vs.segment_id = fc.segment_id WHERE vs.vessel_id = v.vessel_id AND vs.voyage_date > '2023-01-01') AS avg_recent_fuel_consumption FROM vessels v WHERE v.status = 'Operational' AND v.build_year < 2010 AND v.vessel_id NOT IN (SELECT md.vessel_id FROM maintenance_due md WHERE md.due_date < CURDATE() + INTERVAL 30 DAY) AND EXISTS (SELECT 1 FROM vessel_sensors vsn WHERE vsn.vessel_id = v.vessel_id AND vsn.sensor_type = 'Engine Monitoring') ORDER BY max_recent_speed DESC, avg_recent_fuel_consumption ASC LIMIT 10;","output":"WITH VesselSpeed AS (SELECT vs.vessel_id, MAX(sp.speed_knots) AS max_recent_speed FROM voyage_segments AS vs JOIN speed_readings AS sp ON vs.segment_id = sp.segment_id WHERE vs.voyage_date > '2023-01-01' GROUP BY vs.vessel_id), VesselFuel AS (SELECT vs.vessel_id, AVG(fc.fuel_consumption_per_hour) AS avg_recent_fuel_consumption FROM voyage_segments AS vs JOIN fuel_logs AS fc ON vs.segment_id = fc.segment_id WHERE vs.voyage_date > '2023-01-01' GROUP BY vs.vessel_id) SELECT v.vessel_id, v.vessel_name, v.vessel_type, COALESCE(vs.max_recent_speed, 0) AS max_recent_speed, COALESCE(vf.avg_recent_fuel_consumption, 0) AS avg_recent_fuel_consumption FROM vessels AS v LEFT JOIN VesselSpeed AS vs ON v.vessel_id = vs.vessel_id LEFT JOIN VesselFuel AS vf ON v.vessel_id = vf.vessel_id LEFT JOIN maintenance_due AS md ON v.vessel_id = md.vessel_id AND md.due_date < CURDATE() + INTERVAL 30 DAY JOIN vessel_sensors AS vsn ON v.vessel_id = vsn.vessel_id WHERE v.status = 'Operational' AND v.build_year < 2010 AND md.vessel_id IS NULL AND vsn.sensor_type = 'Engine Monitoring' ORDER BY max_recent_speed DESC, avg_recent_fuel_consumption ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.start_date, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = p.project_id AND t.status = 'Completed') AS completed_tasks_count, (SELECT AVG(t.actual_duration_days) FROM tasks t WHERE t.project_id = p.project_id AND t.status = 'Completed') AS avg_task_completion_time FROM projects p WHERE p.status = 'Active' AND p.budget > 100000 AND p.project_id NOT IN (SELECT di.project_id FROM project_delays di WHERE di.delay_start_date > '2023-01-01' AND di.severity = 'High') AND EXISTS (SELECT 1 FROM project_managers pm JOIN employees e ON pm.employee_id = e.employee_id WHERE pm.project_id = p.project_id AND e.department_id = (SELECT department_id FROM departments WHERE department_name = 'Project Management')) ORDER BY completed_tasks_count DESC, avg_task_completion_time ASC LIMIT 10;","output":"WITH ProjectTaskStats AS (SELECT project_id, COUNT(task_id) AS completed_tasks_count, AVG(actual_duration_days) AS avg_task_completion_time FROM tasks WHERE status = 'Completed' GROUP BY project_id) SELECT p.project_id, p.project_name, p.start_date, COALESCE(pts.completed_tasks_count, 0) AS completed_tasks_count, COALESCE(pts.avg_task_completion_time, 0) AS avg_task_completion_time FROM projects AS p LEFT JOIN ProjectTaskStats AS pts ON p.project_id = pts.project_id LEFT JOIN project_delays AS pd ON p.project_id = pd.project_id AND pd.delay_start_date > '2023-01-01' AND pd.severity = 'High' JOIN project_managers AS pm ON p.project_id = pm.project_id JOIN employees AS e ON pm.employee_id = e.employee_id JOIN departments AS d ON e.department_id = d.department_id WHERE p.status = 'Active' AND p.budget > 100000 AND pd.project_id IS NULL AND d.department_name = 'Project Management' ORDER BY completed_tasks_count DESC, avg_task_completion_time ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT cu.customer_id, cu.customer_name, cu.email, (SELECT COUNT(s.subscription_id) FROM subscriptions s WHERE s.customer_id = cu.customer_id AND s.status = 'Active') AS active_subscriptions, (SELECT MAX(o.order_date) FROM orders o WHERE o.customer_id = cu.customer_id) AS last_order_date FROM customers cu WHERE cu.registration_date > '2022-01-01' AND cu.customer_type = 'Premium' AND cu.customer_id NOT IN (SELECT cp.customer_id FROM churned_customers cp WHERE cp.churn_date > '2023-01-01') AND EXISTS (SELECT 1 FROM customer_feedback cf WHERE cf.customer_id = cu.customer_id AND cf.feedback_score = 5) ORDER BY active_subscriptions DESC, last_order_date DESC LIMIT 15;","output":"WITH CustomerSubscriptionStats AS (SELECT customer_id, COUNT(subscription_id) AS active_subscriptions FROM subscriptions WHERE status = 'Active' GROUP BY customer_id), LastOrderDate AS (SELECT customer_id, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id) SELECT cu.customer_id, cu.customer_name, cu.email, COALESCE(css.active_subscriptions, 0) AS active_subscriptions, lod.last_order_date FROM customers AS cu LEFT JOIN CustomerSubscriptionStats AS css ON cu.customer_id = css.customer_id LEFT JOIN LastOrderDate AS lod ON cu.customer_id = lod.customer_id LEFT JOIN churned_customers AS cc ON cu.customer_id = cc.customer_id AND cc.churn_date > '2023-01-01' JOIN customer_feedback AS cf ON cu.customer_id = cf.customer_id WHERE cu.registration_date > '2022-01-01' AND cu.customer_type = 'Premium' AND cc.customer_id IS NULL AND cf.feedback_score = 5 ORDER BY active_subscriptions DESC, last_order_date DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT b.building_id, b.building_name, b.address, (SELECT SUM(uf.utility_cost) FROM utility_bills uf WHERE uf.building_id = b.building_id AND uf.bill_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_utility_cost, (SELECT AVG(oc.occupancy_rate) FROM occupancy_data oc WHERE oc.building_id = b.building_id AND oc.data_date BETWEEN '2023-01-01' AND '2023-12-31') AS avg_annual_occupancy FROM buildings b WHERE b.building_type = 'Commercial' AND b.year_built < 2000 AND b.building_id NOT IN (SELECT rs.building_id FROM structural_issues rs WHERE rs.issue_date > '2023-01-01' AND rs.severity = 'High') AND EXISTS (SELECT 1 FROM building_certifications bc WHERE bc.building_id = b.building_id AND bc.certification_type = 'LEED Platinum') ORDER BY annual_utility_cost DESC, avg_annual_occupancy DESC LIMIT 10;","output":"WITH BuildingUtilityCosts AS (SELECT building_id, SUM(utility_cost) AS annual_utility_cost FROM utility_bills WHERE bill_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY building_id), AnnualOccupancy AS (SELECT building_id, AVG(occupancy_rate) AS avg_annual_occupancy FROM occupancy_data WHERE data_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY building_id) SELECT b.building_id, b.building_name, b.address, COALESCE(buc.annual_utility_cost, 0) AS annual_utility_cost, COALESCE(ao.avg_annual_occupancy, 0) AS avg_annual_occupancy FROM buildings AS b LEFT JOIN BuildingUtilityCosts AS buc ON b.building_id = buc.building_id LEFT JOIN AnnualOccupancy AS ao ON b.building_id = ao.building_id LEFT JOIN structural_issues AS si ON b.building_id = si.building_id AND si.issue_date > '2023-01-01' AND si.severity = 'High' JOIN building_certifications AS bc ON b.building_id = bc.building_id WHERE b.building_type = 'Commercial' AND b.year_built < 2000 AND si.building_id IS NULL AND bc.certification_type = 'LEED Platinum' ORDER BY annual_utility_cost DESC, avg_annual_occupancy DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT inv.investor_id, inv.investor_name, inv.country, (SELECT SUM(tr.amount) FROM transactions tr WHERE tr.investor_id = inv.investor_id AND tr.transaction_type = 'Equity Buy' AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_equity_buys, (SELECT AVG(pr.return_percentage) FROM portfolio_returns pr WHERE pr.investor_id = inv.investor_id AND pr.period = 'YTD') AS YTD_avg_return FROM investors inv WHERE inv.investment_focus = 'Technology' AND inv.risk_tolerance = 'High' AND inv.investor_id NOT IN (SELECT ft.investor_id FROM fraudulent_transactions ft WHERE ft.transaction_date > '2023-01-01') AND EXISTS (SELECT 1 FROM investor_preferences ip WHERE ip.investor_id = inv.investor_id AND ip.preference_type = 'ESG Investing') ORDER BY H1_equity_buys DESC, YTD_avg_return DESC LIMIT 10;","output":"WITH H1EquityBuys AS (SELECT investor_id, SUM(amount) AS H1_equity_buys FROM transactions WHERE transaction_type = 'Equity Buy' AND transaction_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY investor_id), YTDReturns AS (SELECT investor_id, AVG(return_percentage) AS YTD_avg_return FROM portfolio_returns WHERE period = 'YTD' GROUP BY investor_id) SELECT inv.investor_id, inv.investor_name, inv.country, COALESCE(heb.H1_equity_buys, 0) AS H1_equity_buys, COALESCE(ytdr.YTD_avg_return, 0) AS YTD_avg_return FROM investors AS inv LEFT JOIN H1EquityBuys AS heb ON inv.investor_id = heb.investor_id LEFT JOIN YTDReturns AS ytdr ON inv.investor_id = ytdr.investor_id LEFT JOIN fraudulent_transactions AS ft ON inv.investor_id = ft.investor_id AND ft.transaction_date > '2023-01-01' JOIN investor_preferences AS ip ON inv.investor_id = ip.investor_id WHERE inv.investment_focus = 'Technology' AND inv.risk_tolerance = 'High' AND ft.investor_id IS NULL AND ip.preference_type = 'ESG Investing' ORDER BY H1_equity_buys DESC, YTD_avg_return DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT d.division_id, d.division_name, d.head_count, (SELECT COUNT(p.project_id) FROM projects p WHERE p.division_id = d.division_id AND p.status = 'Completed' AND p.end_date BETWEEN '2023-01-01' AND '2023-12-31') AS completed_projects_2023, (SELECT AVG(e.salary) FROM employees e WHERE e.division_id = d.division_id AND e.status = 'Active') AS avg_division_salary FROM divisions d WHERE d.annual_revenue_usd > 100000000 AND d.location = 'Global' AND d.division_id NOT IN (SELECT rd.division_id FROM restructuring_data rd WHERE rd.start_date < CURDATE() AND rd.end_date > CURDATE()) AND EXISTS (SELECT 1 FROM division_goals dg WHERE dg.division_id = d.division_id AND dg.goal_year = 2023 AND dg.status = 'Achieved') ORDER BY completed_projects_2023 DESC, avg_division_salary DESC LIMIT 10;","output":"WITH CompletedProjects AS (SELECT project_id, division_id FROM projects WHERE status = 'Completed' AND end_date BETWEEN '2023-01-01' AND '2023-12-31'), DivisionProjectCounts AS (SELECT division_id, COUNT(project_id) AS completed_projects_2023 FROM CompletedProjects GROUP BY division_id), DivisionAvgSalary AS (SELECT division_id, AVG(salary) AS avg_division_salary FROM employees WHERE status = 'Active' GROUP BY division_id) SELECT d.division_id, d.division_name, d.head_count, COALESCE(dpc.completed_projects_2023, 0) AS completed_projects_2023, COALESCE(das.avg_division_salary, 0) AS avg_division_salary FROM divisions AS d LEFT JOIN DivisionProjectCounts AS dpc ON d.division_id = dpc.division_id LEFT JOIN DivisionAvgSalary AS das ON d.division_id = das.division_id LEFT JOIN restructuring_data AS rd ON d.division_id = rd.division_id AND rd.start_date < CURDATE() AND rd.end_date > CURDATE() JOIN division_goals AS dg ON d.division_id = dg.division_id WHERE d.annual_revenue_usd > 100000000 AND d.location = 'Global' AND rd.division_id IS NULL AND dg.goal_year = 2023 AND dg.status = 'Achieved' ORDER BY completed_projects_2023 DESC, avg_division_salary DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.store_id, s.store_name, s.city, s.region, (SELECT SUM(t.total_amount) FROM transactions t WHERE t.store_id = s.store_id AND t.transaction_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_total_sales, (SELECT AVG(cr.customer_satisfaction_score) FROM customer_reviews cr WHERE cr.store_id = s.store_id AND cr.review_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_satisfaction FROM stores s WHERE s.store_type = 'Retail' AND s.opening_date < '2015-01-01' AND s.store_id NOT IN (SELECT fa.store_id FROM facility_alerts fa WHERE fa.alert_date > '2023-01-01' AND fa.alert_type = 'Security Breach') AND EXISTS (SELECT 1 FROM store_products sp JOIN products p ON sp.product_id = p.product_id WHERE sp.store_id = s.store_id AND p.category_id = (SELECT category_id FROM categories WHERE category_name = 'Electronics')) ORDER BY Q1_total_sales DESC, Q1_avg_satisfaction DESC LIMIT 10;","output":"WITH Q1Sales AS (SELECT store_id, SUM(total_amount) AS Q1_total_sales FROM transactions WHERE transaction_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY store_id), Q1Satisfaction AS (SELECT store_id, AVG(customer_satisfaction_score) AS Q1_avg_satisfaction FROM customer_reviews WHERE review_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY store_id) SELECT s.store_id, s.store_name, s.city, s.region, COALESCE(qs.Q1_total_sales, 0) AS Q1_total_sales, COALESCE(qcs.Q1_avg_satisfaction, 0) AS Q1_avg_satisfaction FROM stores AS s LEFT JOIN Q1Sales AS qs ON s.store_id = qs.store_id LEFT JOIN Q1Satisfaction AS qcs ON s.store_id = qcs.store_id LEFT JOIN facility_alerts AS fa ON s.store_id = fa.store_id AND fa.alert_date > '2023-01-01' AND fa.alert_type = 'Security Breach' JOIN store_products AS sp ON s.store_id = sp.store_id JOIN products AS p ON sp.product_id = p.product_id JOIN categories AS cat ON p.category_id = cat.category_id WHERE s.store_type = 'Retail' AND s.opening_date < '2015-01-01' AND fa.store_id IS NULL AND cat.category_name = 'Electronics' GROUP BY s.store_id, s.store_name, s.city, s.region ORDER BY Q1_total_sales DESC, Q1_avg_satisfaction DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.country_name, c.population, c.gdp_usd, (SELECT AVG(le.life_expectancy) FROM demographics le WHERE le.country_id = c.country_id AND le.year = 2023) AS avg_life_expectancy_2023, (SELECT SUM(co2.emissions_metric_tons) FROM carbon_emissions co2 WHERE co2.country_id = c.country_id AND co2.year BETWEEN 2020 AND 2022) AS last_3_year_emissions FROM countries c WHERE c.continent = 'Europe' AND c.gdp_per_capita_usd > 50000 AND c.country_id NOT IN (SELECT dr.country_id FROM disaster_relief dr WHERE dr.disaster_date > '2023-01-01' AND dr.relief_amount > 1000000) AND EXISTS (SELECT 1 FROM country_trade_agreements cta WHERE cta.country_id = c.country_id AND cta.partner_country_id IN (SELECT country_id FROM countries WHERE country_name = 'USA')) ORDER BY avg_life_expectancy_2023 DESC, last_3_year_emissions ASC LIMIT 10;","output":"WITH CountryDemographics AS (SELECT country_id, AVG(life_expectancy) AS avg_life_expectancy_2023 FROM demographics WHERE year = 2023 GROUP BY country_id), CarbonEmissions AS (SELECT country_id, SUM(emissions_metric_tons) AS last_3_year_emissions FROM carbon_emissions WHERE year BETWEEN 2020 AND 2022 GROUP BY country_id), USACountry AS (SELECT country_id FROM countries WHERE country_name = 'USA') SELECT c.country_name, c.population, c.gdp_usd, COALESCE(cd.avg_life_expectancy_2023, 0) AS avg_life_expectancy_2023, COALESCE(ce.last_3_year_emissions, 0) AS last_3_year_emissions FROM countries AS c LEFT JOIN CountryDemographics AS cd ON c.country_id = cd.country_id LEFT JOIN CarbonEmissions AS ce ON c.country_id = ce.country_id LEFT JOIN disaster_relief AS dr ON c.country_id = dr.country_id AND dr.disaster_date > '2023-01-01' AND dr.relief_amount > 1000000 JOIN country_trade_agreements AS cta ON c.country_id = cta.country_id JOIN USACountry AS uc ON cta.partner_country_id = uc.country_id WHERE c.continent = 'Europe' AND c.gdp_per_capita_usd > 50000 AND dr.country_id IS NULL ORDER BY avg_life_expectancy_2023 DESC, last_3_year_emissions ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.shipping_provider_id, s.provider_name, s.country, (SELECT AVG(dt.delivery_time_days) FROM delivery_tracking dt WHERE dt.shipping_provider_id = s.shipping_provider_id AND dt.delivery_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_delivery_time, (SELECT COUNT(pkg.package_id) FROM packages pkg WHERE pkg.shipping_provider_id = s.shipping_provider_id AND pkg.status = 'Delivered' AND pkg.delivery_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_delivered_packages FROM shipping_providers s WHERE s.service_type = 'Express' AND s.rating > 4.0 AND s.shipping_provider_id NOT IN (SELECT is.provider_id FROM incident_shipments is WHERE is.incident_date > '2023-01-01' AND is.severity = 'High') AND EXISTS (SELECT 1 FROM provider_coverage pc WHERE pc.shipping_provider_id = s.shipping_provider_id AND pc.coverage_area = 'International') ORDER BY H1_avg_delivery_time ASC, H1_delivered_packages DESC LIMIT 10;","output":"WITH H1DeliveryStats AS (SELECT dt.shipping_provider_id, AVG(dt.delivery_time_days) AS H1_avg_delivery_time FROM delivery_tracking AS dt WHERE dt.delivery_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY dt.shipping_provider_id), H1DeliveredPackages AS (SELECT pkg.shipping_provider_id, COUNT(pkg.package_id) AS H1_delivered_packages FROM packages AS pkg WHERE pkg.status = 'Delivered' AND pkg.delivery_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY pkg.shipping_provider_id) SELECT s.shipping_provider_id, s.provider_name, s.country, COALESCE(hds.H1_avg_delivery_time, 0) AS H1_avg_delivery_time, COALESCE(hdp.H1_delivered_packages, 0) AS H1_delivered_packages FROM shipping_providers AS s LEFT JOIN H1DeliveryStats AS hds ON s.shipping_provider_id = hds.shipping_provider_id LEFT JOIN H1DeliveredPackages AS hdp ON s.shipping_provider_id = hdp.shipping_provider_id LEFT JOIN incident_shipments AS ins ON s.shipping_provider_id = ins.provider_id AND ins.incident_date > '2023-01-01' AND ins.severity = 'High' JOIN provider_coverage AS pc ON s.shipping_provider_id = pc.shipping_provider_id WHERE s.service_type = 'Express' AND s.rating > 4.0 AND ins.provider_id IS NULL AND pc.coverage_area = 'International' ORDER BY H1_avg_delivery_time ASC, H1_delivered_packages DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT cu.currency_code, cu.currency_name, (SELECT AVG(er.exchange_rate) FROM exchange_rates er WHERE er.to_currency_code = cu.currency_code AND er.exchange_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_exchange_rate, (SELECT MAX(er.exchange_rate) FROM exchange_rates er WHERE er.to_currency_code = cu.currency_code AND er.exchange_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_max_exchange_rate FROM currencies cu WHERE cu.is_fiat = TRUE AND cu.country_code IN ('USD', 'EUR', 'GBP') AND cu.currency_code NOT IN (SELECT cr.currency_code FROM currency_restrictions cr WHERE cr.restriction_start_date < CURDATE() AND cr.restriction_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM currency_trade_volumes ctv WHERE ctv.currency_code = cu.currency_code AND ctv.trade_date = CURDATE()) ORDER BY Q1_avg_exchange_rate DESC, Q1_max_exchange_rate DESC LIMIT 5;","output":"WITH Q1ExchangeRates AS (SELECT to_currency_code AS currency_code, AVG(exchange_rate) AS Q1_avg_exchange_rate, MAX(exchange_rate) AS Q1_max_exchange_rate FROM exchange_rates WHERE exchange_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY to_currency_code) SELECT cu.currency_code, cu.currency_name, COALESCE(qer.Q1_avg_exchange_rate, 0) AS Q1_avg_exchange_rate, COALESCE(qer.Q1_max_exchange_rate, 0) AS Q1_max_exchange_rate FROM currencies AS cu LEFT JOIN Q1ExchangeRates AS qer ON cu.currency_code = qer.currency_code LEFT JOIN currency_restrictions AS cr ON cu.currency_code = cr.currency_code AND cr.restriction_start_date < CURDATE() AND cr.restriction_end_date > CURDATE() JOIN currency_trade_volumes AS ctv ON cu.currency_code = ctv.currency_code WHERE cu.is_fiat = TRUE AND cu.country_code IN ('USD', 'EUR', 'GBP') AND cr.currency_code IS NULL AND ctv.trade_date = CURDATE() ORDER BY Q1_avg_exchange_rate DESC, Q1_max_exchange_rate DESC LIMIT 5;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.trainer_id, tr.trainer_name, tr.specialty, (SELECT COUNT(cs.client_id) FROM client_sessions cs WHERE cs.trainer_id = tr.trainer_id AND cs.session_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_sessions_count, (SELECT AVG(cs.duration_minutes) FROM client_sessions cs WHERE cs.trainer_id = tr.trainer_id AND cs.session_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_session_duration FROM trainers tr WHERE tr.experience_years > 10 AND tr.certifications LIKE '%NASM%' AND tr.trainer_id NOT IN (SELECT co.trainer_id FROM trainer_complaints co WHERE co.complaint_date > '2023-01-01' AND co.severity = 'High') AND EXISTS (SELECT 1 FROM trainer_availability ta WHERE ta.trainer_id = tr.trainer_id AND ta.day_of_week = 'Monday' AND ta.is_available = TRUE) ORDER BY H1_sessions_count DESC, H1_avg_session_duration DESC LIMIT 10;","output":"WITH H1TrainerStats AS (SELECT trainer_id, COUNT(client_id) AS H1_sessions_count, AVG(duration_minutes) AS H1_avg_session_duration FROM client_sessions WHERE session_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY trainer_id) SELECT tr.trainer_id, tr.trainer_name, tr.specialty, COALESCE(hts.H1_sessions_count, 0) AS H1_sessions_count, COALESCE(hts.H1_avg_session_duration, 0) AS H1_avg_session_duration FROM trainers AS tr LEFT JOIN H1TrainerStats AS hts ON tr.trainer_id = hts.trainer_id LEFT JOIN trainer_complaints AS tc ON tr.trainer_id = tc.trainer_id AND tc.complaint_date > '2023-01-01' AND tc.severity = 'High' JOIN trainer_availability AS ta ON tr.trainer_id = ta.trainer_id WHERE tr.experience_years > 10 AND tr.certifications LIKE '%NASM%' AND tc.trainer_id IS NULL AND ta.day_of_week = 'Monday' AND ta.is_available = TRUE ORDER BY H1_sessions_count DESC, H1_avg_session_duration DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT crs.course_id, crs.course_name, crs.department, (SELECT AVG(e.grade) FROM enrollments e WHERE e.course_id = crs.course_id AND e.enrollment_date > '2023-01-01') AS avg_grade_2023, (SELECT COUNT(DISTINCT s.student_id) FROM enrollments e JOIN students s ON e.student_id = s.student_id WHERE e.course_id = crs.course_id AND s.student_status = 'Active') AS active_students FROM courses crs WHERE crs.credits >= 3 AND crs.course_level = 'Graduate' AND crs.course_id NOT IN (SELECT oc.course_id FROM course_cancellations oc WHERE oc.cancellation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM course_prerequisites cp JOIN courses pre_crs ON cp.prerequisite_course_id = pre_crs.course_id WHERE cp.course_id = crs.course_id AND pre_crs.course_code = 'CS101') ORDER BY avg_grade_2023 DESC, active_students DESC LIMIT 15;","output":"WITH CourseGradeStats AS (SELECT course_id, AVG(grade) AS avg_grade_2023 FROM enrollments WHERE enrollment_date > '2023-01-01' GROUP BY course_id), ActiveStudentsCount AS (SELECT e.course_id, COUNT(DISTINCT s.student_id) AS active_students FROM enrollments AS e JOIN students AS s ON e.student_id = s.student_id WHERE s.student_status = 'Active' GROUP BY e.course_id) SELECT crs.course_id, crs.course_name, crs.department, COALESCE(cgs.avg_grade_2023, 0) AS avg_grade_2023, COALESCE(asc.active_students, 0) AS active_students FROM courses AS crs LEFT JOIN CourseGradeStats AS cgs ON crs.course_id = cgs.course_id LEFT JOIN ActiveStudentsCount AS asc ON crs.course_id = asc.course_id LEFT JOIN course_cancellations AS cc ON crs.course_id = cc.course_id AND cc.cancellation_date > '2023-01-01' JOIN course_prerequisites AS cp ON crs.course_id = cp.course_id JOIN courses AS pre_crs ON cp.prerequisite_course_id = pre_crs.course_id WHERE crs.credits >= 3 AND crs.course_level = 'Graduate' AND cc.course_id IS NULL AND pre_crs.course_code = 'CS101' ORDER BY avg_grade_2023 DESC, active_students DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT l.listing_id, l.title, l.price, l.posted_date, (SELECT AVG(r.rating) FROM property_reviews r WHERE r.listing_id = l.listing_id) AS avg_listing_rating, (SELECT COUNT(i.inquiry_id) FROM property_inquiries i WHERE i.listing_id = l.listing_id AND i.inquiry_date > '2023-01-01') AS recent_inquiries FROM listings l WHERE l.status = 'Active' AND l.property_type = 'Apartment' AND l.city = 'San Francisco' AND l.listing_id NOT IN (SELECT dl.listing_id FROM delisted_properties dl WHERE dl.delist_date > '2023-01-01') AND EXISTS (SELECT 1 FROM listing_amenities la WHERE la.listing_id = l.listing_id AND la.amenity_name = 'Gym') ORDER BY avg_listing_rating DESC, recent_inquiries DESC LIMIT 20;","output":"WITH ListingRatings AS (SELECT listing_id, AVG(rating) AS avg_listing_rating FROM property_reviews GROUP BY listing_id), RecentInquiries AS (SELECT listing_id, COUNT(inquiry_id) AS recent_inquiries FROM property_inquiries WHERE inquiry_date > '2023-01-01' GROUP BY listing_id) SELECT l.listing_id, l.title, l.price, l.posted_date, COALESCE(lr.avg_listing_rating, 0) AS avg_listing_rating, COALESCE(ri.recent_inquiries, 0) AS recent_inquiries FROM listings AS l LEFT JOIN ListingRatings AS lr ON l.listing_id = lr.listing_id LEFT JOIN RecentInquiries AS ri ON l.listing_id = ri.listing_id LEFT JOIN delisted_properties AS dp ON l.listing_id = dp.listing_id AND dp.delist_date > '2023-01-01' JOIN listing_amenities AS la ON l.listing_id = la.listing_id WHERE l.status = 'Active' AND l.property_type = 'Apartment' AND l.city = 'San Francisco' AND dp.listing_id IS NULL AND la.amenity_name = 'Gym' ORDER BY avg_listing_rating DESC, recent_inquiries DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT m.member_id, m.member_name, m.email, (SELECT COUNT(lp.loan_id) FROM loan_applications lp WHERE lp.member_id = m.member_id AND lp.application_date > '2023-01-01') AS loan_applications_2023, (SELECT SUM(lg.amount) FROM loan_grants lg WHERE lg.member_id = m.member_id AND lg.grant_date > '2023-01-01') AS total_loans_granted_2023 FROM members m WHERE m.status = 'Active' AND m.join_date < '2020-01-01' AND m.member_id NOT IN (SELECT dm.member_id FROM delinquent_members dm WHERE dm.delinquency_start_date < CURDATE() AND dm.delinquency_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM member_benefits mb JOIN benefits b ON mb.benefit_id = b.benefit_id WHERE mb.member_id = m.member_id AND b.benefit_type = 'Financial Counseling') ORDER BY loan_applications_2023 DESC, total_loans_granted_2023 DESC LIMIT 10;","output":"WITH MemberLoanStats AS (SELECT m.member_id, COUNT(lp.loan_id) AS loan_applications_2023, SUM(lg.amount) AS total_loans_granted_2023 FROM members AS m LEFT JOIN loan_applications AS lp ON m.member_id = lp.member_id AND lp.application_date > '2023-01-01' LEFT JOIN loan_grants AS lg ON m.member_id = lg.member_id AND lg.grant_date > '2023-01-01' GROUP BY m.member_id) SELECT m.member_id, m.member_name, m.email, COALESCE(mls.loan_applications_2023, 0) AS loan_applications_2023, COALESCE(mls.total_loans_granted_2023, 0) AS total_loans_granted_2023 FROM members AS m LEFT JOIN MemberLoanStats AS mls ON m.member_id = mls.member_id LEFT JOIN delinquent_members AS dm ON m.member_id = dm.member_id AND dm.delinquency_start_date < CURDATE() AND dm.delinquency_end_date > CURDATE() JOIN member_benefits AS mb ON m.member_id = mb.member_id JOIN benefits AS b ON mb.benefit_id = b.benefit_id WHERE m.status = 'Active' AND m.join_date < '2020-01-01' AND dm.member_id IS NULL AND b.benefit_type = 'Financial Counseling' ORDER BY loan_applications_2023 DESC, total_loans_granted_2023 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.show_id, s.show_title, s.genre, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.show_id = s.show_id AND t.sale_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_tickets_sold, (SELECT AVG(r.rating_score) FROM show_reviews r WHERE r.show_id = s.show_id AND r.review_date > '2023-01-01') AS avg_show_rating FROM shows s WHERE s.status = 'Active' AND s.run_start_date < '2022-01-01' AND s.show_id NOT IN (SELECT cc.show_id FROM show_cancellations cc WHERE cc.cancellation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM show_venues sv JOIN venues v ON sv.venue_id = v.venue_id WHERE sv.show_id = s.show_id AND v.city = 'London') ORDER BY H1_tickets_sold DESC, avg_show_rating DESC LIMIT 10;","output":"WITH H1TicketSales AS (SELECT show_id, COUNT(ticket_id) AS H1_tickets_sold FROM tickets WHERE sale_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY show_id), ShowRatings AS (SELECT show_id, AVG(rating_score) AS avg_show_rating FROM show_reviews WHERE review_date > '2023-01-01' GROUP BY show_id) SELECT s.show_id, s.show_title, s.genre, COALESCE(hts.H1_tickets_sold, 0) AS H1_tickets_sold, COALESCE(sr.avg_show_rating, 0) AS avg_show_rating FROM shows AS s LEFT JOIN H1TicketSales AS hts ON s.show_id = hts.show_id LEFT JOIN ShowRatings AS sr ON s.show_id = sr.show_id LEFT JOIN show_cancellations AS sc ON s.show_id = sc.show_id AND sc.cancellation_date > '2023-01-01' JOIN show_venues AS sv ON s.show_id = sv.show_id JOIN venues AS v ON sv.venue_id = v.venue_id WHERE s.status = 'Active' AND s.run_start_date < '2022-01-01' AND sc.show_id IS NULL AND v.city = 'London' ORDER BY H1_tickets_sold DESC, avg_show_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT art.artwork_id, art.title, art.artist_name, art.creation_year, (SELECT MAX(b.bid_amount) FROM bids b WHERE b.artwork_id = art.artwork_id AND b.bid_date > '2023-01-01') AS highest_recent_bid, (SELECT COUNT(v.visitor_id) FROM gallery_visits v WHERE v.artwork_id = art.artwork_id AND v.visit_date > '2023-01-01') AS total_recent_views FROM artworks art WHERE art.medium = 'Painting' AND art.style = 'Abstract' AND art.artwork_id NOT IN (SELECT cs.artwork_id FROM conservation_status cs WHERE cs.condition = 'Poor' AND cs.status_date > '2023-01-01') AND EXISTS (SELECT 1 FROM artwork_exhibitions ae JOIN exhibitions e ON ae.exhibition_id = e.exhibition_id WHERE ae.artwork_id = art.artwork_id AND e.start_date < CURDATE() AND e.end_date > CURDATE()) ORDER BY highest_recent_bid DESC, total_recent_views DESC LIMIT 10;","output":"WITH ArtworkBidStats AS (SELECT artwork_id, MAX(bid_amount) AS highest_recent_bid FROM bids WHERE bid_date > '2023-01-01' GROUP BY artwork_id), ArtworkViewStats AS (SELECT artwork_id, COUNT(visitor_id) AS total_recent_views FROM gallery_visits WHERE visit_date > '2023-01-01' GROUP BY artwork_id) SELECT art.artwork_id, art.title, art.artist_name, art.creation_year, COALESCE(abs.highest_recent_bid, 0) AS highest_recent_bid, COALESCE(avs.total_recent_views, 0) AS total_recent_views FROM artworks AS art LEFT JOIN ArtworkBidStats AS abs ON art.artwork_id = abs.artwork_id LEFT JOIN ArtworkViewStats AS avs ON art.artwork_id = avs.artwork_id LEFT JOIN conservation_status AS cs ON art.artwork_id = cs.artwork_id AND cs.condition = 'Poor' AND cs.status_date > '2023-01-01' JOIN artwork_exhibitions AS ae ON art.artwork_id = ae.artwork_id JOIN exhibitions AS e ON ae.exhibition_id = e.exhibition_id WHERE art.medium = 'Painting' AND art.style = 'Abstract' AND cs.artwork_id IS NULL AND e.start_date < CURDATE() AND e.end_date > CURDATE() ORDER BY highest_recent_bid DESC, total_recent_views DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT sc.scenario_id, sc.scenario_name, sc.category, (SELECT COUNT(si.incident_id) FROM security_incidents si WHERE si.scenario_id = sc.scenario_id AND si.incident_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_incidents, (SELECT AVG(sir.resolution_time_hours) FROM security_incident_resolutions sir JOIN security_incidents si ON sir.incident_id = si.incident_id WHERE si.scenario_id = sc.scenario_id AND si.incident_date BETWEEN '2023-01-01' AND '2023-12-31') AS avg_resolution_time FROM security_scenarios sc WHERE sc.severity = 'Critical' AND sc.last_updated_date < '2023-01-01' AND sc.scenario_id NOT IN (SELECT ap.scenario_id FROM audit_failures ap WHERE ap.audit_date > '2023-01-01') AND EXISTS (SELECT 1 FROM scenario_threat_actors sta JOIN threat_actors ta ON sta.threat_actor_id = ta.threat_actor_id WHERE sta.scenario_id = sc.scenario_id AND ta.actor_type = 'Nation-State') ORDER BY annual_incidents DESC, avg_resolution_time ASC LIMIT 10;","output":"WITH AnnualIncidents AS (SELECT scenario_id, COUNT(incident_id) AS annual_incidents FROM security_incidents WHERE incident_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY scenario_id), AvgResolutionTime AS (SELECT si.scenario_id, AVG(sir.resolution_time_hours) AS avg_resolution_time FROM security_incident_resolutions AS sir JOIN security_incidents AS si ON sir.incident_id = si.incident_id WHERE si.incident_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY si.scenario_id) SELECT sc.scenario_id, sc.scenario_name, sc.category, COALESCE(ai.annual_incidents, 0) AS annual_incidents, COALESCE(art.avg_resolution_time, 0) AS avg_resolution_time FROM security_scenarios AS sc LEFT JOIN AnnualIncidents AS ai ON sc.scenario_id = ai.scenario_id LEFT JOIN AvgResolutionTime AS art ON sc.scenario_id = art.scenario_id LEFT JOIN audit_failures AS af ON sc.scenario_id = af.scenario_id AND af.audit_date > '2023-01-01' JOIN scenario_threat_actors AS sta ON sc.scenario_id = sta.scenario_id JOIN threat_actors AS ta ON sta.threat_actor_id = ta.threat_actor_id WHERE sc.severity = 'Critical' AND sc.last_updated_date < '2023-01-01' AND af.scenario_id IS NULL AND ta.actor_type = 'Nation-State' ORDER BY annual_incidents DESC, avg_resolution_time ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.transaction_id, tr.transaction_date, tr.amount, ac.account_number, (SELECT SUM(sf.fee_amount) FROM transaction_fees sf WHERE sf.transaction_id = tr.transaction_id) AS total_fees, (SELECT AVG(rt.response_time_ms) FROM transaction_responses rt WHERE rt.transaction_id = tr.transaction_id AND rt.response_date > '2023-01-01') AS avg_response_time FROM transactions tr JOIN accounts ac ON tr.account_id = ac.account_id WHERE tr.transaction_type = 'Payment' AND ac.account_status = 'Active' AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-06-30' AND tr.transaction_id NOT IN (SELECT ft.transaction_id FROM fraudulent_transactions ft WHERE ft.fraud_detection_date > '2023-01-01') AND EXISTS (SELECT 1 FROM transaction_channels tc WHERE tc.transaction_id = tr.transaction_id AND tc.channel_type = 'Online') ORDER BY total_fees DESC, avg_response_time ASC LIMIT 20;","output":"WITH TransactionFees AS (SELECT transaction_id, SUM(fee_amount) AS total_fees FROM transaction_fees GROUP BY transaction_id), TransactionResponses AS (SELECT transaction_id, AVG(response_time_ms) AS avg_response_time FROM transaction_responses WHERE response_date > '2023-01-01' GROUP BY transaction_id) SELECT tr.transaction_id, tr.transaction_date, tr.amount, ac.account_number, COALESCE(tf.total_fees, 0) AS total_fees, COALESCE(tres.avg_response_time, 0) AS avg_response_time FROM transactions AS tr JOIN accounts AS ac ON tr.account_id = ac.account_id LEFT JOIN TransactionFees AS tf ON tr.transaction_id = tf.transaction_id LEFT JOIN TransactionResponses AS tres ON tr.transaction_id = tres.transaction_id LEFT JOIN fraudulent_transactions AS ft ON tr.transaction_id = ft.transaction_id AND ft.fraud_detection_date > '2023-01-01' JOIN transaction_channels AS tc ON tr.transaction_id = tc.transaction_id WHERE tr.transaction_type = 'Payment' AND ac.account_status = 'Active' AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-06-30' AND ft.transaction_id IS NULL AND tc.channel_type = 'Online' ORDER BY total_fees DESC, avg_response_time ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.sensor_id, s.sensor_type, s.location, s.deployment_date, (SELECT AVG(sd.reading_value) FROM sensor_data sd WHERE sd.sensor_id = s.sensor_id AND sd.reading_timestamp BETWEEN '2023-01-01' AND '2023-01-31') AS avg_jan_reading, (SELECT MAX(sd.reading_value) FROM sensor_data sd WHERE sd.sensor_id = s.sensor_id AND sd.reading_timestamp BETWEEN '2023-01-01' AND '2023-01-31') AS max_jan_reading FROM sensors s WHERE s.status = 'Active' AND s.power_source = 'Battery' AND s.sensor_id NOT IN (SELECT ce.sensor_id FROM calibration_errors ce WHERE ce.error_date > '2023-01-01') AND EXISTS (SELECT 1 FROM sensor_networks sn JOIN networks n ON sn.network_id = n.network_id WHERE sn.sensor_id = s.sensor_id AND n.network_type = 'Wireless Mesh') ORDER BY avg_jan_reading DESC, max_jan_reading DESC LIMIT 10;","output":"WITH JanReadings AS (SELECT sensor_id, AVG(reading_value) AS avg_jan_reading, MAX(reading_value) AS max_jan_reading FROM sensor_data WHERE reading_timestamp BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY sensor_id) SELECT s.sensor_id, s.sensor_type, s.location, s.deployment_date, COALESCE(jr.avg_jan_reading, 0) AS avg_jan_reading, COALESCE(jr.max_jan_reading, 0) AS max_jan_reading FROM sensors AS s LEFT JOIN JanReadings AS jr ON s.sensor_id = jr.sensor_id LEFT JOIN calibration_errors AS ce ON s.sensor_id = ce.sensor_id AND ce.error_date > '2023-01-01' JOIN sensor_networks AS sn ON s.sensor_id = sn.sensor_id JOIN networks AS n ON sn.network_id = n.network_id WHERE s.status = 'Active' AND s.power_source = 'Battery' AND ce.sensor_id IS NULL AND n.network_type = 'Wireless Mesh' ORDER BY avg_jan_reading DESC, max_jan_reading DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT proj.project_id, proj.project_name, proj.start_date, proj.end_date, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = proj.project_id AND t.status = 'Completed') AS completed_tasks, (SELECT AVG(ts.actual_hours) FROM task_submissions ts JOIN tasks t ON ts.task_id = t.task_id WHERE t.project_id = proj.project_id) AS avg_task_hours FROM projects proj WHERE proj.status = 'In Progress' AND proj.budget > 50000 AND proj.project_id NOT IN (SELECT pd.project_id FROM project_disputes pd WHERE pd.dispute_date > '2023-01-01' AND pd.severity = 'High') AND EXISTS (SELECT 1 FROM project_teams pt JOIN teams tm ON pt.team_id = tm.team_id WHERE pt.project_id = proj.project_id AND tm.team_type = 'Development') ORDER BY completed_tasks DESC, avg_task_hours ASC LIMIT 15;","output":"WITH ProjectTaskStats AS (SELECT t.project_id, COUNT(t.task_id) AS completed_tasks, AVG(ts.actual_hours) AS avg_task_hours FROM tasks AS t LEFT JOIN task_submissions AS ts ON t.task_id = ts.task_id WHERE t.status = 'Completed' GROUP BY t.project_id) SELECT proj.project_id, proj.project_name, proj.start_date, proj.end_date, COALESCE(pts.completed_tasks, 0) AS completed_tasks, COALESCE(pts.avg_task_hours, 0) AS avg_task_hours FROM projects AS proj LEFT JOIN ProjectTaskStats AS pts ON proj.project_id = pts.project_id LEFT JOIN project_disputes AS pd ON proj.project_id = pd.project_id AND pd.dispute_date > '2023-01-01' AND pd.severity = 'High' JOIN project_teams AS pt ON proj.project_id = pt.project_id JOIN teams AS tm ON pt.team_id = tm.team_id WHERE proj.status = 'In Progress' AND proj.budget > 50000 AND pd.project_id IS NULL AND tm.team_type = 'Development' ORDER BY completed_tasks DESC, avg_task_hours ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT doc.document_id, doc.title, doc.author, doc.publish_date, (SELECT COUNT(re.read_event_id) FROM read_events re WHERE re.document_id = doc.document_id AND re.read_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_reads, (SELECT AVG(us.satisfaction_score) FROM user_feedback us WHERE us.document_id = doc.document_id) AS avg_feedback_score FROM documents doc WHERE doc.document_type = 'Research Paper' AND doc.publish_date > '2022-01-01' AND doc.document_id NOT IN (SELECT pr.document_id FROM plagiarism_reports pr WHERE pr.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM document_tags dt JOIN tags t ON dt.tag_id = t.tag_id WHERE dt.document_id = doc.document_id AND t.tag_name = 'AI Ethics') ORDER BY H1_reads DESC, avg_feedback_score DESC LIMIT 10;","output":"WITH DocumentReadStats AS (SELECT document_id, COUNT(read_event_id) AS H1_reads FROM read_events WHERE read_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY document_id), FeedbackScores AS (SELECT document_id, AVG(satisfaction_score) AS avg_feedback_score FROM user_feedback GROUP BY document_id) SELECT doc.document_id, doc.title, doc.author, doc.publish_date, COALESCE(drs.H1_reads, 0) AS H1_reads, COALESCE(fs.avg_feedback_score, 0) AS avg_feedback_score FROM documents AS doc LEFT JOIN DocumentReadStats AS drs ON doc.document_id = drs.document_id LEFT JOIN FeedbackScores AS fs ON doc.document_id = fs.document_id LEFT JOIN plagiarism_reports AS pr ON doc.document_id = pr.document_id AND pr.report_date > '2023-01-01' JOIN document_tags AS dt ON doc.document_id = dt.document_id JOIN tags AS t ON dt.tag_id = t.tag_id WHERE doc.document_type = 'Research Paper' AND doc.publish_date > '2022-01-01' AND pr.document_id IS NULL AND t.tag_name = 'AI Ethics' ORDER BY H1_reads DESC, avg_feedback_score DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.school_id, s.school_name, s.city, (SELECT COUNT(st.student_id) FROM students st WHERE st.school_id = s.school_id AND st.enrollment_date > '2023-01-01') AS new_students_2023, (SELECT AVG(t.teacher_rating) FROM teachers t WHERE t.school_id = s.school_id) AS avg_teacher_rating FROM schools s WHERE s.school_type = 'Primary' AND s.founding_year < 1950 AND s.school_id NOT IN (SELECT cp.school_id FROM compliance_violations cp WHERE cp.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM school_programs sp WHERE sp.school_id = s.school_id AND sp.program_type = 'STEM') ORDER BY new_students_2023 DESC, avg_teacher_rating DESC LIMIT 10;","output":"WITH SchoolStudentStats AS (SELECT school_id, COUNT(student_id) AS new_students_2023 FROM students WHERE enrollment_date > '2023-01-01' GROUP BY school_id), TeacherRatings AS (SELECT school_id, AVG(teacher_rating) AS avg_teacher_rating FROM teachers GROUP BY school_id) SELECT s.school_id, s.school_name, s.city, COALESCE(sss.new_students_2023, 0) AS new_students_2023, COALESCE(tr.avg_teacher_rating, 0) AS avg_teacher_rating FROM schools AS s LEFT JOIN SchoolStudentStats AS sss ON s.school_id = sss.school_id LEFT JOIN TeacherRatings AS tr ON s.school_id = tr.school_id LEFT JOIN compliance_violations AS cv ON s.school_id = cv.school_id AND cv.violation_date > '2023-01-01' JOIN school_programs AS sp ON s.school_id = sp.school_id WHERE s.school_type = 'Primary' AND s.founding_year < 1950 AND cv.school_id IS NULL AND sp.program_type = 'STEM' ORDER BY new_students_2023 DESC, avg_teacher_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.speaker_id, s.speaker_name, s.specialization, (SELECT COUNT(p.presentation_id) FROM presentations p WHERE p.speaker_id = s.speaker_id AND p.event_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_presentations, (SELECT AVG(fb.feedback_score) FROM presentation_feedback fb WHERE fb.speaker_id = s.speaker_id) AS avg_feedback FROM speakers s WHERE s.country = 'USA' AND s.speaking_experience_years > 5 AND s.speaker_id NOT IN (SELECT cc.speaker_id FROM conflict_of_interest_reports cc WHERE cc.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM speaker_topics st JOIN topics t ON st.topic_id = t.topic_id WHERE st.speaker_id = s.speaker_id AND t.topic_name = 'Machine Learning') ORDER BY annual_presentations DESC, avg_feedback DESC LIMIT 10;","output":"WITH SpeakerPresentationStats AS (SELECT p.speaker_id, COUNT(p.presentation_id) AS annual_presentations FROM presentations AS p WHERE p.event_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY p.speaker_id), SpeakerFeedbackStats AS (SELECT speaker_id, AVG(feedback_score) AS avg_feedback FROM presentation_feedback GROUP BY speaker_id) SELECT s.speaker_id, s.speaker_name, s.specialization, COALESCE(sps.annual_presentations, 0) AS annual_presentations, COALESCE(sfs.avg_feedback, 0) AS avg_feedback FROM speakers AS s LEFT JOIN SpeakerPresentationStats AS sps ON s.speaker_id = sps.speaker_id LEFT JOIN SpeakerFeedbackStats AS sfs ON s.speaker_id = sfs.speaker_id LEFT JOIN conflict_of_interest_reports AS coir ON s.speaker_id = coir.speaker_id AND coir.report_date > '2023-01-01' JOIN speaker_topics AS st ON s.speaker_id = st.speaker_id JOIN topics AS t ON st.topic_id = t.topic_id WHERE s.country = 'USA' AND s.speaking_experience_years > 5 AND coir.speaker_id IS NULL AND t.topic_name = 'Machine Learning' ORDER BY annual_presentations DESC, avg_feedback DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.trade_id, tr.trade_date, tr.symbol, tr.quantity, (SELECT AVG(tp.price) FROM trade_prices tp WHERE tp.trade_id = tr.trade_id AND tp.price_date = tr.trade_date) AS actual_trade_price, (SELECT MAX(tp.volume) FROM trade_prices tp WHERE tp.trade_id = tr.trade_id AND tp.price_date = tr.trade_date) AS max_trade_volume FROM trades tr WHERE tr.trade_type = 'Buy' AND tr.trade_date BETWEEN '2023-01-01' AND '2023-01-31' AND tr.account_id IN (SELECT DISTINCT ia.account_id FROM investor_accounts ia WHERE ia.status = 'Active') AND NOT EXISTS (SELECT 1 FROM trade_alerts ta WHERE ta.trade_id = tr.trade_id AND ta.alert_type = 'Unusual Volume') ORDER BY actual_trade_price DESC, max_trade_volume DESC LIMIT 20;","output":"SELECT tr.trade_id, tr.trade_date, tr.symbol, tr.quantity, COALESCE(tp.price, 0) AS actual_trade_price, COALESCE(tp.volume, 0) AS max_trade_volume FROM trades AS tr JOIN investor_accounts AS ia ON tr.account_id = ia.account_id LEFT JOIN trade_prices AS tp ON tr.trade_id = tp.trade_id AND tp.price_date = tr.trade_date LEFT JOIN trade_alerts AS ta ON tr.trade_id = ta.trade_id AND ta.alert_type = 'Unusual Volume' WHERE tr.trade_type = 'Buy' AND tr.trade_date BETWEEN '2023-01-01' AND '2023-01-31' AND ia.status = 'Active' AND ta.trade_id IS NULL ORDER BY actual_trade_price DESC, max_trade_volume DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_id, c.campaign_name, c.start_date, (SELECT SUM(cm.conversions) FROM campaign_performance cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_conversions, (SELECT AVG(cm.cpc) FROM campaign_performance cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_cpc FROM campaigns c WHERE c.campaign_type = 'Search' AND c.budget > 5000 AND c.campaign_id NOT IN (SELECT pr.campaign_id FROM policy_violations pr WHERE pr.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM campaign_audiences ca JOIN audiences a ON ca.audience_id = a.audience_id WHERE ca.campaign_id = c.campaign_id AND a.audience_segment = 'High Intent') ORDER BY Q1_conversions DESC, Q1_avg_cpc ASC LIMIT 10;","output":"WITH Q1CampaignPerformance AS (SELECT campaign_id, SUM(conversions) AS Q1_conversions, AVG(cpc) AS Q1_avg_cpc FROM campaign_performance WHERE metric_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY campaign_id) SELECT c.campaign_id, c.campaign_name, c.start_date, COALESCE(qcp.Q1_conversions, 0) AS Q1_conversions, COALESCE(qcp.Q1_avg_cpc, 0) AS Q1_avg_cpc FROM campaigns AS c LEFT JOIN Q1CampaignPerformance AS qcp ON c.campaign_id = qcp.campaign_id LEFT JOIN policy_violations AS pv ON c.campaign_id = pv.campaign_id AND pv.violation_date > '2023-01-01' JOIN campaign_audiences AS ca ON c.campaign_id = ca.campaign_id JOIN audiences AS a ON ca.audience_id = a.audience_id WHERE c.campaign_type = 'Search' AND c.budget > 5000 AND pv.campaign_id IS NULL AND a.audience_segment = 'High Intent' ORDER BY Q1_conversions DESC, Q1_avg_cpc ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pr.product_id, pr.product_name, pr.category_id, (SELECT SUM(s.quantity) FROM sales s WHERE s.product_id = pr.product_id AND s.sale_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_sales_quantity, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = pr.product_id AND r.review_date > '2023-01-01') AS avg_product_rating FROM products pr WHERE pr.price > 200 AND pr.stock_level > 0 AND pr.category_id IN (SELECT cat.category_id FROM categories cat WHERE cat.category_name LIKE '%Gaming%') AND pr.product_id NOT IN (SELECT ir.product_id FROM inventory_reconciliation ir WHERE ir.discrepancy_date > '2023-01-01') ORDER BY H1_sales_quantity DESC, avg_product_rating DESC LIMIT 20;","output":"WITH H1SalesQuantity AS (SELECT product_id, SUM(quantity) AS H1_sales_quantity FROM sales WHERE sale_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY product_id), ProductRatings AS (SELECT product_id, AVG(rating) AS avg_product_rating FROM reviews WHERE review_date > '2023-01-01' GROUP BY product_id) SELECT pr.product_id, pr.product_name, pr.category_id, COALESCE(hsq.H1_sales_quantity, 0) AS H1_sales_quantity, COALESCE(prt.avg_product_rating, 0) AS avg_product_rating FROM products AS pr JOIN categories AS cat ON pr.category_id = cat.category_id LEFT JOIN H1SalesQuantity AS hsq ON pr.product_id = hsq.product_id LEFT JOIN ProductRatings AS prt ON pr.product_id = prt.product_id LEFT JOIN inventory_reconciliation AS ir ON pr.product_id = ir.product_id AND ir.discrepancy_date > '2023-01-01' WHERE pr.price > 200 AND pr.stock_level > 0 AND cat.category_name LIKE '%Gaming%' AND ir.product_id IS NULL ORDER BY H1_sales_quantity DESC, avg_product_rating DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.student_id, s.first_name, s.last_name, (SELECT AVG(g.score) FROM grades g WHERE g.student_id = s.student_id AND g.exam_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_score, (SELECT COUNT(DISTINCT c.course_id) FROM enrollments e JOIN courses c ON e.course_id = c.course_id WHERE e.student_id = s.student_id AND c.department = 'Computer Science') AS cs_course_count FROM students s WHERE s.enrollment_year = 2022 AND s.major = 'Computer Science' AND s.student_id NOT IN (SELECT da.student_id FROM disciplinary_actions da WHERE da.action_date > '2023-01-01' AND da.severity = 'Expulsion') AND EXISTS (SELECT 1 FROM student_achievements sa WHERE sa.student_id = s.student_id AND sa.achievement_type = 'Dean''s List') ORDER BY H1_avg_score DESC, cs_course_count DESC LIMIT 15;","output":"WITH H1AvgScore AS (SELECT student_id, AVG(score) AS H1_avg_score FROM grades WHERE exam_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY student_id), CSCourseCount AS (SELECT e.student_id, COUNT(DISTINCT c.course_id) AS cs_course_count FROM enrollments AS e JOIN courses AS c ON e.course_id = c.course_id WHERE c.department = 'Computer Science' GROUP BY e.student_id) SELECT s.student_id, s.first_name, s.last_name, COALESCE(has.H1_avg_score, 0) AS H1_avg_score, COALESCE(cscc.cs_course_count, 0) AS cs_course_count FROM students AS s LEFT JOIN H1AvgScore AS has ON s.student_id = has.student_id LEFT JOIN CSCourseCount AS cscc ON s.student_id = cscc.student_id LEFT JOIN disciplinary_actions AS da ON s.student_id = da.student_id AND da.action_date > '2023-01-01' AND da.severity = 'Expulsion' JOIN student_achievements AS sa ON s.student_id = sa.student_id WHERE s.enrollment_year = 2022 AND s.major = 'Computer Science' AND da.student_id IS NULL AND sa.achievement_type = 'Dean''s List' ORDER BY H1_avg_score DESC, cs_course_count DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pa.patent_id, pa.title, pa.inventor, pa.filing_date, (SELECT COUNT(l.license_id) FROM licenses l WHERE l.patent_id = pa.patent_id AND l.license_start_date > '2023-01-01') AS new_licenses_2023, (SELECT SUM(r.royalty_amount) FROM royalties r WHERE r.patent_id = pa.patent_id AND r.payment_date > '2023-01-01') AS total_royalties_2023 FROM patents pa WHERE pa.status = 'Granted' AND pa.filing_date BETWEEN '2010-01-01' AND '2020-12-31' AND pa.patent_id NOT IN (SELECT iv.patent_id FROM infringement_violations iv WHERE iv.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM patent_claims pc WHERE pc.patent_id = pa.patent_id AND pc.claim_type = 'Method') ORDER BY new_licenses_2023 DESC, total_royalties_2023 DESC LIMIT 10;","output":"WITH PatentLicenseStats AS (SELECT l.patent_id, COUNT(l.license_id) AS new_licenses_2023 FROM licenses AS l WHERE l.license_start_date > '2023-01-01' GROUP BY l.patent_id), PatentRoyalties AS (SELECT r.patent_id, SUM(r.royalty_amount) AS total_royalties_2023 FROM royalties AS r WHERE r.payment_date > '2023-01-01' GROUP BY r.patent_id) SELECT pa.patent_id, pa.title, pa.inventor, pa.filing_date, COALESCE(pls.new_licenses_2023, 0) AS new_licenses_2023, COALESCE(pr.total_royalties_2023, 0) AS total_royalties_2023 FROM patents AS pa LEFT JOIN PatentLicenseStats AS pls ON pa.patent_id = pls.patent_id LEFT JOIN PatentRoyalties AS pr ON pa.patent_id = pr.patent_id LEFT JOIN infringement_violations AS iv ON pa.patent_id = iv.patent_id AND iv.violation_date > '2023-01-01' JOIN patent_claims AS pc ON pa.patent_id = pc.patent_id WHERE pa.status = 'Granted' AND pa.filing_date BETWEEN '2010-01-01' AND '2020-12-31' AND iv.patent_id IS NULL AND pc.claim_type = 'Method' ORDER BY new_licenses_2023 DESC, total_royalties_2023 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT co.country_code, co.country_name, co.continent, (SELECT AVG(gd.gdp_per_capita) FROM gdp_data gd WHERE gd.country_code = co.country_code AND gd.year BETWEEN 2020 AND 2022) AS avg_gdp_last_3_years, (SELECT SUM(tr.export_value) FROM trade_data tr WHERE tr.country_code = co.country_code AND tr.year = 2023) AS current_year_exports FROM countries co WHERE co.population > 10000000 AND co.gdp_usd > 100000000000 AND co.country_code NOT IN (SELECT sa.country_code FROM sanctions_list sa WHERE sa.start_date < CURDATE() AND sa.end_date > CURDATE()) AND EXISTS (SELECT 1 FROM country_alliances ca JOIN alliances al ON ca.alliance_id = al.alliance_id WHERE ca.country_code = co.country_code AND al.alliance_type = 'Economic') ORDER BY avg_gdp_last_3_years DESC, current_year_exports DESC LIMIT 10;","output":"WITH GDPStats AS (SELECT country_code, AVG(gdp_per_capita) AS avg_gdp_last_3_years FROM gdp_data WHERE year BETWEEN 2020 AND 2022 GROUP BY country_code), TradeStats AS (SELECT country_code, SUM(export_value) AS current_year_exports FROM trade_data WHERE year = 2023 GROUP BY country_code) SELECT co.country_code, co.country_name, co.continent, COALESCE(gs.avg_gdp_last_3_years, 0) AS avg_gdp_last_3_years, COALESCE(ts.current_year_exports, 0) AS current_year_exports FROM countries AS co LEFT JOIN GDPStats AS gs ON co.country_code = gs.country_code LEFT JOIN TradeStats AS ts ON co.country_code = ts.country_code LEFT JOIN sanctions_list AS sl ON co.country_code = sl.country_code AND sl.start_date < CURDATE() AND sl.end_date > CURDATE() JOIN country_alliances AS ca ON co.country_code = ca.country_code JOIN alliances AS al ON ca.alliance_id = al.alliance_id WHERE co.population > 10000000 AND co.gdp_usd > 100000000000 AND sl.country_code IS NULL AND al.alliance_type = 'Economic' ORDER BY avg_gdp_last_3_years DESC, current_year_exports DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.track_id, tr.track_name, tr.artist_id, ar.artist_name, (SELECT COUNT(pl.playlist_id) FROM playlist_tracks pl WHERE pl.track_id = tr.track_id AND pl.added_date > '2023-01-01') AS added_to_playlists_2023, (SELECT AVG(ur.rating) FROM user_track_ratings ur WHERE ur.track_id = tr.track_id AND ur.rating_date > '2023-01-01') AS avg_track_rating FROM tracks tr JOIN artists ar ON tr.artist_id = ar.artist_id WHERE tr.genre = 'Hip Hop' AND tr.release_date BETWEEN '2020-01-01' AND '2022-12-31' AND tr.track_id NOT IN (SELECT cr.track_id FROM copyright_violations cr WHERE cr.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM track_features tf WHERE tf.track_id = tr.track_id AND tf.feature_type = 'Explicit Lyrics') ORDER BY added_to_playlists_2023 DESC, avg_track_rating DESC LIMIT 15;","output":"WITH PlaylistAdds AS (SELECT track_id, COUNT(playlist_id) AS added_to_playlists_2023 FROM playlist_tracks WHERE added_date > '2023-01-01' GROUP BY track_id), TrackRatings AS (SELECT track_id, AVG(rating) AS avg_track_rating FROM user_track_ratings WHERE rating_date > '2023-01-01' GROUP BY track_id) SELECT tr.track_id, tr.track_name, tr.artist_id, ar.artist_name, COALESCE(pa.added_to_playlists_2023, 0) AS added_to_playlists_2023, COALESCE(trr.avg_track_rating, 0) AS avg_track_rating FROM tracks AS tr JOIN artists AS ar ON tr.artist_id = ar.artist_id LEFT JOIN PlaylistAdds AS pa ON tr.track_id = pa.track_id LEFT JOIN TrackRatings AS trr ON tr.track_id = trr.track_id LEFT JOIN copyright_violations AS cv ON tr.track_id = cv.track_id AND cv.violation_date > '2023-01-01' JOIN track_features AS tf ON tr.track_id = tf.track_id WHERE tr.genre = 'Hip Hop' AND tr.release_date BETWEEN '2020-01-01' AND '2022-12-31' AND cv.track_id IS NULL AND tf.feature_type = 'Explicit Lyrics' ORDER BY added_to_playlists_2023 DESC, avg_track_rating DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.stock_id, s.symbol, s.company_name, (SELECT AVG(sh.high_price) FROM stock_history sh WHERE sh.stock_id = s.stock_id AND sh.trade_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_high_price, (SELECT SUM(sh.volume) FROM stock_history sh WHERE sh.stock_id = s.stock_id AND sh.trade_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_total_volume FROM stocks s WHERE s.sector = 'Technology' AND s.market_cap_usd > 10000000000 AND s.stock_id NOT IN (SELECT del.stock_id FROM delisted_stocks del WHERE del.delist_date > '2023-01-01') AND EXISTS (SELECT 1 FROM analyst_ratings ar WHERE ar.stock_id = s.stock_id AND ar.rating = 'Buy') ORDER BY Q1_total_volume DESC, Q1_avg_high_price DESC LIMIT 15;","output":"WITH Q1StockStats AS (SELECT stock_id, AVG(high_price) AS Q1_avg_high_price, SUM(volume) AS Q1_total_volume FROM stock_history WHERE trade_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY stock_id) SELECT s.stock_id, s.symbol, s.company_name, COALESCE(qss.Q1_avg_high_price, 0) AS Q1_avg_high_price, COALESCE(qss.Q1_total_volume, 0) AS Q1_total_volume FROM stocks AS s LEFT JOIN Q1StockStats AS qss ON s.stock_id = qss.stock_id LEFT JOIN delisted_stocks AS ds ON s.stock_id = ds.stock_id AND ds.delist_date > '2023-01-01' JOIN analyst_ratings AS ar ON s.stock_id = ar.stock_id WHERE s.sector = 'Technology' AND s.market_cap_usd > 10000000000 AND ds.stock_id IS NULL AND ar.rating = 'Buy' ORDER BY Q1_total_volume DESC, Q1_avg_high_price DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT ve.voter_id, ve.first_name, ve.last_name, (SELECT MAX(vp.vote_date) FROM voter_participations vp WHERE vp.voter_id = ve.voter_id) AS last_vote_date, (SELECT COUNT(vp.vote_id) FROM voter_participations vp WHERE vp.voter_id = ve.voter_id AND vp.election_year = 2022) AS votes_2022 FROM voters ve WHERE ve.registration_date > '2020-01-01' AND ve.party_affiliation = 'Independent' AND ve.voter_id NOT IN (SELECT vr.voter_id FROM voter_registrations_removed vr WHERE vr.removal_date > '2023-01-01') AND EXISTS (SELECT 1 FROM voter_donations vd WHERE vd.voter_id = ve.voter_id AND vd.donation_amount > 500) ORDER BY last_vote_date DESC, votes_2022 DESC LIMIT 10;","output":"WITH VoterParticipationStats AS (SELECT voter_id, MAX(vote_date) AS last_vote_date, COUNT(CASE WHEN election_year = 2022 THEN vote_id END) AS votes_2022 FROM voter_participations GROUP BY voter_id) SELECT ve.voter_id, ve.first_name, ve.last_name, vps.last_vote_date, COALESCE(vps.votes_2022, 0) AS votes_2022 FROM voters AS ve LEFT JOIN VoterParticipationStats AS vps ON ve.voter_id = vps.voter_id LEFT JOIN voter_registrations_removed AS vrr ON ve.voter_id = vrr.voter_id AND vrr.removal_date > '2023-01-01' JOIN voter_donations AS vd ON ve.voter_id = vd.voter_id WHERE ve.registration_date > '2020-01-01' AND ve.party_affiliation = 'Independent' AND vrr.voter_id IS NULL AND vd.donation_amount > 500 ORDER BY last_vote_date DESC, votes_2022 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_id, c.campaign_name, c.start_date, (SELECT SUM(ad.spend) FROM ad_data ad WHERE ad.campaign_id = c.campaign_id AND ad.date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_ad_spend, (SELECT AVG(ad.cpm) FROM ad_data ad WHERE ad.campaign_id = c.campaign_id AND ad.date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_cpm FROM campaigns c WHERE c.status = 'Running' AND c.target_audience = 'Youth' AND c.campaign_id NOT IN (SELECT iv.campaign_id FROM invalid_traffic_reports iv WHERE iv.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM campaign_platforms cp JOIN platforms p ON cp.platform_id = p.platform_id WHERE cp.campaign_id = c.campaign_id AND p.platform_name = 'TikTok') ORDER BY Q1_ad_spend DESC, Q1_avg_cpm DESC LIMIT 10;","output":"WITH Q1AdMetrics AS (SELECT campaign_id, SUM(spend) AS Q1_ad_spend, AVG(cpm) AS Q1_avg_cpm FROM ad_data WHERE date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY campaign_id) SELECT c.campaign_id, c.campaign_name, c.start_date, COALESCE(qam.Q1_ad_spend, 0) AS Q1_ad_spend, COALESCE(qam.Q1_avg_cpm, 0) AS Q1_avg_cpm FROM campaigns AS c LEFT JOIN Q1AdMetrics AS qam ON c.campaign_id = qam.campaign_id LEFT JOIN invalid_traffic_reports AS itr ON c.campaign_id = itr.campaign_id AND itr.report_date > '2023-01-01' JOIN campaign_platforms AS cp ON c.campaign_id = cp.campaign_id JOIN platforms AS p ON cp.platform_id = p.platform_id WHERE c.status = 'Running' AND c.target_audience = 'Youth' AND itr.campaign_id IS NULL AND p.platform_name = 'TikTok' ORDER BY Q1_ad_spend DESC, Q1_avg_cpm DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT u.user_id, u.username, u.last_login_date, (SELECT COUNT(f.follow_id) FROM followers f WHERE f.following_id = u.user_id AND f.follow_date > '2023-01-01') AS new_followers_2023, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id AND p.created_at > '2023-01-01' AND p.likes > 100) AS high_engagement_posts FROM users u WHERE u.account_status = 'Active' AND u.registration_date BETWEEN '2021-01-01' AND '2022-12-31' AND u.user_id NOT IN (SELECT pr.user_id FROM privacy_violations pr WHERE pr.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM user_settings us WHERE us.user_id = u.user_id AND us.setting_name = 'Public Profile' AND us.setting_value = 'True') ORDER BY new_followers_2023 DESC, high_engagement_posts DESC LIMIT 15;","output":"WITH UserFollowerStats AS (SELECT following_id AS user_id, COUNT(follow_id) AS new_followers_2023 FROM followers WHERE follow_date > '2023-01-01' GROUP BY following_id), UserPostEngagement AS (SELECT user_id, COUNT(post_id) AS high_engagement_posts FROM posts WHERE created_at > '2023-01-01' AND likes > 100 GROUP BY user_id) SELECT u.user_id, u.username, u.last_login_date, COALESCE(ufs.new_followers_2023, 0) AS new_followers_2023, COALESCE(upe.high_engagement_posts, 0) AS high_engagement_posts FROM users AS u LEFT JOIN UserFollowerStats AS ufs ON u.user_id = ufs.user_id LEFT JOIN UserPostEngagement AS upe ON u.user_id = upe.user_id LEFT JOIN privacy_violations AS pv ON u.user_id = pv.user_id AND pv.violation_date > '2023-01-01' JOIN user_settings AS us ON u.user_id = us.user_id WHERE u.account_status = 'Active' AND u.registration_date BETWEEN '2021-01-01' AND '2022-12-31' AND pv.user_id IS NULL AND us.setting_name = 'Public Profile' AND us.setting_value = 'True' ORDER BY new_followers_2023 DESC, high_engagement_posts DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.transaction_id, tr.transaction_type, tr.amount, tr.transaction_date, (SELECT ba.balance_after_transaction FROM bank_accounts ba WHERE ba.account_id = tr.account_id AND ba.transaction_id = tr.transaction_id) AS post_transaction_balance, (SELECT COUNT(al.alert_id) FROM security_alerts al WHERE al.transaction_id = tr.transaction_id AND al.alert_type = 'Fraudulent Activity') AS fraud_alerts_count FROM transactions tr WHERE tr.account_id IN (SELECT DISTINCT ca.account_id FROM customer_accounts ca WHERE ca.customer_id IN (SELECT customer_id FROM customers WHERE country = 'USA')) AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-03-31' AND tr.status = 'Completed' AND tr.transaction_id NOT IN (SELECT rv.transaction_id FROM reversed_transactions rv WHERE rv.reversal_date > '2023-01-01') ORDER BY fraud_alerts_count DESC, post_transaction_balance DESC LIMIT 20;","output":"WITH TransactionBalance AS (SELECT account_id, transaction_id, balance_after_transaction FROM bank_accounts), FraudAlerts AS (SELECT transaction_id, COUNT(alert_id) AS fraud_alerts_count FROM security_alerts WHERE alert_type = 'Fraudulent Activity' GROUP BY transaction_id) SELECT tr.transaction_id, tr.transaction_type, tr.amount, tr.transaction_date, tbal.balance_after_transaction AS post_transaction_balance, COALESCE(fa.fraud_alerts_count, 0) AS fraud_alerts_count FROM transactions AS tr JOIN customer_accounts AS ca ON tr.account_id = ca.account_id JOIN customers AS cust ON ca.customer_id = cust.customer_id LEFT JOIN TransactionBalance AS tbal ON tr.account_id = tbal.account_id AND tr.transaction_id = tbal.transaction_id LEFT JOIN FraudAlerts AS fa ON tr.transaction_id = fa.transaction_id LEFT JOIN reversed_transactions AS rt ON tr.transaction_id = rt.transaction_id AND rt.reversal_date > '2023-01-01' WHERE cust.country = 'USA' AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-03-31' AND tr.status = 'Completed' AND rt.transaction_id IS NULL ORDER BY fraud_alerts_count DESC, post_transaction_balance DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.server_id, s.hostname, s.ip_address, (SELECT AVG(cpu.usage_percent) FROM cpu_metrics cpu WHERE cpu.server_id = s.server_id AND cpu.metric_date BETWEEN '2023-01-01' AND '2023-01-31') AS avg_jan_cpu, (SELECT SUM(mem.memory_used_gb) FROM memory_metrics mem WHERE mem.server_id = s.server_id AND mem.metric_date BETWEEN '2023-01-01' AND '2023-01-31') AS total_jan_memory_used FROM servers s WHERE s.status = 'Operational' AND s.environment = 'Production' AND s.server_id NOT IN (SELECT ofl.server_id FROM outage_failures ofl WHERE ofl.outage_date > '2023-01-01') AND EXISTS (SELECT 1 FROM server_roles sr JOIN roles r ON sr.role_id = r.role_id WHERE sr.server_id = s.server_id AND r.role_name = 'Web Server') ORDER BY avg_jan_cpu DESC, total_jan_memory_used DESC LIMIT 10;","output":"WITH JanCPUMetrics AS (SELECT server_id, AVG(usage_percent) AS avg_jan_cpu FROM cpu_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY server_id), JanMemoryMetrics AS (SELECT server_id, SUM(memory_used_gb) AS total_jan_memory_used FROM memory_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY server_id) SELECT s.server_id, s.hostname, s.ip_address, COALESCE(jcm.avg_jan_cpu, 0) AS avg_jan_cpu, COALESCE(jmm.total_jan_memory_used, 0) AS total_jan_memory_used FROM servers AS s LEFT JOIN JanCPUMetrics AS jcm ON s.server_id = jcm.server_id LEFT JOIN JanMemoryMetrics AS jmm ON s.server_id = jmm.server_id LEFT JOIN outage_failures AS ofl ON s.server_id = ofl.server_id AND ofl.outage_date > '2023-01-01' JOIN server_roles AS sr ON s.server_id = sr.server_id JOIN roles AS r ON sr.role_id = r.role_id WHERE s.status = 'Operational' AND s.environment = 'Production' AND ofl.server_id IS NULL AND r.role_name = 'Web Server' ORDER BY avg_jan_cpu DESC, total_jan_memory_used DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT p.patient_id, p.first_name, p.last_name, (SELECT COUNT(v.visit_id) FROM visits v WHERE v.patient_id = p.patient_id AND v.visit_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_visits, (SELECT MAX(v.diagnosis_code) FROM visits v WHERE v.patient_id = p.patient_id) AS last_diagnosis FROM patients p WHERE p.gender = 'Male' AND p.age BETWEEN 50 AND 70 AND p.patient_id NOT IN (SELECT pr.patient_id FROM prescription_refills pr WHERE pr.refill_date > '2023-01-01' AND pr.medication_id IN (SELECT drug_id FROM drugs WHERE is_controlled = TRUE)) AND EXISTS (SELECT 1 FROM patient_conditions pc JOIN conditions c ON pc.condition_id = c.condition_id WHERE pc.patient_id = p.patient_id AND c.condition_name = 'Diabetes') ORDER BY H1_visits DESC, last_diagnosis ASC LIMIT 10;","output":"WITH PatientVisitStats AS (SELECT patient_id, COUNT(visit_id) AS H1_visits, MAX(diagnosis_code) AS last_diagnosis FROM visits WHERE visit_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY patient_id) SELECT p.patient_id, p.first_name, p.last_name, COALESCE(pvs.H1_visits, 0) AS H1_visits, pvs.last_diagnosis FROM patients AS p LEFT JOIN PatientVisitStats AS pvs ON p.patient_id = pvs.patient_id LEFT JOIN prescription_refills AS pr ON p.patient_id = pr.patient_id AND pr.refill_date > '2023-01-01' LEFT JOIN drugs AS d ON pr.medication_id = d.drug_id AND d.is_controlled = TRUE JOIN patient_conditions AS pc ON p.patient_id = pc.patient_id JOIN conditions AS c ON pc.condition_id = c.condition_id WHERE p.gender = 'Male' AND p.age BETWEEN 50 AND 70 AND pr.patient_id IS NULL AND c.condition_name = 'Diabetes' ORDER BY H1_visits DESC, last_diagnosis ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.class_id, c.class_name, c.instructor_name, (SELECT COUNT(e.enrollment_id) FROM enrollments e WHERE e.class_id = c.class_id AND e.enrollment_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_enrollments, (SELECT AVG(g.grade_value) FROM grades g WHERE g.class_id = c.class_id AND g.grade_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_grade FROM classes c WHERE c.semester = 'Spring 2023' AND c.department = 'Arts' AND c.class_id NOT IN (SELECT wc.class_id FROM waitlist_classes wc WHERE wc.waitlist_count > 10) AND EXISTS (SELECT 1 FROM class_materials cm WHERE cm.class_id = c.class_id AND cm.material_type = 'Textbook') ORDER BY H1_enrollments DESC, H1_avg_grade DESC LIMIT 10;","output":"WITH H1Enrollments AS (SELECT class_id, COUNT(enrollment_id) AS H1_enrollments FROM enrollments WHERE enrollment_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY class_id), H1AvgGrade AS (SELECT class_id, AVG(grade_value) AS H1_avg_grade FROM grades WHERE grade_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY class_id) SELECT c.class_id, c.class_name, c.instructor_name, COALESCE(he.H1_enrollments, 0) AS H1_enrollments, COALESCE(hag.H1_avg_grade, 0) AS H1_avg_grade FROM classes AS c LEFT JOIN H1Enrollments AS he ON c.class_id = he.class_id LEFT JOIN H1AvgGrade AS hag ON c.class_id = hag.class_id LEFT JOIN waitlist_classes AS wc ON c.class_id = wc.class_id AND wc.waitlist_count > 10 JOIN class_materials AS cm ON c.class_id = cm.class_id WHERE c.semester = 'Spring 2023' AND c.department = 'Arts' AND wc.class_id IS NULL AND cm.material_type = 'Textbook' ORDER BY H1_enrollments DESC, H1_avg_grade DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pub.publisher_id, pub.publisher_name, pub.country, (SELECT COUNT(b.book_id) FROM books b WHERE b.publisher_id = pub.publisher_id AND b.publication_year = 2023) AS new_books_2023, (SELECT SUM(s.royalty_amount) FROM sales_royalty s WHERE s.publisher_id = pub.publisher_id AND s.sale_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_royalties_2023 FROM publishers pub WHERE pub.founding_year < 1980 AND pub.publisher_id NOT IN (SELECT cr.publisher_id FROM copyright_infringements cr WHERE cr.infringement_date > '2023-01-01') AND EXISTS (SELECT 1 FROM publisher_genres pg JOIN genres g ON pg.genre_id = g.genre_id WHERE pg.publisher_id = pub.publisher_id AND g.genre_name = 'Fantasy') ORDER BY new_books_2023 DESC, annual_royalties_2023 DESC LIMIT 10;","output":"WITH PublisherBookStats AS (SELECT publisher_id, COUNT(book_id) AS new_books_2023 FROM books WHERE publication_year = 2023 GROUP BY publisher_id), PublisherRoyalties AS (SELECT publisher_id, SUM(royalty_amount) AS annual_royalties_2023 FROM sales_royalty WHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY publisher_id) SELECT pub.publisher_id, pub.publisher_name, pub.country, COALESCE(pbs.new_books_2023, 0) AS new_books_2023, COALESCE(pr.annual_royalties_2023, 0) AS annual_royalties_2023 FROM publishers AS pub LEFT JOIN PublisherBookStats AS pbs ON pub.publisher_id = pbs.publisher_id LEFT JOIN PublisherRoyalties AS pr ON pub.publisher_id = pr.publisher_id LEFT JOIN copyright_infringements AS ci ON pub.publisher_id = ci.publisher_id AND ci.infringement_date > '2023-01-01' JOIN publisher_genres AS pg ON pub.publisher_id = pg.publisher_id JOIN genres AS g ON pg.genre_id = g.genre_id WHERE pub.founding_year < 1980 AND ci.publisher_id IS NULL AND g.genre_name = 'Fantasy' ORDER BY new_books_2023 DESC, annual_royalties_2023 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT co.customer_id, co.customer_name, co.city, (SELECT COUNT(o.order_id) FROM orders o WHERE o.customer_id = co.customer_id AND o.order_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_orders, (SELECT SUM(o.total_amount) FROM orders o WHERE o.customer_id = co.customer_id AND o.order_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_total_spend FROM customers co WHERE co.registration_date > '2022-01-01' AND co.customer_type = 'Business' AND co.customer_id NOT IN (SELECT cb.customer_id FROM customer_blacklists cb WHERE cb.blacklist_date > '2023-01-01') AND EXISTS (SELECT 1 FROM customer_contracts cc WHERE cc.customer_id = co.customer_id AND cc.contract_status = 'Active') ORDER BY Q1_total_spend DESC, Q1_orders DESC LIMIT 15;","output":"WITH Q1CustomerStats AS (SELECT customer_id, COUNT(order_id) AS Q1_orders, SUM(total_amount) AS Q1_total_spend FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY customer_id) SELECT co.customer_id, co.customer_name, co.city, COALESCE(qcs.Q1_orders, 0) AS Q1_orders, COALESCE(qcs.Q1_total_spend, 0) AS Q1_total_spend FROM customers AS co LEFT JOIN Q1CustomerStats AS qcs ON co.customer_id = qcs.customer_id LEFT JOIN customer_blacklists AS cb ON co.customer_id = cb.customer_id AND cb.blacklist_date > '2023-01-01' JOIN customer_contracts AS cc ON co.customer_id = cc.customer_id WHERE co.registration_date > '2022-01-01' AND co.customer_type = 'Business' AND cb.customer_id IS NULL AND cc.contract_status = 'Active' ORDER BY Q1_total_spend DESC, Q1_orders DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT ev.event_id, ev.event_name, ev.event_date, (SELECT COUNT(reg.registration_id) FROM event_registrations reg WHERE reg.event_id = ev.event_id AND reg.registration_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_registrations, (SELECT AVG(fb.satisfaction_score) FROM event_feedback fb WHERE fb.event_id = ev.event_id AND fb.feedback_date > '2023-01-01') AS avg_feedback_score FROM events ev WHERE ev.event_type = 'Webinar' AND ev.status = 'Completed' AND ev.event_date BETWEEN '2023-01-01' AND '2023-12-31' AND ev.event_id NOT IN (SELECT tech.event_id FROM technical_issues tech WHERE tech.issue_date > '2023-01-01') AND EXISTS (SELECT 1 FROM event_speakers es JOIN speakers s ON es.speaker_id = s.speaker_id WHERE es.event_id = ev.event_id AND s.specialization = 'Data Science') ORDER BY H1_registrations DESC, avg_feedback_score DESC LIMIT 10;","output":"WITH H1Registrations AS (SELECT event_id, COUNT(registration_id) AS H1_registrations FROM event_registrations WHERE registration_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY event_id), EventFeedback AS (SELECT event_id, AVG(satisfaction_score) AS avg_feedback_score FROM event_feedback WHERE feedback_date > '2023-01-01' GROUP BY event_id) SELECT ev.event_id, ev.event_name, ev.event_date, COALESCE(hr.H1_registrations, 0) AS H1_registrations, COALESCE(ef.avg_feedback_score, 0) AS avg_feedback_score FROM events AS ev LEFT JOIN H1Registrations AS hr ON ev.event_id = hr.event_id LEFT JOIN EventFeedback AS ef ON ev.event_id = ef.event_id LEFT JOIN technical_issues AS ti ON ev.event_id = ti.event_id AND ti.issue_date > '2023-01-01' JOIN event_speakers AS es ON ev.event_id = es.event_id JOIN speakers AS s ON es.speaker_id = s.speaker_id WHERE ev.event_type = 'Webinar' AND ev.status = 'Completed' AND ev.event_date BETWEEN '2023-01-01' AND '2023-12-31' AND ti.event_id IS NULL AND s.specialization = 'Data Science' ORDER BY H1_registrations DESC, avg_feedback_score DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT rep.report_id, rep.report_name, rep.report_type, rep.generation_date, (SELECT COUNT(dist.distribution_id) FROM report_distributions dist WHERE dist.report_id = rep.report_id AND dist.distribution_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_distributions, (SELECT AVG(usg.usage_count) FROM report_usage usg WHERE usg.report_id = rep.report_id AND usg.usage_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_usage FROM reports rep WHERE rep.status = 'Published' AND rep.visibility = 'Public' AND rep.generation_date > '2022-01-01' AND rep.report_id NOT IN (SELECT err.report_id FROM report_errors err WHERE err.error_date > '2023-01-01') AND EXISTS (SELECT 1 FROM report_categories rc JOIN categories cat ON rc.category_id = cat.category_id WHERE rc.report_id = rep.report_id AND cat.category_name = 'Financial') ORDER BY H1_distributions DESC, H1_avg_usage DESC LIMIT 10;","output":"WITH H1Distributions AS (SELECT report_id, COUNT(distribution_id) AS H1_distributions FROM report_distributions WHERE distribution_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY report_id), H1Usage AS (SELECT report_id, AVG(usage_count) AS H1_avg_usage FROM report_usage WHERE usage_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY report_id) SELECT rep.report_id, rep.report_name, rep.report_type, rep.generation_date, COALESCE(hd.H1_distributions, 0) AS H1_distributions, COALESCE(hu.H1_avg_usage, 0) AS H1_avg_usage FROM reports AS rep LEFT JOIN H1Distributions AS hd ON rep.report_id = hd.report_id LEFT JOIN H1Usage AS hu ON rep.report_id = hu.report_id LEFT JOIN report_errors AS re ON rep.report_id = re.report_id AND re.error_date > '2023-01-01' JOIN report_categories AS rc ON rep.report_id = rc.report_id JOIN categories AS cat ON rc.category_id = cat.category_id WHERE rep.status = 'Published' AND rep.visibility = 'Public' AND rep.generation_date > '2022-01-01' AND re.report_id IS NULL AND cat.category_name = 'Financial' ORDER BY H1_distributions DESC, H1_avg_usage DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT em.employee_id, em.first_name, em.last_name, em.department_id, (SELECT COUNT(t.training_id) FROM employee_trainings t WHERE t.employee_id = em.employee_id AND t.completion_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_trainings_completed, (SELECT AVG(pf.score) FROM performance_feedback pf WHERE pf.employee_id = em.employee_id AND pf.feedback_date BETWEEN '2023-01-01' AND '2023-12-31') AS avg_performance_score FROM employees em WHERE em.status = 'Active' AND em.hire_date < '2020-01-01' AND em.employee_id NOT IN (SELECT cp.employee_id FROM disciplinary_cases cp WHERE cp.case_date > '2023-01-01' AND cp.severity = 'Termination') AND EXISTS (SELECT 1 FROM employee_skills es JOIN skills s ON es.skill_id = s.skill_id WHERE es.employee_id = em.employee_id AND s.skill_name = 'Project Management') ORDER BY annual_trainings_completed DESC, avg_performance_score DESC LIMIT 15;","output":"WITH AnnualTrainings AS (SELECT employee_id, COUNT(training_id) AS annual_trainings_completed FROM employee_trainings WHERE completion_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY employee_id), PerformanceScores AS (SELECT employee_id, AVG(score) AS avg_performance_score FROM performance_feedback WHERE feedback_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY employee_id) SELECT em.employee_id, em.first_name, em.last_name, em.department_id, COALESCE(at.annual_trainings_completed, 0) AS annual_trainings_completed, COALESCE(ps.avg_performance_score, 0) AS avg_performance_score FROM employees AS em LEFT JOIN AnnualTrainings AS at ON em.employee_id = at.employee_id LEFT JOIN PerformanceScores AS ps ON em.employee_id = ps.employee_id LEFT JOIN disciplinary_cases AS dc ON em.employee_id = dc.employee_id AND dc.case_date > '2023-01-01' AND dc.severity = 'Termination' JOIN employee_skills AS es ON em.employee_id = es.employee_id JOIN skills AS s ON es.skill_id = s.skill_id WHERE em.status = 'Active' AND em.hire_date < '2020-01-01' AND dc.employee_id IS NULL AND s.skill_name = 'Project Management' ORDER BY annual_trainings_completed DESC, avg_performance_score DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pub.publication_id, pub.title, pub.publisher, (SELECT COUNT(cit.citation_id) FROM citations cit WHERE cit.publication_id = pub.publication_id AND cit.citation_year = 2023) AS citations_2023, (SELECT AVG(met.impact_factor) FROM journal_metrics met WHERE met.publication_id = pub.publication_id AND met.metric_year = 2023) AS avg_impact_factor FROM publications pub WHERE pub.publication_type = 'Journal Article' AND pub.publication_year BETWEEN 2010 AND 2022 AND pub.publication_id NOT IN (SELECT pr.publication_id FROM retraction_notices pr WHERE pr.retraction_date > '2023-01-01') AND EXISTS (SELECT 1 FROM publication_authors pa JOIN authors au ON pa.author_id = au.author_id WHERE pa.publication_id = pub.publication_id AND au.academic_rank = 'Professor') ORDER BY citations_2023 DESC, avg_impact_factor DESC LIMIT 10;","output":"WITH PublicationCitationStats AS (SELECT publication_id, COUNT(citation_id) AS citations_2023 FROM citations WHERE citation_year = 2023 GROUP BY publication_id), ImpactFactors AS (SELECT publication_id, AVG(impact_factor) AS avg_impact_factor FROM journal_metrics WHERE metric_year = 2023 GROUP BY publication_id) SELECT pub.publication_id, pub.title, pub.publisher, COALESCE(pcs.citations_2023, 0) AS citations_2023, COALESCE(imf.avg_impact_factor, 0) AS avg_impact_factor FROM publications AS pub LEFT JOIN PublicationCitationStats AS pcs ON pub.publication_id = pcs.publication_id LEFT JOIN ImpactFactors AS imf ON pub.publication_id = imf.publication_id LEFT JOIN retraction_notices AS rn ON pub.publication_id = rn.publication_id AND rn.retraction_date > '2023-01-01' JOIN publication_authors AS pa ON pub.publication_id = pa.publication_id JOIN authors AS au ON pa.author_id = au.author_id WHERE pub.publication_type = 'Journal Article' AND pub.publication_year BETWEEN 2010 AND 2022 AND rn.publication_id IS NULL AND au.academic_rank = 'Professor' ORDER BY citations_2023 DESC, avg_impact_factor DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pat.patient_id, pat.first_name, pat.last_name, pat.date_of_birth, (SELECT COUNT(diag.diagnosis_id) FROM diagnoses diag WHERE diag.patient_id = pat.patient_id AND diag.diagnosis_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_diagnoses_count, (SELECT MAX(med.prescription_date) FROM prescriptions med WHERE med.patient_id = pat.patient_id) AS last_prescription_date FROM patients pat WHERE pat.gender = 'Female' AND pat.age BETWEEN 30 AND 50 AND pat.patient_id NOT IN (SELECT adm.patient_id FROM admissions adm WHERE adm.admission_date > '2023-01-01' AND adm.reason = 'Emergency') AND EXISTS (SELECT 1 FROM patient_allergies pa WHERE pa.patient_id = pat.patient_id AND pa.allergy_type = 'Drug') ORDER BY H1_diagnoses_count DESC, last_prescription_date DESC LIMIT 10;","output":"WITH H1Diagnoses AS (SELECT patient_id, COUNT(diagnosis_id) AS H1_diagnoses_count FROM diagnoses WHERE diagnosis_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY patient_id), LastPrescription AS (SELECT patient_id, MAX(prescription_date) AS last_prescription_date FROM prescriptions GROUP BY patient_id) SELECT pat.patient_id, pat.first_name, pat.last_name, pat.date_of_birth, COALESCE(hd.H1_diagnoses_count, 0) AS H1_diagnoses_count, lpr.last_prescription_date FROM patients AS pat LEFT JOIN H1Diagnoses AS hd ON pat.patient_id = hd.patient_id LEFT JOIN LastPrescription AS lpr ON pat.patient_id = lpr.patient_id LEFT JOIN admissions AS adm ON pat.patient_id = adm.patient_id AND adm.admission_date > '2023-01-01' AND adm.reason = 'Emergency' JOIN patient_allergies AS pa ON pat.patient_id = pa.patient_id WHERE pat.gender = 'Female' AND pat.age BETWEEN 30 AND 50 AND adm.patient_id IS NULL AND pa.allergy_type = 'Drug' ORDER BY H1_diagnoses_count DESC, last_prescription_date DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT res.resource_id, res.resource_name, res.resource_type, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.resource_id = res.resource_id AND b.booking_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_bookings, (SELECT SUM(b.duration_hours) FROM bookings b WHERE b.resource_id = res.resource_id AND b.booking_date BETWEEN '2023-01-01' AND '2023-12-31') AS total_booking_hours FROM resources res WHERE res.status = 'Available' AND res.location = 'Main Campus' AND res.resource_id NOT IN (SELECT br.resource_id FROM breakage_reports br WHERE br.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM resource_tags rt JOIN tags t ON rt.tag_id = t.tag_id WHERE rt.resource_id = res.resource_id AND t.tag_name = 'High Demand') ORDER BY annual_bookings DESC, total_booking_hours DESC LIMIT 15;","output":"WITH ResourceBookingStats AS (SELECT resource_id, COUNT(booking_id) AS annual_bookings, SUM(duration_hours) AS total_booking_hours FROM bookings WHERE booking_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY resource_id) SELECT res.resource_id, res.resource_name, res.resource_type, COALESCE(rbs.annual_bookings, 0) AS annual_bookings, COALESCE(rbs.total_booking_hours, 0) AS total_booking_hours FROM resources AS res LEFT JOIN ResourceBookingStats AS rbs ON res.resource_id = rbs.resource_id LEFT JOIN breakage_reports AS br ON res.resource_id = br.resource_id AND br.report_date > '2023-01-01' JOIN resource_tags AS rt ON res.resource_id = rt.resource_id JOIN tags AS t ON rt.tag_id = t.tag_id WHERE res.status = 'Available' AND res.location = 'Main Campus' AND br.resource_id IS NULL AND t.tag_name = 'High Demand' ORDER BY annual_bookings DESC, total_booking_hours DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.track_id, tr.track_name, tr.artist_name, tr.album_name, (SELECT COUNT(us.stream_id) FROM user_streams us WHERE us.track_id = tr.track_id AND us.stream_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_streams, (SELECT AVG(ur.rating_score) FROM user_ratings ur WHERE ur.track_id = tr.track_id AND ur.rating_date > '2023-01-01') AS avg_user_rating FROM tracks tr WHERE tr.genre = 'Pop' AND tr.release_year = 2023 AND tr.track_id NOT IN (SELECT pv.track_id FROM piracy_violations pv WHERE pv.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM track_playlists tp JOIN playlists p ON tp.playlist_id = p.playlist_id WHERE tp.track_id = tr.track_id AND p.playlist_type = 'Editorial') ORDER BY H1_streams DESC, avg_user_rating DESC LIMIT 15;","output":"WITH H1Streams AS (SELECT track_id, COUNT(stream_id) AS H1_streams FROM user_streams WHERE stream_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY track_id), AvgUserRating AS (SELECT track_id, AVG(rating_score) AS avg_user_rating FROM user_ratings WHERE rating_date > '2023-01-01' GROUP BY track_id) SELECT tr.track_id, tr.track_name, tr.artist_name, tr.album_name, COALESCE(hs.H1_streams, 0) AS H1_streams, COALESCE(aur.avg_user_rating, 0) AS avg_user_rating FROM tracks AS tr LEFT JOIN H1Streams AS hs ON tr.track_id = hs.track_id LEFT JOIN AvgUserRating AS aur ON tr.track_id = aur.track_id LEFT JOIN piracy_violations AS pv ON tr.track_id = pv.track_id AND pv.violation_date > '2023-01-01' JOIN track_playlists AS tp ON tr.track_id = tp.track_id JOIN playlists AS p ON tp.playlist_id = p.playlist_id WHERE tr.genre = 'Pop' AND tr.release_year = 2023 AND pv.track_id IS NULL AND p.playlist_type = 'Editorial' ORDER BY H1_streams DESC, avg_user_rating DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT dev.developer_id, dev.developer_name, dev.specialty, (SELECT COUNT(app.app_id) FROM applications app WHERE app.developer_id = dev.developer_id AND app.release_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_app_releases, (SELECT AVG(ur.average_rating) FROM app_user_ratings ur JOIN applications app ON ur.app_id = app.app_id WHERE app.developer_id = dev.developer_id) AS avg_app_rating FROM developers dev WHERE dev.country = 'Japan' AND dev.years_experience > 5 AND dev.developer_id NOT IN (SELECT pr.developer_id FROM code_review_penalties pr WHERE pr.penalty_date > '2023-01-01') AND EXISTS (SELECT 1 FROM developer_platforms dp JOIN platforms p ON dp.platform_id = p.platform_id WHERE dp.developer_id = dev.developer_id AND p.platform_name = 'iOS') ORDER BY annual_app_releases DESC, avg_app_rating DESC LIMIT 10;","output":"WITH AnnualAppReleases AS (SELECT developer_id, COUNT(app_id) AS annual_app_releases FROM applications WHERE release_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY developer_id), AvgAppRating AS (SELECT app.developer_id, AVG(ur.average_rating) AS avg_app_rating FROM app_user_ratings AS ur JOIN applications AS app ON ur.app_id = app.app_id GROUP BY app.developer_id) SELECT dev.developer_id, dev.developer_name, dev.specialty, COALESCE(aar.annual_app_releases, 0) AS annual_app_releases, COALESCE(aar_avg.avg_app_rating, 0) AS avg_app_rating FROM developers AS dev LEFT JOIN AnnualAppReleases AS aar ON dev.developer_id = aar.developer_id LEFT JOIN AvgAppRating AS aar_avg ON dev.developer_id = aar_avg.developer_id LEFT JOIN code_review_penalties AS crp ON dev.developer_id = crp.developer_id AND crp.penalty_date > '2023-01-01' JOIN developer_platforms AS dp ON dev.developer_id = dp.developer_id JOIN platforms AS p ON dp.platform_id = p.platform_id WHERE dev.country = 'Japan' AND dev.years_experience > 5 AND crp.developer_id IS NULL AND p.platform_name = 'iOS' ORDER BY annual_app_releases DESC, avg_app_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"WITH RECURSIVE category_tree AS (SELECT category_id, category_name, parent_category_id, 1 as level FROM categories WHERE parent_category_id IS NULL UNION ALL SELECT c.category_id, c.category_name, c.parent_category_id, ct.level + 1 FROM categories c INNER JOIN category_tree ct ON c.parent_category_id = ct.category_id) SELECT ct.category_id, ct.category_name, ct.level, p.product_count, COALESCE(SUM(s.sales_amount), 0) as total_sales FROM category_tree ct LEFT JOIN (SELECT category_id, COUNT(*) as product_count FROM products WHERE discontinued = FALSE GROUP BY category_id) p ON ct.category_id = p.category_id LEFT JOIN (SELECT p.category_id, SUM(sd.quantity * sd.unit_price) as sales_amount FROM sales_details sd JOIN products p ON sd.product_id = p.product_id JOIN sales s ON sd.sale_id = s.sale_id WHERE s.sale_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY p.category_id) s ON ct.category_id = s.category_id WHERE ct.level <= 4 AND p.product_count > 0 ORDER BY ct.level, total_sales DESC","output":"WITH RECURSIVE category_tree AS (SELECT category_id, category_name, parent_category_id, 1 as level FROM categories WHERE parent_category_id IS NULL UNION ALL SELECT c.category_id, c.category_name, c.parent_category_id, ct.level + 1 FROM categories c INNER JOIN category_tree ct ON c.parent_category_id = ct.category_id) SELECT ct.category_id, ct.category_name, ct.level, p.product_count, COALESCE(SUM(s.sales_amount), 0) as total_sales FROM category_tree ct LEFT JOIN (SELECT category_id, COUNT(*) as product_count FROM products WHERE discontinued = false GROUP BY category_id) p ON ct.category_id = p.category_id LEFT JOIN (SELECT p.category_id, SUM(sd.quantity * sd.unit_price) as sales_amount FROM sales_details sd JOIN products p ON sd.product_id = p.product_id JOIN sales s ON sd.sale_id = s.sale_id WHERE s.sale_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY p.category_id) s ON ct.category_id = s.category_id WHERE ct.level <= 4 AND p.product_count > 0 ORDER BY ct.level, total_sales DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, customer_name, email, registration_date, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.customer_id AND o.order_date >= CURRENT_DATE - INTERVAL '365 days') as orders_last_year, (SELECT SUM(total_amount) FROM orders o WHERE o.customer_id = c.customer_id AND o.status = 'completed') as lifetime_value, (SELECT MAX(order_date) FROM orders o WHERE o.customer_id = c.customer_id) as last_order_date, EXISTS(SELECT 1 FROM subscriptions s WHERE s.customer_id = c.customer_id AND s.status = 'active') as has_active_subscription, (SELECT STRING_AGG(DISTINCT category_name, ', ') FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id JOIN categories cat ON p.category_id = cat.category_id WHERE o.customer_id = c.customer_id) as purchased_categories FROM customers c WHERE registration_date > '2020-01-01' AND customer_id IN (SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(*) > 3 AND SUM(total_amount) > 500) ORDER BY lifetime_value DESC NULLS LAST LIMIT 100","output":"SELECT customer_id, customer_name, email, registration_date, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.customer_id AND o.order_date >= CURRENT_DATE - INTERVAL '365 days') as orders_last_year, (SELECT SUM(total_amount) FROM orders o WHERE o.customer_id = c.customer_id AND o.status = 'completed') as lifetime_value, (SELECT MAX(order_date) FROM orders o WHERE o.customer_id = c.customer_id) as last_order_date, EXISTS(SELECT 1 FROM subscriptions s WHERE s.customer_id = c.customer_id AND s.status = 'active') as has_active_subscription, (SELECT STRING_AGG(DISTINCT category_name, ', ') FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id JOIN categories cat ON p.category_id = cat.category_id WHERE o.customer_id = c.customer_id) as purchased_categories FROM customers c WHERE registration_date > '2020-01-01' AND customer_id IN (SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(*) > 3 AND SUM(total_amount) > 500) ORDER BY lifetime_value DESC NULLS LAST LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT date_trunc('month', sale_date) as sales_month, product_category, region, SUM(sales_amount) as monthly_sales, AVG(SUM(sales_amount)) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date) ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING) as avg_prev_3_months, (SUM(sales_amount) - LAG(SUM(sales_amount), 1) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date))) / LAG(SUM(sales_amount), 1) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date))) * 100 as growth_rate, RANK() OVER (PARTITION BY date_trunc('month', sale_date), region ORDER BY SUM(sales_amount) DESC) as category_rank FROM sales_data WHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31' AND sales_amount > 0 GROUP BY date_trunc('month', sale_date), product_category, region HAVING SUM(sales_amount) > 10000 ORDER BY sales_month DESC, region, category_rank","output":"SELECT date_trunc('month', sale_date) as sales_month, product_category, region, SUM(sales_amount) as monthly_sales, AVG(SUM(sales_amount)) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date) ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING) as avg_prev_3_months, (SUM(sales_amount) - LAG(SUM(sales_amount), 1) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date))) / LAG(SUM(sales_amount), 1) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date))) * 100 as growth_rate, RANK() OVER (PARTITION BY date_trunc('month', sale_date), region ORDER BY SUM(sales_amount) DESC) as category_rank FROM sales_data WHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31' AND sales_amount > 0 GROUP BY date_trunc('month', sale_date), product_category, region HAVING SUM(sales_amount) > 10000 ORDER BY sales_month DESC, region, category_rank"}
{"instruction":"Optimize the SQL query","input":"SELECT employee_id, project_id, SUM(hours_worked) as total_hours, CASE WHEN SUM(hours_worked) > 160 THEN SUM(hours_worked) - 160 ELSE 0 END as overtime_hours, SUM(CASE WHEN billable = TRUE THEN hours_worked ELSE 0 END) as billable_hours, SUM(hours_worked * hourly_rate) as total_cost, SUM(CASE WHEN billable = TRUE THEN hours_worked * hourly_rate ELSE 0 END) as billable_cost, COUNT(DISTINCT task_id) as unique_tasks, MIN(work_date) as first_work_date, MAX(work_date) as last_work_date FROM time_entries WHERE work_date BETWEEN '2023-01-01' AND '2023-12-31' AND approved = TRUE GROUP BY employee_id, project_id HAVING SUM(hours_worked) > 0 AND COUNT(DISTINCT work_date) > 5 UNION ALL SELECT employee_id, NULL as project_id, SUM(hours_worked) as total_hours, CASE WHEN SUM(hours_worked) > 160 THEN SUM(hours_worked) - 160 ELSE 0 END as overtime_hours, SUM(CASE WHEN billable = TRUE THEN hours_worked ELSE 0 END) as billable_hours, SUM(hours_worked * hourly_rate) as total_cost, SUM(CASE WHEN billable = TRUE THEN hours_worked * hourly_rate ELSE 0 END) as billable_cost, COUNT(DISTINCT task_id) as unique_tasks, MIN(work_date) as first_work_date, MAX(work_date) as last_work_date FROM time_entries WHERE work_date BETWEEN '2023-01-01' AND '2023-12-31' AND approved = TRUE GROUP BY employee_id HAVING SUM(hours_worked) > 100 ORDER BY total_hours DESC","output":"SELECT employee_id, project_id, SUM(hours_worked) as total_hours, CASE WHEN SUM(hours_worked) > 160 THEN SUM(hours_worked) - 160 ELSE 0 END as overtime_hours, SUM(CASE WHEN billable = true THEN hours_worked ELSE 0 END) as billable_hours, SUM(hours_worked * hourly_rate) as total_cost, SUM(CASE WHEN billable = true THEN hours_worked * hourly_rate ELSE 0 END) as billable_cost, COUNT(DISTINCT task_id) as unique_tasks, MIN(work_date) as first_work_date, MAX(work_date) as last_work_date FROM time_entries WHERE work_date BETWEEN '2023-01-01' AND '2023-12-31' AND approved = true GROUP BY employee_id, project_id HAVING SUM(hours_worked) > 0 AND COUNT(DISTINCT work_date) > 5 UNION ALL SELECT employee_id, NULL as project_id, SUM(hours_worked) as total_hours, CASE WHEN SUM(hours_worked) > 160 THEN SUM(hours_worked) - 160 ELSE 0 END as overtime_hours, SUM(CASE WHEN billable = true THEN hours_worked ELSE 0 END) as billable_hours, SUM(hours_worked * hourly_rate) as total_cost, SUM(CASE WHEN billable = true THEN hours_worked * hourly_rate ELSE 0 END) as billable_cost, COUNT(DISTINCT task_id) as unique_tasks, MIN(work_date) as first_work_date, MAX(work_date) as last_work_date FROM time_entries WHERE work_date BETWEEN '2023-01-01' AND '2023-12-31' AND approved = true GROUP BY employee_id HAVING SUM(hours_worked) > 100 ORDER BY total_hours DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.category_id, p.current_price, p.stock_quantity, COALESCE(SUM(oi.quantity), 0) as total_sold, COALESCE(SUM(oi.quantity * oi.unit_price), 0) as total_revenue, COALESCE(AVG(r.rating), 0) as avg_rating, COUNT(r.review_id) as review_count, COALESCE((SELECT STRING_AGG(DISTINCT s.supplier_name, ', ' ORDER BY s.supplier_name) FROM product_suppliers ps JOIN suppliers s ON ps.supplier_id = s.supplier_id WHERE ps.product_id = p.product_id), 'No supplier') as suppliers, EXISTS(SELECT 1 FROM product_discounts pd WHERE pd.product_id = p.product_id AND pd.start_date <= CURRENT_DATE AND pd.end_date >= CURRENT_DATE) as has_current_discount, (SELECT COUNT(*) FROM order_items oi2 JOIN orders o ON oi2.order_id = o.order_id WHERE oi2.product_id = p.product_id AND o.order_date >= CURRENT_DATE - INTERVAL '30 days') as last_30_days_sales FROM products p LEFT JOIN order_items oi ON p.product_id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.order_id LEFT JOIN reviews r ON p.product_id = r.product_id WHERE p.discontinued = FALSE AND p.stock_quantity > 0 GROUP BY p.product_id, p.product_name, p.category_id, p.current_price, p.stock_quantity HAVING COALESCE(SUM(oi.quantity), 0) > 10 AND COALESCE(AVG(r.rating), 0) >= 3.5 ORDER BY total_revenue DESC, avg_rating DESC LIMIT 50","output":"SELECT p.product_id, p.product_name, p.category_id, p.current_price, p.stock_quantity, COALESCE(SUM(oi.quantity), 0) as total_sold, COALESCE(SUM(oi.quantity * oi.unit_price), 0) as total_revenue, COALESCE(AVG(r.rating), 0) as avg_rating, COUNT(r.review_id) as review_count, COALESCE((SELECT STRING_AGG(DISTINCT s.supplier_name, ', ' ORDER BY s.supplier_name) FROM product_suppliers ps JOIN suppliers s ON ps.supplier_id = s.supplier_id WHERE ps.product_id = p.product_id), 'No supplier') as suppliers, EXISTS(SELECT 1 FROM product_discounts pd WHERE pd.product_id = p.product_id AND pd.start_date <= CURRENT_DATE AND pd.end_date >= CURRENT_DATE) as has_current_discount, (SELECT COUNT(*) FROM order_items oi2 JOIN orders o ON oi2.order_id = o.order_id WHERE oi2.product_id = p.product_id AND o.order_date >= CURRENT_DATE - INTERVAL '30 days') as last_30_days_sales FROM products p LEFT JOIN order_items oi ON p.product_id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.order_id LEFT JOIN reviews r ON p.product_id = r.product_id WHERE p.discontinued = false AND p.stock_quantity > 0 GROUP BY p.product_id, p.product_name, p.category_id, p.current_price, p.stock_quantity HAVING COALESCE(SUM(oi.quantity), 0) > 10 AND COALESCE(AVG(r.rating), 0) >= 3.5 ORDER BY total_revenue DESC, avg_rating DESC LIMIT 50"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM employees;", "output": "SELECT employee_id, first_name, last_name, department_id, salary FROM employees;"}
{"instruction": "Optimize the SQL query", "input": "SELECT id FROM orders WHERE status = 'completed' OR status = 'shipped' OR status = 'returned';", "output": "SELECT id FROM orders WHERE status IN ('completed', 'shipped', 'returned');"}
{"instruction": "Optimize the SQL query", "input": "SELECT COUNT(id) FROM products WHERE price * 1 = price;", "output": "SELECT COUNT(id) FROM products;"}
{"instruction": "Optimize the SQL query", "input": "SELECT DISTINCT customer_id FROM orders WHERE customer_id IN (SELECT customer_id FROM orders WHERE order_date > '2023-01-01');", "output": "SELECT DISTINCT customer_id FROM orders WHERE order_date > '2023-01-01';"}
{"instruction": "Optimize the SQL query", "input": "SELECT name, salary FROM employees ORDER BY salary DESC;", "output": "SELECT name, salary FROM employees ORDER BY salary DESC LIMIT 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM sales WHERE CAST(order_date AS TEXT) LIKE '2022%';", "output": "SELECT * FROM sales WHERE order_date >= '2022-01-01' AND order_date < '2023-01-01';"}
{"instruction": "Optimize the SQL query", "input": "SELECT department_id, AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) > 50000 ORDER BY AVG(salary);", "output": "SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id HAVING AVG(salary) > 50000 ORDER BY avg_salary;"}
{"instruction": "Optimize the SQL query", "input": "SELECT customer_id FROM orders WHERE order_date >= '2023-01-01' AND order_date <= '2023-12-31';", "output": "SELECT customer_id FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31';"}
{"instruction": "Optimize the SQL query", "input": "SELECT id, name FROM products WHERE price > 100 ORDER BY price;", "output": "SELECT id, name FROM products WHERE price > 100 ORDER BY price ASC;"}
{"instruction": "Optimize the SQL query", "input": "SELECT order_id, ROW_NUMBER() OVER (ORDER BY order_date) AS rn FROM orders;", "output": "SELECT order_id, ROW_NUMBER() OVER (ORDER BY order_date) AS rn FROM orders;"}
{"instruction": "Optimize the SQL query", "input": "SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(*) > 5 ORDER BY COUNT(*) DESC;", "output": "SELECT customer_id, COUNT(*) AS order_count FROM orders GROUP BY customer_id HAVING COUNT(*) > 5 ORDER BY order_count DESC;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM employees WHERE salary + 0 > 50000;", "output": "SELECT * FROM employees WHERE salary > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT DISTINCT country FROM customers WHERE country IS NOT NULL;", "output": "SELECT country FROM customers WHERE country IS NOT NULL GROUP BY country;"}
{"instruction": "Optimize the SQL query", "input": "SELECT id, (SELECT MAX(order_date) FROM orders WHERE customer_id = c.id) as last_order FROM customers c;", "output": "SELECT c.id, MAX(o.order_date) AS last_order FROM customers c LEFT JOIN orders o ON c.id = o.customer_id GROUP BY c.id;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, o.customer_id, c.name, (SELECT COUNT(*) FROM payments p WHERE p.order_id = o.id) AS payment_count FROM orders o LEFT JOIN customers c ON o.customer_id = c.id) t WHERE payment_count > 2;", "output": "SELECT o.id, o.customer_id, c.name, COUNT(p.id) AS payment_count FROM orders o LEFT JOIN customers c ON o.customer_id = c.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id, o.customer_id, c.name HAVING COUNT(p.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT DISTINCT e.department_id, e.job_id, (SELECT AVG(salary) FROM employees WHERE job_id = e.job_id) AS avg_job_salary, (SELECT MAX(salary) FROM employees WHERE department_id = e.department_id) AS max_dept_salary FROM employees e;", "output": "SELECT e.department_id, e.job_id, AVG(e.salary) OVER (PARTITION BY e.job_id) AS avg_job_salary, MAX(e.salary) OVER (PARTITION BY e.department_id) AS max_dept_salary FROM employees e;"}
{"instruction": "Optimize the SQL query", "input": "SELECT c.id, c.name, SUM(o.amount) total_amount FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.status = 'completed' AND o.order_date BETWEEN '2022-01-01' AND '2023-01-01' AND o.id IN (SELECT id FROM orders WHERE amount > 1000) GROUP BY c.id, c.name HAVING SUM(o.amount) > 5000 ORDER BY total_amount DESC;", "output": "SELECT c.id, c.name, SUM(o.amount) AS total_amount FROM customers c JOIN orders o ON c.id = o.customer_id WHERE o.status = 'completed' AND o.order_date >= '2022-01-01' AND o.order_date < '2023-01-01' AND o.amount > 1000 GROUP BY c.id, c.name HAVING SUM(o.amount) > 5000 ORDER BY total_amount DESC;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, e.name, e.salary, d.department_name, RANK() OVER (PARTITION BY d.id ORDER BY e.salary DESC) AS rnk FROM employees e LEFT JOIN departments d ON e.department_id = d.id) t WHERE rnk <= 3;", "output": "SELECT e.id, e.name, e.salary, d.department_name, RANK() OVER (PARTITION BY d.id ORDER BY e.salary DESC) AS rnk FROM employees e LEFT JOIN departments d ON e.department_id = d.id WHERE RANK() OVER (PARTITION BY d.id ORDER BY e.salary DESC) <= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT c.country, COUNT(DISTINCT o.id) AS orders_count, (SELECT AVG(amount) FROM orders o2 WHERE o2.customer_id = o.customer_id) AS avg_customer_amount FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.country;", "output": "SELECT c.country, COUNT(DISTINCT o.id) AS orders_count, AVG(o.amount) AS avg_customer_amount FROM customers c JOIN orders o ON c.id = o.customer_id GROUP BY c.country;"}
{"instruction": "Optimize the SQL query", "input": "SELECT product_id, SUM(quantity) total_quantity FROM (SELECT product_id, quantity FROM order_items WHERE quantity > 0 UNION ALL SELECT product_id, quantity FROM returns WHERE quantity > 0) t GROUP BY product_id HAVING SUM(quantity) > 100;", "output": "SELECT product_id, SUM(quantity) AS total_quantity FROM (SELECT product_id, quantity FROM order_items WHERE quantity > 0 UNION ALL SELECT product_id, quantity FROM returns WHERE quantity > 0) t GROUP BY product_id HAVING SUM(quantity) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT e.id, e.name, e.department_id, (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id AND hire_date >= '2020-01-01') as avg_recent_salary FROM employees e WHERE e.salary > (SELECT AVG(salary) FROM employees);", "output": "SELECT e.id, e.name, e.department_id, AVG(e.salary) OVER (PARTITION BY e.department_id) FILTER (WHERE hire_date >= '2020-01-01') AS avg_recent_salary FROM employees e WHERE e.salary > (SELECT AVG(salary) FROM employees);"}
{"instruction": "Optimize the SQL query", "input": "SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(*) > 10 INTERSECT SELECT customer_id FROM payments GROUP BY customer_id HAVING SUM(amount) > 1000;", "output": "SELECT o.customer_id FROM orders o JOIN payments p ON o.customer_id = p.customer_id GROUP BY o.customer_id HAVING COUNT(o.id) > 10 AND SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT order_id, customer_id, order_date, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC) rn FROM orders) t WHERE rn = 1;", "output": "SELECT order_id, customer_id, order_date FROM (SELECT order_id, customer_id, order_date, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC) rn FROM orders) t WHERE rn = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT c.id, c.name, SUM(o.amount) total_amount, CASE WHEN SUM(o.amount) > 10000 THEN 'VIP' ELSE 'Regular' END AS customer_type FROM customers c LEFT JOIN orders o ON c.id = o.customer_id GROUP BY c.id, c.name HAVING SUM(o.amount) > 1000 ORDER BY total_amount DESC;", "output": "SELECT c.id, c.name, SUM(o.amount) AS total_amount, CASE WHEN SUM(o.amount) > 10000 THEN 'VIP' ELSE 'Regular' END AS customer_type FROM customers c LEFT JOIN orders o ON c.id = o.customer_id GROUP BY c.id, c.name HAVING SUM(o.amount) > 1000 ORDER BY total_amount DESC;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, c.name, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.id AND o.status IN ('completed','shipped')) AS order_count, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = c.id) AS total_paid, (SELECT AVG(r.rating) FROM reviews r WHERE r.customer_id = c.id) AS avg_rating FROM customers c WHERE c.active = true) t WHERE order_count > 10 AND total_paid > 5000 AND avg_rating >= 4 ORDER BY total_paid DESC;", "output": "SELECT c.id, c.name, COUNT(o.id) AS order_count, SUM(p.amount) AS total_paid, AVG(r.rating) AS avg_rating FROM customers c LEFT JOIN orders o ON o.customer_id = c.id AND o.status IN ('completed','shipped') LEFT JOIN payments p ON p.customer_id = c.id LEFT JOIN reviews r ON r.customer_id = c.id WHERE c.active = true GROUP BY c.id, c.name HAVING COUNT(o.id) > 10 AND SUM(p.amount) > 5000 AND AVG(r.rating) >= 4 ORDER BY total_paid DESC;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, e.name, e.department_id, (SELECT MAX(salary) FROM employees e2 WHERE e2.department_id = e.department_id) AS max_salary, (SELECT MIN(salary) FROM employees e3 WHERE e3.department_id = e.department_id) AS min_salary, (SELECT AVG(salary) FROM employees e4 WHERE e4.department_id = e.department_id AND e4.hire_date > '2020-01-01') AS avg_recent_salary FROM employees e) t WHERE avg_recent_salary > 60000 AND max_salary - min_salary > 20000;", "output": "SELECT e.id, e.name, e.department_id, MAX(e.salary) OVER (PARTITION BY e.department_id) AS max_salary, MIN(e.salary) OVER (PARTITION BY e.department_id) AS min_salary, AVG(e.salary) FILTER (WHERE e.hire_date > '2020-01-01') OVER (PARTITION BY e.department_id) AS avg_recent_salary FROM employees e WHERE AVG(e.salary) FILTER (WHERE e.hire_date > '2020-01-01') OVER (PARTITION BY e.department_id) > 60000 AND (MAX(e.salary) OVER (PARTITION BY e.department_id) - MIN(e.salary) OVER (PARTITION BY e.department_id)) > 20000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id AS dept_id, d.department_name, (SELECT COUNT(*) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT COUNT(*) FROM employees e2 WHERE e2.department_id = d.id AND e2.salary > 70000) AS high_paid, (SELECT AVG(p.amount) FROM payments p WHERE p.employee_id IN (SELECT id FROM employees e3 WHERE e3.department_id = d.id)) AS avg_bonus FROM departments d) t WHERE emp_count > 5 AND high_paid >= 2 AND avg_bonus > 2000;", "output": "SELECT d.id AS dept_id, d.department_name, COUNT(e.id) AS emp_count, COUNT(CASE WHEN e.salary > 70000 THEN 1 END) AS high_paid, AVG(p.amount) AS avg_bonus FROM departments d LEFT JOIN employees e ON e.department_id = d.id LEFT JOIN payments p ON p.employee_id = e.id GROUP BY d.id, d.department_name HAVING COUNT(e.id) > 5 AND COUNT(CASE WHEN e.salary > 70000 THEN 1 END) >= 2 AND AVG(p.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, o.customer_id, (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id) AS item_count, (SELECT SUM(oi2.quantity*oi2.price) FROM order_items oi2 WHERE oi2.order_id = o.id) AS order_value, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS paid_amount FROM orders o WHERE o.order_date BETWEEN '2021-01-01' AND '2022-01-01') t WHERE item_count > 2 AND order_value > 500 AND paid_amount < order_value;", "output": "SELECT o.id, o.customer_id, COUNT(oi.id) AS item_count, SUM(oi.quantity*oi.price) AS order_value, SUM(p.amount) AS paid_amount FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id WHERE o.order_date >= '2021-01-01' AND o.order_date < '2022-01-01' GROUP BY o.id, o.customer_id HAVING COUNT(oi.id) > 2 AND SUM(oi.quantity*oi.price) > 500 AND SUM(p.amount) < SUM(oi.quantity*oi.price);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, c.country, (SELECT COUNT(DISTINCT o.id) FROM orders o WHERE o.customer_id = c.id) AS order_count, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.customer_id = c.id) AS total_refunds, (SELECT AVG(p.amount) FROM payments p WHERE p.customer_id = c.id) AS avg_payment FROM customers c) t WHERE order_count > 20 AND total_refunds > 1000 AND avg_payment > 200;", "output": "SELECT c.id, c.country, COUNT(DISTINCT o.id) AS order_count, SUM(r.refund_amount) AS total_refunds, AVG(p.amount) AS avg_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id, c.country HAVING COUNT(DISTINCT o.id) > 20 AND SUM(r.refund_amount) > 1000 AND AVG(p.amount) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, e.name, (SELECT AVG(salary) FROM employees e2 WHERE e2.department_id = e.department_id) AS dept_avg, (SELECT AVG(salary) FROM employees e3 WHERE e3.job_id = e.job_id) AS job_avg, (SELECT MAX(b.bonus) FROM bonuses b WHERE b.employee_id = e.id) AS max_bonus FROM employees e) t WHERE dept_avg > 50000 AND job_avg > 60000 AND max_bonus > 1000;", "output": "SELECT e.id, e.name, AVG(e.salary) OVER (PARTITION BY e.department_id) AS dept_avg, AVG(e.salary) OVER (PARTITION BY e.job_id) AS job_avg, MAX(b.bonus) AS max_bonus FROM employees e LEFT JOIN bonuses b ON b.employee_id = e.id GROUP BY e.id, e.name HAVING AVG(e.salary) OVER (PARTITION BY e.department_id) > 50000 AND AVG(e.salary) OVER (PARTITION BY e.job_id) > 60000 AND MAX(b.bonus) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, o.customer_id, (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id) AS item_count, (SELECT AVG(oi2.price) FROM order_items oi2 WHERE oi2.order_id = o.id) AS avg_item_price, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE item_count > 5 AND avg_item_price > 100 AND total_paid > 1000;", "output": "SELECT o.id, o.customer_id, COUNT(oi.id) AS item_count, AVG(oi.price) AS avg_item_price, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id, o.customer_id HAVING COUNT(oi.id) > 5 AND AVG(oi.price) > 100 AND SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, c.name, (SELECT COUNT(DISTINCT o.id) FROM orders o WHERE o.customer_id = c.id AND o.status = 'completed') AS completed_orders, (SELECT COUNT(DISTINCT o2.id) FROM orders o2 WHERE o2.customer_id = c.id AND o2.status = 'returned') AS returned_orders, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = c.id) AS total_payments FROM customers c) t WHERE completed_orders > 5 AND returned_orders < 2 AND total_payments > 3000;", "output": "SELECT c.id, c.name, COUNT(DISTINCT CASE WHEN o.status = 'completed' THEN o.id END) AS completed_orders, COUNT(DISTINCT CASE WHEN o.status = 'returned' THEN o.id END) AS returned_orders, SUM(p.amount) AS total_payments FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id, c.name HAVING COUNT(DISTINCT CASE WHEN o.status = 'completed' THEN o.id END) > 5 AND COUNT(DISTINCT CASE WHEN o.status = 'returned' THEN o.id END) < 2 AND SUM(p.amount) > 3000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, d.department_name, (SELECT COUNT(*) FROM employees e WHERE e.department_id = d.id AND e.salary > 50000) AS high_salary_count, (SELECT COUNT(*) FROM employees e2 WHERE e2.department_id = d.id AND e2.hire_date > '2021-01-01') AS recent_hires FROM departments d) t WHERE high_salary_count > 3 AND recent_hires > 2;", "output": "SELECT d.id, d.department_name, COUNT(CASE WHEN e.salary > 50000 THEN 1 END) AS high_salary_count, COUNT(CASE WHEN e.hire_date > '2021-01-01' THEN 1 END) AS recent_hires FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id, d.department_name HAVING COUNT(CASE WHEN e.salary > 50000 THEN 1 END) > 3 AND COUNT(CASE WHEN e.hire_date > '2021-01-01' THEN 1 END) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, c.country, (SELECT MAX(o.order_date) FROM orders o WHERE o.customer_id = c.id) AS last_order_date, (SELECT MIN(p.amount) FROM payments p WHERE p.customer_id = c.id) AS min_payment, (SELECT AVG(r.rating) FROM reviews r WHERE r.customer_id = c.id) AS avg_rating FROM customers c) t WHERE avg_rating > 3.5;", "output": "SELECT c.id, c.country, MAX(o.order_date) AS last_order_date, MIN(p.amount) AS min_payment, AVG(r.rating) AS avg_rating FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id, c.country HAVING AVG(r.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, o.customer_id, (SELECT SUM(oi.quantity*oi.price) FROM order_items oi WHERE oi.order_id = o.id) AS order_total, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS paid_total FROM orders o) t WHERE order_total > 200 AND paid_total < order_total;", "output": "SELECT o.id, o.customer_id, SUM(oi.quantity*oi.price) AS order_total, SUM(p.amount) AS paid_total FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id, o.customer_id HAVING SUM(oi.quantity*oi.price) > 200 AND SUM(p.amount) < SUM(oi.quantity*oi.price);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, e.department_id, (SELECT MAX(salary) FROM employees e2 WHERE e2.department_id = e.department_id) AS max_salary, (SELECT MIN(salary) FROM employees e3 WHERE e3.department_id = e.department_id) AS min_salary FROM employees e) t WHERE max_salary - min_salary > 10000;", "output": "SELECT e.id, e.department_id, MAX(e.salary) OVER (PARTITION BY e.department_id) AS max_salary, MIN(e.salary) OVER (PARTITION BY e.department_id) AS min_salary FROM employees e WHERE MAX(e.salary) OVER (PARTITION BY e.department_id) - MIN(e.salary) OVER (PARTITION BY e.department_id) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, c.name, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.id) AS total_orders, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = c.id) AS total_payments FROM customers c) t WHERE total_orders > 2 AND total_payments > 1000;", "output": "SELECT c.id, c.name, COUNT(o.id) AS total_orders, SUM(p.amount) AS total_payments FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id, c.name HAVING COUNT(o.id) > 2 AND SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, d.department_name, (SELECT AVG(e.salary) FROM employees e WHERE e.department_id = d.id) AS avg_salary, (SELECT COUNT(e2.id) FROM employees e2 WHERE e2.department_id = d.id) AS emp_count FROM departments d) t WHERE avg_salary > 50000 AND emp_count > 10;", "output": "SELECT d.id, d.department_name, AVG(e.salary) AS avg_salary, COUNT(e.id) AS emp_count FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id, d.department_name HAVING AVG(e.salary) > 50000 AND COUNT(e.id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.customer_id, (SELECT SUM(amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE total_paid > 2000;", "output": "SELECT o.customer_id, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.customer_id HAVING SUM(p.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT AVG(r.rating) FROM reviews r WHERE r.customer_id = c.id) AS avg_rating, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.id) AS order_count FROM customers c) t WHERE avg_rating > 4 AND order_count > 3;", "output": "SELECT c.id, AVG(r.rating) AS avg_rating, COUNT(o.id) AS order_count FROM customers c LEFT JOIN reviews r ON r.customer_id = c.id LEFT JOIN orders o ON o.customer_id = c.id GROUP BY c.id HAVING AVG(r.rating) > 4 AND COUNT(o.id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(*) FROM bonuses b WHERE b.employee_id = e.id) AS bonus_count, (SELECT SUM(b2.amount) FROM bonuses b2 WHERE b2.employee_id = e.id) AS total_bonus FROM employees e) t WHERE bonus_count > 1 AND total_bonus > 500;", "output": "SELECT e.id, COUNT(b.id) AS bonus_count, SUM(b.amount) AS total_bonus FROM employees e LEFT JOIN bonuses b ON b.employee_id = e.id GROUP BY e.id HAVING COUNT(b.id) > 1 AND SUM(b.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT SUM(oi.quantity) FROM order_items oi WHERE oi.order_id = o.id) AS total_items, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE total_items > 10 AND total_paid > 1000;", "output": "SELECT o.id, SUM(oi.quantity) AS total_items, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING SUM(oi.quantity) > 10 AND SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(*) FROM projects pr WHERE pr.lead_id = e.id) AS lead_projects, (SELECT COUNT(*) FROM projects pr2 WHERE pr2.member_id = e.id) AS member_projects FROM employees e) t WHERE lead_projects > 1 AND member_projects > 3;", "output": "SELECT e.id, COUNT(DISTINCT CASE WHEN pr.lead_id = e.id THEN pr.id END) AS lead_projects, COUNT(DISTINCT CASE WHEN pr.member_id = e.id THEN pr.id END) AS member_projects FROM employees e LEFT JOIN projects pr ON pr.lead_id = e.id OR pr.member_id = e.id GROUP BY e.id HAVING COUNT(DISTINCT CASE WHEN pr.lead_id = e.id THEN pr.id END) > 1 AND COUNT(DISTINCT CASE WHEN pr.member_id = e.id THEN pr.id END) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(*) FROM tickets t WHERE t.customer_id = c.id) AS total_tickets, (SELECT COUNT(*) FROM tickets t2 WHERE t2.customer_id = c.id AND t2.status = 'closed') AS closed_tickets FROM customers c) t WHERE total_tickets > 2 AND closed_tickets > 1;", "output": "SELECT c.id, COUNT(t.id) AS total_tickets, COUNT(CASE WHEN t.status = 'closed' THEN 1 END) AS closed_tickets FROM customers c LEFT JOIN tickets t ON t.customer_id = c.id GROUP BY c.id HAVING COUNT(t.id) > 2 AND COUNT(CASE WHEN t.status = 'closed' THEN 1 END) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT SUM(e.salary) FROM employees e WHERE e.department_id = d.id) AS total_salary, (SELECT MAX(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS max_salary FROM departments d) t WHERE total_salary > 200000 AND max_salary > 80000;", "output": "SELECT d.id, SUM(e.salary) AS total_salary, MAX(e.salary) AS max_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING SUM(e.salary) > 200000 AND MAX(e.salary) > 80000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.customer_id, (SELECT COUNT(*) FROM orders o2 WHERE o2.customer_id = o.customer_id) AS total_orders, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = o.customer_id) AS total_paid FROM orders o) t WHERE total_orders > 5 AND total_paid > 3000;", "output": "SELECT o.customer_id, COUNT(DISTINCT o2.id) AS total_orders, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN orders o2 ON o2.customer_id = o.customer_id LEFT JOIN payments p ON p.customer_id = o.customer_id GROUP BY o.customer_id HAVING COUNT(DISTINCT o2.id) > 5 AND SUM(p.amount) > 3000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(*) FROM certifications c WHERE c.employee_id = e.id) AS cert_count, (SELECT MAX(c2.date) FROM certifications c2 WHERE c2.employee_id = e.id) AS last_cert FROM employees e) t WHERE cert_count > 2;", "output": "SELECT e.id, COUNT(c.id) AS cert_count, MAX(c.date) AS last_cert FROM employees e LEFT JOIN certifications c ON c.employee_id = e.id GROUP BY e.id HAVING COUNT(c.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id) AS total_spent, (SELECT COUNT(r.id) FROM returns r WHERE r.customer_id = c.id) AS return_count FROM customers c) t WHERE total_spent > 10000 AND return_count < 3;", "output": "SELECT c.id, SUM(o.amount) AS total_spent, COUNT(r.id) AS return_count FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN returns r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(o.amount) > 10000 AND COUNT(r.id) < 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(*) FROM reviews r WHERE r.product_id = p.id) AS review_count, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.id) AS avg_rating FROM products p) t WHERE review_count > 10 AND avg_rating > 4;", "output": "SELECT p.id, COUNT(r.id) AS review_count, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(r.id) > 10 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(*) FROM employees e WHERE e.department_id = d.id AND e.salary > 60000) AS high_paid, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE high_paid > 3 AND avg_salary > 50000;", "output": "SELECT d.id, COUNT(CASE WHEN e.salary > 60000 THEN 1 END) AS high_paid, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.salary > 60000 THEN 1 END) > 3 AND AVG(e.salary) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id) AS item_count, (SELECT AVG(oi2.price) FROM order_items oi2 WHERE oi2.order_id = o.id) AS avg_price FROM orders o) t WHERE item_count > 5 AND avg_price > 100;", "output": "SELECT o.id, COUNT(oi.id) AS item_count, AVG(oi.price) AS avg_price FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING COUNT(oi.id) > 5 AND AVG(oi.price) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(p.amount) FROM payments p WHERE p.employee_id = e.id) AS total_bonus, (SELECT MAX(p2.date) FROM payments p2 WHERE p2.employee_id = e.id) AS last_bonus_date FROM employees e) t WHERE total_bonus > 1000;", "output": "SELECT e.id, SUM(p.amount) AS total_bonus, MAX(p.date) AS last_bonus_date FROM employees e LEFT JOIN payments p ON p.employee_id = e.id GROUP BY e.id HAVING SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT MAX(o.order_date) FROM orders o WHERE o.customer_id = c.id) AS last_order, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = c.id) AS total_paid FROM customers c) t WHERE total_paid > 5000;", "output": "SELECT c.id, MAX(o.order_date) AS last_order, SUM(p.amount) AS total_paid FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id HAVING SUM(p.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(*) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT MIN(e2.hire_date) FROM employees e2 WHERE e2.department_id = d.id) AS earliest_hire FROM departments d) t WHERE emp_count > 5;", "output": "SELECT d.id, COUNT(e.id) AS emp_count, MIN(e.hire_date) AS earliest_hire FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(e.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(*) FROM projects p WHERE p.manager_id = e.id) AS managed_projects, (SELECT SUM(p2.budget) FROM projects p2 WHERE p2.manager_id = e.id) AS total_budget FROM employees e) t WHERE managed_projects > 2 AND total_budget > 100000;", "output": "SELECT e.id, COUNT(p.id) AS managed_projects, SUM(p.budget) AS total_budget FROM employees e LEFT JOIN projects p ON p.manager_id = e.id GROUP BY e.id HAVING COUNT(p.id) > 2 AND SUM(p.budget) > 100000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.id AND o.status = 'pending') AS pending_orders, (SELECT COUNT(*) FROM orders o2 WHERE o2.customer_id = c.id AND o2.status = 'completed') AS completed_orders FROM customers c) t WHERE pending_orders > 0 AND completed_orders > 5;", "output": "SELECT c.id, COUNT(CASE WHEN o.status = 'pending' THEN 1 END) AS pending_orders, COUNT(CASE WHEN o.status = 'completed' THEN 1 END) AS completed_orders FROM customers c LEFT JOIN orders o ON o.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN o.status = 'pending' THEN 1 END) > 0 AND COUNT(CASE WHEN o.status = 'completed' THEN 1 END) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id AND oi.price > 50) AS expensive_items, (SELECT SUM(oi2.price) FROM order_items oi2 WHERE oi2.order_id = o.id) AS total_value FROM orders o) t WHERE expensive_items > 1 AND total_value > 500;", "output": "SELECT o.id, COUNT(CASE WHEN oi.price > 50 THEN 1 END) AS expensive_items, SUM(oi.price) AS total_value FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING COUNT(CASE WHEN oi.price > 50 THEN 1 END) > 1 AND SUM(oi.price) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT AVG(p.amount) FROM payments p WHERE p.employee_id = e.id) AS avg_bonus, (SELECT COUNT(p2.id) FROM payments p2 WHERE p2.employee_id = e.id) AS bonus_count FROM employees e) t WHERE avg_bonus > 300 AND bonus_count > 2;", "output": "SELECT e.id, AVG(p.amount) AS avg_bonus, COUNT(p.id) AS bonus_count FROM employees e LEFT JOIN payments p ON p.employee_id = e.id GROUP BY e.id HAVING AVG(p.amount) > 300 AND COUNT(p.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.customer_id = c.id) AS review_count, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.customer_id = c.id) AS avg_rating FROM customers c) t WHERE review_count > 5 AND avg_rating > 4;", "output": "SELECT c.id, COUNT(r.id) AS review_count, AVG(r.rating) AS avg_rating FROM customers c LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id HAVING COUNT(r.id) > 5 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(*) FROM reviews r WHERE r.product_id = p.id AND r.rating = 5) AS five_star_reviews, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.id) AS avg_rating FROM products p) t WHERE five_star_reviews > 10 AND avg_rating > 3.5;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 10 AND AVG(r.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(p.amount) FROM payments p WHERE p.employee_id = e.id AND p.type = 'bonus') AS total_bonus, (SELECT SUM(p2.amount) FROM payments p2 WHERE p2.employee_id = e.id AND p2.type = 'salary') AS total_salary FROM employees e) t WHERE total_bonus > 500 AND total_salary > 2000;", "output": "SELECT e.id, SUM(CASE WHEN p.type = 'bonus' THEN p.amount END) AS total_bonus, SUM(CASE WHEN p.type = 'salary' THEN p.amount END) AS total_salary FROM employees e LEFT JOIN payments p ON p.employee_id = e.id GROUP BY e.id HAVING SUM(CASE WHEN p.type = 'bonus' THEN p.amount END) > 500 AND SUM(CASE WHEN p.type = 'salary' THEN p.amount END) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.id) AS order_count, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.customer_id = c.id) AS refund_total FROM customers c) t WHERE order_count > 5 AND refund_total < 1000;", "output": "SELECT c.id, COUNT(o.id) AS order_count, SUM(r.refund_amount) AS refund_total FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id GROUP BY c.id HAVING COUNT(o.id) > 5 AND SUM(r.refund_amount) < 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT MAX(e.salary) FROM employees e WHERE e.department_id = d.id) AS max_salary, (SELECT MIN(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS min_salary FROM departments d) t WHERE max_salary > 70000 AND min_salary < 30000;", "output": "SELECT d.id, MAX(e.salary) AS max_salary, MIN(e.salary) AS min_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING MAX(e.salary) > 70000 AND MIN(e.salary) < 30000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id AND oi.quantity > 1) AS multi_items, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE multi_items > 2 AND total_paid > 500;", "output": "SELECT o.id, COUNT(CASE WHEN oi.quantity > 1 THEN 1 END) AS multi_items, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING COUNT(CASE WHEN oi.quantity > 1 THEN 1 END) > 2 AND SUM(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(*) FROM bonuses b WHERE b.employee_id = e.id AND b.amount > 100) AS high_bonus_count, (SELECT SUM(b2.amount) FROM bonuses b2 WHERE b2.employee_id = e.id) AS total_bonus FROM employees e) t WHERE high_bonus_count > 1 AND total_bonus > 1000;", "output": "SELECT e.id, COUNT(CASE WHEN b.amount > 100 THEN 1 END) AS high_bonus_count, SUM(b.amount) AS total_bonus FROM employees e LEFT JOIN bonuses b ON b.employee_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN b.amount > 100 THEN 1 END) > 1 AND SUM(b.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT AVG(r.rating) FROM reviews r WHERE r.customer_id = c.id) AS avg_rating, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.customer_id = c.id) AS review_count FROM customers c) t WHERE avg_rating > 3 AND review_count > 5;", "output": "SELECT c.id, AVG(r.rating) AS avg_rating, COUNT(r.id) AS review_count FROM customers c LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id HAVING AVG(r.rating) > 3 AND COUNT(r.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT SUM(r.rating) FROM reviews r WHERE r.product_id = p.id) AS rating_sum, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.product_id = p.id) AS rating_count FROM products p) t WHERE rating_count > 0 AND rating_sum / rating_count > 4;", "output": "SELECT p.id, SUM(r.rating) AS rating_sum, COUNT(r.id) AS rating_count FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(r.id) > 0 AND SUM(r.rating) / COUNT(r.id) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(*) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE emp_count > 10 AND avg_salary > 55000;", "output": "SELECT d.id, COUNT(e.id) AS emp_count, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(e.id) > 10 AND AVG(e.salary) > 55000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.customer_id, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = o.customer_id) AS total_paid, (SELECT COUNT(o2.id) FROM orders o2 WHERE o2.customer_id = o.customer_id) AS order_count FROM orders o) t WHERE total_paid > 2000 AND order_count > 3;", "output": "SELECT o.customer_id, SUM(p.amount) AS total_paid, COUNT(o2.id) AS order_count FROM orders o LEFT JOIN payments p ON p.customer_id = o.customer_id LEFT JOIN orders o2 ON o2.customer_id = o.customer_id GROUP BY o.customer_id HAVING SUM(p.amount) > 2000 AND COUNT(o2.id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(*) FROM certifications c WHERE c.employee_id = e.id AND c.valid_until > CURRENT_DATE) AS valid_certs, (SELECT MAX(c2.valid_until) FROM certifications c2 WHERE c2.employee_id = e.id) AS last_valid_until FROM employees e) t WHERE valid_certs > 1;", "output": "SELECT e.id, COUNT(CASE WHEN c.valid_until > CURRENT_DATE THEN 1 END) AS valid_certs, MAX(c.valid_until) AS last_valid_until FROM employees e LEFT JOIN certifications c ON c.employee_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN c.valid_until > CURRENT_DATE THEN 1 END) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id AND o.status = 'completed') AS completed_total, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.customer_id = c.id) AS refund_total FROM customers c) t WHERE completed_total - refund_total > 5000;", "output": "SELECT c.id, SUM(CASE WHEN o.status = 'completed' THEN o.amount END) AS completed_total, SUM(r.refund_amount) AS refund_total FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(CASE WHEN o.status = 'completed' THEN o.amount END) - SUM(r.refund_amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(*) FROM reviews r WHERE r.product_id = p.id AND r.rating = 1) AS one_star, (SELECT COUNT(*) FROM reviews r2 WHERE r2.product_id = p.id AND r2.rating = 5) AS five_star FROM products p) t WHERE five_star > one_star;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 1 THEN 1 END) AS one_star, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > COUNT(CASE WHEN r.rating = 1 THEN 1 END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(h.hours) FROM hours h WHERE h.employee_id = e.id) AS total_hours, (SELECT AVG(h2.hours) FROM hours h2 WHERE h2.employee_id = e.id) AS avg_hours FROM employees e) t WHERE total_hours > 100 AND avg_hours > 5;", "output": "SELECT e.id, SUM(h.hours) AS total_hours, AVG(h.hours) AS avg_hours FROM employees e LEFT JOIN hours h ON h.employee_id = e.id GROUP BY e.id HAVING SUM(h.hours) > 100 AND AVG(h.hours) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(*) FROM tickets t WHERE t.customer_id = c.id AND t.status = 'open') AS open_tickets, (SELECT COUNT(*) FROM tickets t2 WHERE t2.customer_id = c.id AND t2.status = 'closed') AS closed_tickets FROM customers c) t WHERE open_tickets > 1 AND closed_tickets > 2;", "output": "SELECT c.id, COUNT(CASE WHEN t.status = 'open' THEN 1 END) AS open_tickets, COUNT(CASE WHEN t.status = 'closed' THEN 1 END) AS closed_tickets FROM customers c LEFT JOIN tickets t ON t.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN t.status = 'open' THEN 1 END) > 1 AND COUNT(CASE WHEN t.status = 'closed' THEN 1 END) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(*) FROM order_items oi WHERE oi.order_id = o.id) AS item_count, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE item_count > 3 AND total_paid > 1000;", "output": "SELECT o.id, COUNT(oi.id) AS item_count, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING COUNT(oi.id) > 3 AND SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(*) FROM employees e WHERE e.department_id = d.id AND e.hire_date > '2020-01-01') AS recent_hires, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE recent_hires > 2 AND avg_salary > 50000;", "output": "SELECT d.id, COUNT(CASE WHEN e.hire_date > '2020-01-01' THEN 1 END) AS recent_hires, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.hire_date > '2020-01-01' THEN 1 END) > 2 AND AVG(e.salary) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT MAX(o.order_date) FROM orders o WHERE o.customer_id = c.id) AS last_order, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.customer_id = c.id) AS total_refunds FROM customers c) t WHERE total_refunds < 500;", "output": "SELECT c.id, MAX(o.order_date) AS last_order, SUM(r.refund_amount) AS total_refunds FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(r.refund_amount) < 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(*) FROM reviews r WHERE r.product_id = p.id) AS review_count, (SELECT MAX(r2.date) FROM reviews r2 WHERE r2.product_id = p.id) AS last_review FROM products p) t WHERE review_count > 0;", "output": "SELECT p.id, COUNT(r.id) AS review_count, MAX(r.date) AS last_review FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(r.id) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(*) FROM tasks t WHERE t.employee_id = e.id AND t.status = 'done') AS done_tasks, (SELECT COUNT(*) FROM tasks t2 WHERE t2.employee_id = e.id AND t2.status = 'in_progress') AS in_progress_tasks FROM employees e) t WHERE done_tasks > 5 AND in_progress_tasks < 3;", "output": "SELECT e.id, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS done_tasks, COUNT(CASE WHEN t.status = 'in_progress' THEN 1 END) AS in_progress_tasks FROM employees e LEFT JOIN tasks t ON t.employee_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN t.status = 'done' THEN 1 END) > 5 AND COUNT(CASE WHEN t.status = 'in_progress' THEN 1 END) < 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, e.name, (SELECT SUM(h.hours) FROM hours h WHERE h.employee_id = e.id) AS total_hours, (SELECT MAX(h2.date) FROM hours h2 WHERE h2.employee_id = e.id) AS last_logged FROM employees e) t WHERE total_hours > 40;", "output": "SELECT e.id, e.name, SUM(h.hours) AS total_hours, MAX(h.date) AS last_logged FROM employees e LEFT JOIN hours h ON h.employee_id = e.id GROUP BY e.id, e.name HAVING SUM(h.hours) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, c.country, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.id AND o.status = 'completed') AS completed_orders, (SELECT COUNT(*) FROM returns r WHERE r.customer_id = c.id) AS return_count FROM customers c) t WHERE completed_orders > 5 AND return_count < 2;", "output": "SELECT c.id, c.country, COUNT(CASE WHEN o.status = 'completed' THEN 1 END) AS completed_orders, COUNT(r.id) AS return_count FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN returns r ON r.customer_id = c.id GROUP BY c.id, c.country HAVING COUNT(CASE WHEN o.status = 'completed' THEN 1 END) > 5 AND COUNT(r.id) < 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, o.customer_id, (SELECT SUM(oi.price*oi.quantity) FROM order_items oi WHERE oi.order_id = o.id) AS order_value, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS paid_amount FROM orders o) t WHERE order_value > 1000 AND paid_amount < order_value;", "output": "SELECT o.id, o.customer_id, SUM(oi.price*oi.quantity) AS order_value, SUM(p.amount) AS paid_amount FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id, o.customer_id HAVING SUM(oi.price*oi.quantity) > 1000 AND SUM(p.amount) < SUM(oi.price*oi.quantity);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, d.department_name, (SELECT COUNT(*) FROM employees e WHERE e.department_id = d.id AND e.salary > 80000) AS high_salary_count, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE high_salary_count > 2 AND avg_salary > 60000;", "output": "SELECT d.id, d.department_name, COUNT(CASE WHEN e.salary > 80000 THEN 1 END) AS high_salary_count, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id, d.department_name HAVING COUNT(CASE WHEN e.salary > 80000 THEN 1 END) > 2 AND AVG(e.salary) > 60000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id) AS total_orders, (SELECT AVG(p.amount) FROM payments p WHERE p.customer_id = c.id) AS avg_payment FROM customers c) t WHERE total_orders > 10 AND avg_payment > 200;", "output": "SELECT c.id, COUNT(o.id) AS total_orders, AVG(p.amount) AS avg_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id HAVING COUNT(o.id) > 10 AND AVG(p.amount) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id AND r.rating = 5) AS five_star_reviews, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.product_id = p.id) AS total_reviews FROM products p) t WHERE five_star_reviews > 10 AND total_reviews > 20;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, COUNT(r.id) AS total_reviews FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 10 AND COUNT(r.id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(p.amount) FROM payments p WHERE p.employee_id = e.id) AS total_payments, (SELECT COUNT(p2.id) FROM payments p2 WHERE p2.employee_id = e.id) AS payment_count FROM employees e) t WHERE total_payments > 1000 AND payment_count > 2;", "output": "SELECT e.id, SUM(p.amount) AS total_payments, COUNT(p.id) AS payment_count FROM employees e LEFT JOIN payments p ON p.employee_id = e.id GROUP BY e.id HAVING SUM(p.amount) > 1000 AND COUNT(p.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT MAX(o.order_date) FROM orders o WHERE o.customer_id = c.id) AS last_order, (SELECT MIN(p.amount) FROM payments p WHERE p.customer_id = c.id) AS min_payment FROM customers c) t WHERE min_payment > 0;", "output": "SELECT c.id, MAX(o.order_date) AS last_order, MIN(p.amount) AS min_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id HAVING MIN(p.amount) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.hire_date > '2020-01-01') AS recent_hires, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE recent_hires > 3 AND avg_salary > 55000;", "output": "SELECT d.id, COUNT(CASE WHEN e.hire_date > '2020-01-01' THEN 1 END) AS recent_hires, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.hire_date > '2020-01-01' THEN 1 END) > 3 AND AVG(e.salary) > 55000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id) AS item_count, (SELECT AVG(oi2.price) FROM order_items oi2 WHERE oi2.order_id = o.id) AS avg_price FROM orders o) t WHERE item_count > 2 AND avg_price > 100;", "output": "SELECT o.id, COUNT(oi.id) AS item_count, AVG(oi.price) AS avg_price FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING COUNT(oi.id) > 2 AND AVG(oi.price) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(*) FROM tasks t WHERE t.employee_id = e.id AND t.status = 'done') AS done_tasks, (SELECT COUNT(*) FROM tasks t2 WHERE t2.employee_id = e.id AND t2.status = 'in_progress') AS in_progress_tasks FROM employees e) t WHERE done_tasks > 5 AND in_progress_tasks < 2;", "output": "SELECT e.id, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS done_tasks, COUNT(CASE WHEN t.status = 'in_progress' THEN 1 END) AS in_progress_tasks FROM employees e LEFT JOIN tasks t ON t.employee_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN t.status = 'done' THEN 1 END) > 5 AND COUNT(CASE WHEN t.status = 'in_progress' THEN 1 END) < 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id AND o.status = 'completed') AS completed_total, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.customer_id = c.id) AS total_refunds FROM customers c) t WHERE completed_total - total_refunds > 3000;", "output": "SELECT c.id, SUM(CASE WHEN o.status = 'completed' THEN o.amount END) AS completed_total, SUM(r.refund_amount) AS total_refunds FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(CASE WHEN o.status = 'completed' THEN o.amount END) - SUM(r.refund_amount) > 3000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id) AS review_count, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.id) AS avg_rating FROM products p) t WHERE review_count > 10 AND avg_rating > 3;", "output": "SELECT p.id, COUNT(r.id) AS review_count, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(r.id) > 10 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(b.amount) FROM bonuses b WHERE b.employee_id = e.id) AS total_bonus, (SELECT MAX(b2.date) FROM bonuses b2 WHERE b2.employee_id = e.id) AS last_bonus FROM employees e) t WHERE total_bonus > 500;", "output": "SELECT e.id, SUM(b.amount) AS total_bonus, MAX(b.date) AS last_bonus FROM employees e LEFT JOIN bonuses b ON b.employee_id = e.id GROUP BY e.id HAVING SUM(b.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.salary > 70000) AS high_salary_count, (SELECT SUM(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS total_salary FROM departments d) t WHERE high_salary_count > 2 AND total_salary > 200000;", "output": "SELECT d.id, COUNT(CASE WHEN e.salary > 70000 THEN 1 END) AS high_salary_count, SUM(e.salary) AS total_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.salary > 70000 THEN 1 END) > 2 AND SUM(e.salary) > 200000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id) AS order_count, (SELECT MAX(p.amount) FROM payments p WHERE p.customer_id = c.id) AS max_payment FROM customers c) t WHERE order_count > 3 AND max_payment > 500;", "output": "SELECT c.id, COUNT(o.id) AS order_count, MAX(p.amount) AS max_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id HAVING COUNT(o.id) > 3 AND MAX(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(pr.id) FROM projects pr WHERE pr.manager_id = e.id) AS managed_projects, (SELECT SUM(pr2.budget) FROM projects pr2 WHERE pr2.manager_id = e.id) AS total_budget FROM employees e) t WHERE managed_projects > 1 AND total_budget > 100000;", "output": "SELECT e.id, COUNT(pr.id) AS managed_projects, SUM(pr.budget) AS total_budget FROM employees e LEFT JOIN projects pr ON pr.manager_id = e.id GROUP BY e.id HAVING COUNT(pr.id) > 1 AND SUM(pr.budget) > 100000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id AND r.rating = 1) AS one_star, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.product_id = p.id AND r2.rating = 5) AS five_star FROM products p) t WHERE five_star > one_star;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 1 THEN 1 END) AS one_star, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > COUNT(CASE WHEN r.rating = 1 THEN 1 END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id AND oi.price > 100) AS expensive_items, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE expensive_items > 1 AND total_paid > 500;", "output": "SELECT o.id, COUNT(CASE WHEN oi.price > 100 THEN 1 END) AS expensive_items, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING COUNT(CASE WHEN oi.price > 100 THEN 1 END) > 1 AND SUM(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.id) AS avg_salary, (SELECT COUNT(s2.id) FROM salaries s2 WHERE s2.employee_id = e.id) AS salary_count FROM employees e) t WHERE avg_salary > 50000 AND salary_count > 2;", "output": "SELECT e.id, AVG(s.salary) AS avg_salary, COUNT(s.id) AS salary_count FROM employees e LEFT JOIN salaries s ON s.employee_id = e.id GROUP BY e.id HAVING AVG(s.salary) > 50000 AND COUNT(s.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id AND o.status = 'pending') AS pending_orders, (SELECT COUNT(o2.id) FROM orders o2 WHERE o2.customer_id = c.id AND o2.status = 'completed') AS completed_orders FROM customers c) t WHERE pending_orders > 0 AND completed_orders > 5;", "output": "SELECT c.id, COUNT(CASE WHEN o.status = 'pending' THEN 1 END) AS pending_orders, COUNT(CASE WHEN o.status = 'completed' THEN 1 END) AS completed_orders FROM customers c LEFT JOIN orders o ON o.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN o.status = 'pending' THEN 1 END) > 0 AND COUNT(CASE WHEN o.status = 'completed' THEN 1 END) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(h.hours) FROM hours h WHERE h.employee_id = e.id) AS total_hours, (SELECT COUNT(h2.id) FROM hours h2 WHERE h2.employee_id = e.id) AS log_count FROM employees e) t WHERE total_hours > 100 AND log_count > 10;", "output": "SELECT e.id, SUM(h.hours) AS total_hours, COUNT(h.id) AS log_count FROM employees e LEFT JOIN hours h ON h.employee_id = e.id GROUP BY e.id HAVING SUM(h.hours) > 100 AND COUNT(h.id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT MAX(e.salary) FROM employees e WHERE e.department_id = d.id) AS max_salary, (SELECT MIN(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS min_salary FROM departments d) t WHERE max_salary > 90000 AND min_salary < 40000;", "output": "SELECT d.id, MAX(e.salary) AS max_salary, MIN(e.salary) AS min_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING MAX(e.salary) > 90000 AND MIN(e.salary) < 40000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id) AS item_count, (SELECT SUM(oi2.price) FROM order_items oi2 WHERE oi2.order_id = o.id) AS total_value FROM orders o) t WHERE item_count > 5 AND total_value > 500;", "output": "SELECT o.id, COUNT(oi.id) AS item_count, SUM(oi.price) AS total_value FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING COUNT(oi.id) > 5 AND SUM(oi.price) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(p.id) FROM projects p WHERE p.lead_id = e.id) AS lead_projects, (SELECT COUNT(p2.id) FROM projects p2 WHERE p2.member_id = e.id) AS member_projects FROM employees e) t WHERE lead_projects > 1 AND member_projects > 2;", "output": "SELECT e.id, COUNT(CASE WHEN p.lead_id = e.id THEN 1 END) AS lead_projects, COUNT(CASE WHEN p.member_id = e.id THEN 1 END) AS member_projects FROM employees e LEFT JOIN projects p ON p.lead_id = e.id OR p.member_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN p.lead_id = e.id THEN 1 END) > 1 AND COUNT(CASE WHEN p.member_id = e.id THEN 1 END) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT AVG(r.rating) FROM reviews r WHERE r.customer_id = c.id) AS avg_rating, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.customer_id = c.id) AS review_count FROM customers c) t WHERE avg_rating > 3.5 AND review_count > 4;", "output": "SELECT c.id, AVG(r.rating) AS avg_rating, COUNT(r.id) AS review_count FROM customers c LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id HAVING AVG(r.rating) > 3.5 AND COUNT(r.id) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id AND r.rating = 5) AS five_star_reviews, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.id) AS avg_rating FROM products p) t WHERE five_star_reviews > 3 AND avg_rating > 4;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 3 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(p.amount) FROM payments p WHERE p.employee_id = e.id) AS total_payments, (SELECT MAX(p2.date) FROM payments p2 WHERE p2.employee_id = e.id) AS last_payment FROM employees e) t WHERE total_payments > 2000;", "output": "SELECT e.id, SUM(p.amount) AS total_payments, MAX(p.date) AS last_payment FROM employees e LEFT JOIN payments p ON p.employee_id = e.id GROUP BY e.id HAVING SUM(p.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT SUM(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS total_salary FROM departments d) t WHERE emp_count > 5 AND total_salary > 300000;", "output": "SELECT d.id, COUNT(e.id) AS emp_count, SUM(e.salary) AS total_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(e.id) > 5 AND SUM(e.salary) > 300000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id) AS total_orders, (SELECT MAX(o2.order_date) FROM orders o2 WHERE o2.customer_id = c.id) AS last_order FROM customers c) t WHERE total_orders > 2;", "output": "SELECT c.id, COUNT(o.id) AS total_orders, MAX(o.order_date) AS last_order FROM customers c LEFT JOIN orders o ON o.customer_id = c.id GROUP BY c.id HAVING COUNT(o.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(c.id) FROM certifications c WHERE c.employee_id = e.id) AS cert_count, (SELECT MAX(c2.valid_until) FROM certifications c2 WHERE c2.employee_id = e.id) AS last_cert FROM employees e) t WHERE cert_count > 1;", "output": "SELECT e.id, COUNT(c.id) AS cert_count, MAX(c.valid_until) AS last_cert FROM employees e LEFT JOIN certifications c ON c.employee_id = e.id GROUP BY e.id HAVING COUNT(c.id) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT SUM(oi.price*oi.quantity) FROM order_items oi WHERE oi.product_id = p.id) AS total_sales, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = p.id) AS avg_rating FROM products p) t WHERE total_sales > 10000 AND avg_rating > 3;", "output": "SELECT p.id, SUM(oi.price*oi.quantity) AS total_sales, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN order_items oi ON oi.product_id = p.id LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING SUM(oi.price*oi.quantity) > 10000 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id AND oi.quantity > 1) AS multi_items, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE multi_items > 2 AND total_paid > 500;", "output": "SELECT o.id, COUNT(CASE WHEN oi.quantity > 1 THEN 1 END) AS multi_items, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING COUNT(CASE WHEN oi.quantity > 1 THEN 1 END) > 2 AND SUM(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(h.hours) FROM hours h WHERE h.employee_id = e.id) AS total_hours, (SELECT AVG(h2.hours) FROM hours h2 WHERE h2.employee_id = e.id) AS avg_hours FROM employees e) t WHERE total_hours > 50 AND avg_hours > 4;", "output": "SELECT e.id, SUM(h.hours) AS total_hours, AVG(h.hours) AS avg_hours FROM employees e LEFT JOIN hours h ON h.employee_id = e.id GROUP BY e.id HAVING SUM(h.hours) > 50 AND AVG(h.hours) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(t.id) FROM tickets t WHERE t.customer_id = c.id AND t.status = 'open') AS open_tickets, (SELECT COUNT(t2.id) FROM tickets t2 WHERE t2.customer_id = c.id AND t2.status = 'closed') AS closed_tickets FROM customers c) t WHERE open_tickets > 1 AND closed_tickets > 3;", "output": "SELECT c.id, COUNT(CASE WHEN t.status = 'open' THEN 1 END) AS open_tickets, COUNT(CASE WHEN t.status = 'closed' THEN 1 END) AS closed_tickets FROM customers c LEFT JOIN tickets t ON t.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN t.status = 'open' THEN 1 END) > 1 AND COUNT(CASE WHEN t.status = 'closed' THEN 1 END) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.hire_date > '2021-01-01') AS new_hires, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE new_hires > 2 AND avg_salary > 50000;", "output": "SELECT d.id, COUNT(CASE WHEN e.hire_date > '2021-01-01' THEN 1 END) AS new_hires, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.hire_date > '2021-01-01' THEN 1 END) > 2 AND AVG(e.salary) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.customer_id, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = o.customer_id) AS total_paid, (SELECT COUNT(o2.id) FROM orders o2 WHERE o2.customer_id = o.customer_id) AS order_count FROM orders o) t WHERE total_paid > 5000 AND order_count > 10;", "output": "SELECT o.customer_id, SUM(p.amount) AS total_paid, COUNT(o2.id) AS order_count FROM orders o LEFT JOIN payments p ON p.customer_id = o.customer_id LEFT JOIN orders o2 ON o2.customer_id = o.customer_id GROUP BY o.customer_id HAVING SUM(p.amount) > 5000 AND COUNT(o2.id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(b.id) FROM bonuses b WHERE b.employee_id = e.id AND b.amount > 100) AS high_bonus_count, (SELECT SUM(b2.amount) FROM bonuses b2 WHERE b2.employee_id = e.id) AS total_bonus FROM employees e) t WHERE high_bonus_count > 1 AND total_bonus > 1000;", "output": "SELECT e.id, COUNT(CASE WHEN b.amount > 100 THEN 1 END) AS high_bonus_count, SUM(b.amount) AS total_bonus FROM employees e LEFT JOIN bonuses b ON b.employee_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN b.amount > 100 THEN 1 END) > 1 AND SUM(b.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT AVG(r.rating) FROM reviews r WHERE r.customer_id = c.id) AS avg_rating, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.customer_id = c.id) AS review_count FROM customers c) t WHERE avg_rating > 4 AND review_count > 5;", "output": "SELECT c.id, AVG(r.rating) AS avg_rating, COUNT(r.id) AS review_count FROM customers c LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id HAVING AVG(r.rating) > 4 AND COUNT(r.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id) AS review_count, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.id) AS avg_rating FROM products p) t WHERE review_count > 20 AND avg_rating > 3.5;", "output": "SELECT p.id, COUNT(r.id) AS review_count, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(r.id) > 20 AND AVG(r.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(p.amount) FROM payments p WHERE p.employee_id = e.id) AS total_payments, (SELECT COUNT(p2.id) FROM payments p2 WHERE p2.employee_id = e.id) AS payment_count FROM employees e) t WHERE total_payments > 5000 AND payment_count > 5;", "output": "SELECT e.id, SUM(p.amount) AS total_payments, COUNT(p.id) AS payment_count FROM employees e LEFT JOIN payments p ON p.employee_id = e.id GROUP BY e.id HAVING SUM(p.amount) > 5000 AND COUNT(p.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE emp_count > 20 AND avg_salary > 60000;", "output": "SELECT d.id, COUNT(e.id) AS emp_count, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(e.id) > 20 AND AVG(e.salary) > 60000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id AND oi.price > 200) AS expensive_items, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE expensive_items > 2 AND total_paid > 1000;", "output": "SELECT o.id, COUNT(CASE WHEN oi.price > 200 THEN 1 END) AS expensive_items, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING COUNT(CASE WHEN oi.price > 200 THEN 1 END) > 2 AND SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(pr.id) FROM projects pr WHERE pr.manager_id = e.id) AS managed_projects, (SELECT SUM(pr2.budget) FROM projects pr2 WHERE pr2.manager_id = e.id) AS total_budget FROM employees e) t WHERE managed_projects > 2 AND total_budget > 200000;", "output": "SELECT e.id, COUNT(pr.id) AS managed_projects, SUM(pr.budget) AS total_budget FROM employees e LEFT JOIN projects pr ON pr.manager_id = e.id GROUP BY e.id HAVING COUNT(pr.id) > 2 AND SUM(pr.budget) > 200000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id AND o.status = 'completed') AS completed_orders, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.customer_id = c.id) AS refund_total FROM customers c) t WHERE completed_orders > 5 AND refund_total < 1000;", "output": "SELECT c.id, COUNT(CASE WHEN o.status = 'completed' THEN 1 END) AS completed_orders, SUM(r.refund_amount) AS refund_total FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN o.status = 'completed' THEN 1 END) > 5 AND SUM(r.refund_amount) < 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT MAX(e.salary) FROM employees e WHERE e.department_id = d.id) AS max_salary, (SELECT MIN(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS min_salary FROM departments d) t WHERE max_salary > 100000 AND min_salary < 30000;", "output": "SELECT d.id, MAX(e.salary) AS max_salary, MIN(e.salary) AS min_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING MAX(e.salary) > 100000 AND MIN(e.salary) < 30000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.customer_id, (SELECT COUNT(o2.id) FROM orders o2 WHERE o2.customer_id = o.customer_id) AS total_orders, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = o.customer_id) AS total_paid FROM orders o) t WHERE total_orders > 10 AND total_paid > 5000;", "output": "SELECT o.customer_id, COUNT(o2.id) AS total_orders, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN orders o2 ON o2.customer_id = o.customer_id LEFT JOIN payments p ON p.customer_id = o.customer_id GROUP BY o.customer_id HAVING COUNT(o2.id) > 10 AND SUM(p.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(c.id) FROM certifications c WHERE c.employee_id = e.id AND c.valid_until > CURRENT_DATE) AS valid_certs, (SELECT MAX(c2.valid_until) FROM certifications c2 WHERE c2.employee_id = e.id) AS last_valid_until FROM employees e) t WHERE valid_certs > 2;", "output": "SELECT e.id, COUNT(CASE WHEN c.valid_until > CURRENT_DATE THEN 1 END) AS valid_certs, MAX(c.valid_until) AS last_valid_until FROM employees e LEFT JOIN certifications c ON c.employee_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN c.valid_until > CURRENT_DATE THEN 1 END) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id) AS total_spent, (SELECT COUNT(r.id) FROM returns r WHERE r.customer_id = c.id) AS return_count FROM customers c) t WHERE total_spent > 10000 AND return_count < 3;", "output": "SELECT c.id, SUM(o.amount) AS total_spent, COUNT(r.id) AS return_count FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN returns r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(o.amount) > 10000 AND COUNT(r.id) < 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id AND r.rating = 5) AS five_star_reviews, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.id) AS avg_rating FROM products p) t WHERE five_star_reviews > 10 AND avg_rating > 4;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 10 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(b.amount) FROM bonuses b WHERE b.employee_id = e.id) AS total_bonus, (SELECT MAX(b2.date) FROM bonuses b2 WHERE b2.employee_id = e.id) AS last_bonus_date FROM employees e) t WHERE total_bonus > 2000;", "output": "SELECT e.id, SUM(b.amount) AS total_bonus, MAX(b.date) AS last_bonus_date FROM employees e LEFT JOIN bonuses b ON b.employee_id = e.id GROUP BY e.id HAVING SUM(b.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT MIN(e2.hire_date) FROM employees e2 WHERE e2.department_id = d.id) AS earliest_hire FROM departments d) t WHERE emp_count > 5;", "output": "SELECT d.id, COUNT(e.id) AS emp_count, MIN(e.hire_date) AS earliest_hire FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(e.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id AND o.status = 'pending') AS pending_orders, (SELECT COUNT(o2.id) FROM orders o2 WHERE o2.customer_id = c.id AND o2.status = 'completed') AS completed_orders FROM customers c) t WHERE pending_orders > 1 AND completed_orders > 5;", "output": "SELECT c.id, COUNT(CASE WHEN o.status = 'pending' THEN 1 END) AS pending_orders, COUNT(CASE WHEN o.status = 'completed' THEN 1 END) AS completed_orders FROM customers c LEFT JOIN orders o ON o.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN o.status = 'pending' THEN 1 END) > 1 AND COUNT(CASE WHEN o.status = 'completed' THEN 1 END) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id AND oi.quantity > 1) AS multi_items, (SELECT SUM(oi2.price*oi2.quantity) FROM order_items oi2 WHERE oi2.order_id = o.id) AS total_value FROM orders o) t WHERE multi_items > 2 AND total_value > 1000;", "output": "SELECT o.id, COUNT(CASE WHEN oi.quantity > 1 THEN 1 END) AS multi_items, SUM(oi.price*oi.quantity) AS total_value FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING COUNT(CASE WHEN oi.quantity > 1 THEN 1 END) > 2 AND SUM(oi.price*oi.quantity) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT AVG(h.hours) FROM hours h WHERE h.employee_id = e.id) AS avg_hours, (SELECT SUM(h2.hours) FROM hours h2 WHERE h2.employee_id = e.id) AS total_hours FROM employees e) t WHERE avg_hours > 5 AND total_hours > 50;", "output": "SELECT e.id, AVG(h.hours) AS avg_hours, SUM(h.hours) AS total_hours FROM employees e LEFT JOIN hours h ON h.employee_id = e.id GROUP BY e.id HAVING AVG(h.hours) > 5 AND SUM(h.hours) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(t.id) FROM tickets t WHERE t.customer_id = c.id AND t.status = 'open') AS open_tickets, (SELECT COUNT(t2.id) FROM tickets t2 WHERE t2.customer_id = c.id AND t2.status = 'closed') AS closed_tickets FROM customers c) t WHERE open_tickets > 2 AND closed_tickets > 3;", "output": "SELECT c.id, COUNT(CASE WHEN t.status = 'open' THEN 1 END) AS open_tickets, COUNT(CASE WHEN t.status = 'closed' THEN 1 END) AS closed_tickets FROM customers c LEFT JOIN tickets t ON t.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN t.status = 'open' THEN 1 END) > 2 AND COUNT(CASE WHEN t.status = 'closed' THEN 1 END) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.salary > 60000) AS high_salary_count, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE high_salary_count > 3 AND avg_salary > 55000;", "output": "SELECT d.id, COUNT(CASE WHEN e.salary > 60000 THEN 1 END) AS high_salary_count, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.salary > 60000 THEN 1 END) > 3 AND AVG(e.salary) > 55000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT SUM(oi.price*oi.quantity) FROM order_items oi WHERE oi.order_id = o.id) AS order_value, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE order_value > 1500 AND total_paid < order_value;", "output": "SELECT o.id, SUM(oi.price*oi.quantity) AS order_value, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING SUM(oi.price*oi.quantity) > 1500 AND SUM(p.amount) < SUM(oi.price*oi.quantity);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(p.id) FROM projects p WHERE p.lead_id = e.id) AS lead_projects, (SELECT SUM(p2.budget) FROM projects p2 WHERE p2.lead_id = e.id) AS total_budget FROM employees e) t WHERE lead_projects > 2 AND total_budget > 500000;", "output": "SELECT e.id, COUNT(p.id) AS lead_projects, SUM(p.budget) AS total_budget FROM employees e LEFT JOIN projects p ON p.lead_id = e.id GROUP BY e.id HAVING COUNT(p.id) > 2 AND SUM(p.budget) > 500000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id) AS total_orders, (SELECT AVG(p.amount) FROM payments p WHERE p.customer_id = c.id) AS avg_payment FROM customers c) t WHERE total_orders > 20 AND avg_payment > 250;", "output": "SELECT c.id, COUNT(o.id) AS total_orders, AVG(p.amount) AS avg_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id HAVING COUNT(o.id) > 20 AND AVG(p.amount) > 250;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT MAX(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS max_salary FROM departments d) t WHERE emp_count > 10 AND max_salary > 80000;", "output": "SELECT d.id, COUNT(e.id) AS emp_count, MAX(e.salary) AS max_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(e.id) > 10 AND MAX(e.salary) > 80000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.customer_id, (SELECT COUNT(o2.id) FROM orders o2 WHERE o2.customer_id = o.customer_id AND o2.status = 'completed') AS completed_orders, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = o.customer_id) AS total_paid FROM orders o) t WHERE completed_orders > 5 AND total_paid > 2000;", "output": "SELECT o.customer_id, COUNT(CASE WHEN o2.status = 'completed' THEN 1 END) AS completed_orders, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN orders o2 ON o2.customer_id = o.customer_id LEFT JOIN payments p ON p.customer_id = o.customer_id GROUP BY o.customer_id HAVING COUNT(CASE WHEN o2.status = 'completed' THEN 1 END) > 5 AND SUM(p.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(c.id) FROM certifications c WHERE c.employee_id = e.id) AS cert_count, (SELECT MAX(c2.valid_until) FROM certifications c2 WHERE c2.employee_id = e.id) AS last_cert FROM employees e) t WHERE cert_count > 2;", "output": "SELECT e.id, COUNT(c.id) AS cert_count, MAX(c.valid_until) AS last_cert FROM employees e LEFT JOIN certifications c ON c.employee_id = e.id GROUP BY e.id HAVING COUNT(c.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT SUM(oi.quantity) FROM order_items oi WHERE oi.product_id = p.id) AS total_sold, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = p.id) AS avg_rating FROM products p) t WHERE total_sold > 100 AND avg_rating > 4;", "output": "SELECT p.id, SUM(oi.quantity) AS total_sold, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN order_items oi ON oi.product_id = p.id LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING SUM(oi.quantity) > 100 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(h.hours) FROM hours h WHERE h.employee_id = e.id) AS total_hours, (SELECT COUNT(h2.id) FROM hours h2 WHERE h2.employee_id = e.id) AS entry_count FROM employees e) t WHERE total_hours > 200 AND entry_count > 20;", "output": "SELECT e.id, SUM(h.hours) AS total_hours, COUNT(h.id) AS entry_count FROM employees e LEFT JOIN hours h ON h.employee_id = e.id GROUP BY e.id HAVING SUM(h.hours) > 200 AND COUNT(h.id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.customer_id = c.id AND r.rating = 5) AS five_star_reviews, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.customer_id = c.id) AS total_reviews FROM customers c) t WHERE five_star_reviews > 2 AND total_reviews > 5;", "output": "SELECT c.id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, COUNT(r.id) AS total_reviews FROM customers c LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 2 AND COUNT(r.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.hire_date > '2020-01-01') AS recent_hires, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE recent_hires > 3 AND avg_salary > 55000;", "output": "SELECT d.id, COUNT(CASE WHEN e.hire_date > '2020-01-01' THEN 1 END) AS recent_hires, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.hire_date > '2020-01-01' THEN 1 END) > 3 AND AVG(e.salary) > 55000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id) AS item_count, (SELECT AVG(oi2.price) FROM order_items oi2 WHERE oi2.order_id = o.id) AS avg_price FROM orders o) t WHERE item_count > 5 AND avg_price > 100;", "output": "SELECT o.id, COUNT(oi.id) AS item_count, AVG(oi.price) AS avg_price FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING COUNT(oi.id) > 5 AND AVG(oi.price) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(t.id) FROM tasks t WHERE t.employee_id = e.id AND t.status = 'done') AS done_tasks, (SELECT COUNT(t2.id) FROM tasks t2 WHERE t2.employee_id = e.id AND t2.status = 'in_progress') AS in_progress_tasks FROM employees e) t WHERE done_tasks > 5 AND in_progress_tasks < 3;", "output": "SELECT e.id, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS done_tasks, COUNT(CASE WHEN t.status = 'in_progress' THEN 1 END) AS in_progress_tasks FROM employees e LEFT JOIN tasks t ON t.employee_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN t.status = 'done' THEN 1 END) > 5 AND COUNT(CASE WHEN t.status = 'in_progress' THEN 1 END) < 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id AND o.status = 'completed') AS completed_total, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.customer_id = c.id) AS total_refunds FROM customers c) t WHERE completed_total - total_refunds > 5000;", "output": "SELECT c.id, SUM(CASE WHEN o.status = 'completed' THEN o.amount END) AS completed_total, SUM(r.refund_amount) AS total_refunds FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(CASE WHEN o.status = 'completed' THEN o.amount END) - SUM(r.refund_amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id) AS review_count, (SELECT MAX(r2.date) FROM reviews r2 WHERE r2.product_id = p.id) AS last_review FROM products p) t WHERE review_count > 0;", "output": "SELECT p.id, COUNT(r.id) AS review_count, MAX(r.date) AS last_review FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(r.id) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(s.salary) FROM salaries s WHERE s.employee_id = e.id) AS total_salary, (SELECT AVG(s2.salary) FROM salaries s2 WHERE s2.employee_id = e.id) AS avg_salary FROM employees e) t WHERE total_salary > 100000 AND avg_salary > 40000;", "output": "SELECT e.id, SUM(s.salary) AS total_salary, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN salaries s ON s.employee_id = e.id GROUP BY e.id HAVING SUM(s.salary) > 100000 AND AVG(s.salary) > 40000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.salary > 70000) AS high_salary_count, (SELECT SUM(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS total_salary FROM departments d) t WHERE high_salary_count > 2 AND total_salary > 200000;", "output": "SELECT d.id, COUNT(CASE WHEN e.salary > 70000 THEN 1 END) AS high_salary_count, SUM(e.salary) AS total_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.salary > 70000 THEN 1 END) > 2 AND SUM(e.salary) > 200000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id) AS order_count, (SELECT MAX(p.amount) FROM payments p WHERE p.customer_id = c.id) AS max_payment FROM customers c) t WHERE order_count > 3 AND max_payment > 1000;", "output": "SELECT c.id, COUNT(o.id) AS order_count, MAX(p.amount) AS max_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id HAVING COUNT(o.id) > 3 AND MAX(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(pr.id) FROM projects pr WHERE pr.manager_id = e.id) AS managed_projects, (SELECT SUM(pr2.budget) FROM projects pr2 WHERE pr2.manager_id = e.id) AS total_budget FROM employees e) t WHERE managed_projects > 1 AND total_budget > 150000;", "output": "SELECT e.id, COUNT(pr.id) AS managed_projects, SUM(pr.budget) AS total_budget FROM employees e LEFT JOIN projects pr ON pr.manager_id = e.id GROUP BY e.id HAVING COUNT(pr.id) > 1 AND SUM(pr.budget) > 150000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(t.id) FROM tasks t WHERE t.employee_id = e.id AND t.status = 'done') AS done_tasks, (SELECT COUNT(t2.id) FROM tasks t2 WHERE t2.employee_id = e.id AND t2.status = 'open') AS open_tasks FROM employees e) t WHERE done_tasks > 3 AND open_tasks < 5;", "output": "SELECT e.id, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS done_tasks, COUNT(CASE WHEN t.status = 'open' THEN 1 END) AS open_tasks FROM employees e LEFT JOIN tasks t ON t.employee_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN t.status = 'done' THEN 1 END) > 3 AND COUNT(CASE WHEN t.status = 'open' THEN 1 END) < 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id) AS total_orders, (SELECT SUM(r.amount) FROM refunds r WHERE r.customer_id = c.id) AS total_refunds FROM customers c) t WHERE total_orders - total_refunds > 10000;", "output": "SELECT c.id, SUM(o.amount) AS total_orders, SUM(r.amount) AS total_refunds FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(o.amount) - SUM(r.amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT MAX(e.salary) FROM employees e WHERE e.department_id = d.id) AS max_salary, (SELECT MIN(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS min_salary FROM departments d) t WHERE max_salary > 120000 AND min_salary < 25000;", "output": "SELECT d.id, MAX(e.salary) AS max_salary, MIN(e.salary) AS min_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING MAX(e.salary) > 120000 AND MIN(e.salary) < 25000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id AND oi.quantity > 5) AS bulk_items, (SELECT SUM(oi2.price*oi2.quantity) FROM order_items oi2 WHERE oi2.order_id = o.id) AS total_value FROM orders o) t WHERE bulk_items > 1 AND total_value > 2000;", "output": "SELECT o.id, COUNT(CASE WHEN oi.quantity > 5 THEN 1 END) AS bulk_items, SUM(oi.price*oi.quantity) AS total_value FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING COUNT(CASE WHEN oi.quantity > 5 THEN 1 END) > 1 AND SUM(oi.price*oi.quantity) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT AVG(p.amount) FROM payments p WHERE p.employee_id = e.id) AS avg_payment, (SELECT COUNT(p2.id) FROM payments p2 WHERE p2.employee_id = e.id) AS payment_count FROM employees e) t WHERE avg_payment > 300 AND payment_count > 2;", "output": "SELECT e.id, AVG(p.amount) AS avg_payment, COUNT(p.id) AS payment_count FROM employees e LEFT JOIN payments p ON p.employee_id = e.id GROUP BY e.id HAVING AVG(p.amount) > 300 AND COUNT(p.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id) AS order_count, (SELECT AVG(r.rating) FROM reviews r WHERE r.customer_id = c.id) AS avg_rating FROM customers c) t WHERE order_count > 5 AND avg_rating > 4;", "output": "SELECT c.id, COUNT(o.id) AS order_count, AVG(r.rating) AS avg_rating FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id HAVING COUNT(o.id) > 5 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id AND r.rating = 1) AS one_star, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.product_id = p.id AND r2.rating = 5) AS five_star FROM products p) t WHERE five_star > one_star;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 1 THEN 1 END) AS one_star, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > COUNT(CASE WHEN r.rating = 1 THEN 1 END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(b.amount) FROM bonuses b WHERE b.employee_id = e.id) AS total_bonus, (SELECT COUNT(b2.id) FROM bonuses b2 WHERE b2.employee_id = e.id) AS bonus_count FROM employees e) t WHERE total_bonus > 500 AND bonus_count > 2;", "output": "SELECT e.id, SUM(b.amount) AS total_bonus, COUNT(b.id) AS bonus_count FROM employees e LEFT JOIN bonuses b ON b.employee_id = e.id GROUP BY e.id HAVING SUM(b.amount) > 500 AND COUNT(b.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.hire_date > '2022-01-01') AS new_hires, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE new_hires > 1 AND avg_salary > 45000;", "output": "SELECT d.id, COUNT(CASE WHEN e.hire_date > '2022-01-01' THEN 1 END) AS new_hires, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.hire_date > '2022-01-01' THEN 1 END) > 1 AND AVG(e.salary) > 45000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id AND o.status = 'completed') AS completed_total, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.customer_id = c.id) AS total_refunds FROM customers c) t WHERE completed_total - total_refunds > 2000;", "output": "SELECT c.id, SUM(CASE WHEN o.status = 'completed' THEN o.amount END) AS completed_total, SUM(r.refund_amount) AS total_refunds FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(CASE WHEN o.status = 'completed' THEN o.amount END) - SUM(r.refund_amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id) AS review_count, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.id) AS avg_rating FROM products p) t WHERE review_count > 15 AND avg_rating > 3;", "output": "SELECT p.id, COUNT(r.id) AS review_count, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(r.id) > 15 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(h.hours) FROM hours h WHERE h.employee_id = e.id) AS total_hours, (SELECT MAX(h2.date) FROM hours h2 WHERE h2.employee_id = e.id) AS last_entry FROM employees e) t WHERE total_hours > 80;", "output": "SELECT e.id, SUM(h.hours) AS total_hours, MAX(h.date) AS last_entry FROM employees e LEFT JOIN hours h ON h.employee_id = e.id GROUP BY e.id HAVING SUM(h.hours) > 80;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT SUM(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS total_salary FROM departments d) t WHERE emp_count > 8 AND total_salary > 250000;", "output": "SELECT d.id, COUNT(e.id) AS emp_count, SUM(e.salary) AS total_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(e.id) > 8 AND SUM(e.salary) > 250000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT MAX(o.order_date) FROM orders o WHERE o.customer_id = c.id) AS last_order, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = c.id) AS total_paid FROM customers c) t WHERE total_paid > 3000;", "output": "SELECT c.id, MAX(o.order_date) AS last_order, SUM(p.amount) AS total_paid FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id HAVING SUM(p.amount) > 3000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(pr.id) FROM projects pr WHERE pr.manager_id = e.id) AS managed_projects, (SELECT SUM(pr2.budget) FROM projects pr2 WHERE pr2.manager_id = e.id) AS total_budget FROM employees e) t WHERE managed_projects > 2 AND total_budget > 100000;", "output": "SELECT e.id, COUNT(pr.id) AS managed_projects, SUM(pr.budget) AS total_budget FROM employees e LEFT JOIN projects pr ON pr.manager_id = e.id GROUP BY e.id HAVING COUNT(pr.id) > 2 AND SUM(pr.budget) > 100000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id AND r.rating = 5) AS five_star_reviews, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.product_id = p.id) AS total_reviews FROM products p) t WHERE five_star_reviews > 5 AND total_reviews > 15;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, COUNT(r.id) AS total_reviews FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 5 AND COUNT(r.id) > 15;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.id) AS avg_salary, (SELECT COUNT(s2.id) FROM salaries s2 WHERE s2.employee_id = e.id) AS salary_count FROM employees e) t WHERE avg_salary > 40000 AND salary_count > 1;", "output": "SELECT e.id, AVG(s.salary) AS avg_salary, COUNT(s.id) AS salary_count FROM employees e LEFT JOIN salaries s ON s.employee_id = e.id GROUP BY e.id HAVING AVG(s.salary) > 40000 AND COUNT(s.id) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(t.id) FROM tickets t WHERE t.customer_id = c.id AND t.status = 'open') AS open_tickets, (SELECT COUNT(t2.id) FROM tickets t2 WHERE t2.customer_id = c.id AND t2.status = 'closed') AS closed_tickets FROM customers c) t WHERE open_tickets > 0 AND closed_tickets > 2;", "output": "SELECT c.id, COUNT(CASE WHEN t.status = 'open' THEN 1 END) AS open_tickets, COUNT(CASE WHEN t.status = 'closed' THEN 1 END) AS closed_tickets FROM customers c LEFT JOIN tickets t ON t.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN t.status = 'open' THEN 1 END) > 0 AND COUNT(CASE WHEN t.status = 'closed' THEN 1 END) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id) AS item_count, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE item_count > 3 AND total_paid > 800;", "output": "SELECT o.id, COUNT(oi.id) AS item_count, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING COUNT(oi.id) > 3 AND SUM(p.amount) > 800;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.salary > 60000) AS high_salary_count, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE high_salary_count > 2 AND avg_salary > 50000;", "output": "SELECT d.id, COUNT(CASE WHEN e.salary > 60000 THEN 1 END) AS high_salary_count, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.salary > 60000 THEN 1 END) > 2 AND AVG(e.salary) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(pr.id) FROM projects pr WHERE pr.lead_id = e.id) AS lead_projects, (SELECT COUNT(pr2.id) FROM projects pr2 WHERE pr2.member_id = e.id) AS member_projects FROM employees e) t WHERE lead_projects > 1 AND member_projects > 3;", "output": "SELECT e.id, COUNT(CASE WHEN pr.lead_id = e.id THEN 1 END) AS lead_projects, COUNT(CASE WHEN pr.member_id = e.id THEN 1 END) AS member_projects FROM employees e LEFT JOIN projects pr ON pr.lead_id = e.id OR pr.member_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN pr.lead_id = e.id THEN 1 END) > 1 AND COUNT(CASE WHEN pr.member_id = e.id THEN 1 END) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id) AS total_spent, (SELECT COUNT(r.id) FROM returns r WHERE r.customer_id = c.id) AS return_count FROM customers c) t WHERE total_spent > 5000 AND return_count < 5;", "output": "SELECT c.id, SUM(o.amount) AS total_spent, COUNT(r.id) AS return_count FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN returns r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(o.amount) > 5000 AND COUNT(r.id) < 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id) AS review_count, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.id) AS avg_rating FROM products p) t WHERE review_count > 20 AND avg_rating > 4;", "output": "SELECT p.id, COUNT(r.id) AS review_count, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(r.id) > 20 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(p.amount) FROM payments p WHERE p.employee_id = e.id) AS total_payments, (SELECT MAX(p2.date) FROM payments p2 WHERE p2.employee_id = e.id) AS last_payment FROM employees e) t WHERE total_payments > 1000;", "output": "SELECT e.id, SUM(p.amount) AS total_payments, MAX(p.date) AS last_payment FROM employees e LEFT JOIN payments p ON p.employee_id = e.id GROUP BY e.id HAVING SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE emp_count > 15 AND avg_salary > 50000;", "output": "SELECT d.id, COUNT(e.id) AS emp_count, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(e.id) > 15 AND AVG(e.salary) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id) AS item_count, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE item_count > 2 AND total_paid > 300;", "output": "SELECT o.id, COUNT(oi.id) AS item_count, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING COUNT(oi.id) > 2 AND SUM(p.amount) > 300;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(c.id) FROM certifications c WHERE c.employee_id = e.id) AS cert_count, (SELECT MAX(c2.valid_until) FROM certifications c2 WHERE c2.employee_id = e.id) AS last_cert FROM employees e) t WHERE cert_count > 2;", "output": "SELECT e.id, COUNT(c.id) AS cert_count, MAX(c.valid_until) AS last_cert FROM employees e LEFT JOIN certifications c ON c.employee_id = e.id GROUP BY e.id HAVING COUNT(c.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT MAX(o.order_date) FROM orders o WHERE o.customer_id = c.id) AS last_order, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = c.id) AS total_paid FROM customers c) t WHERE total_paid > 4000;", "output": "SELECT c.id, MAX(o.order_date) AS last_order, SUM(p.amount) AS total_paid FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id HAVING SUM(p.amount) > 4000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id AND r.rating = 5) AS five_star_reviews, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.product_id = p.id) AS total_reviews FROM products p) t WHERE five_star_reviews > 8 AND total_reviews > 20;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, COUNT(r.id) AS total_reviews FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 8 AND COUNT(r.id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(h.hours) FROM hours h WHERE h.employee_id = e.id) AS total_hours, (SELECT AVG(h2.hours) FROM hours h2 WHERE h2.employee_id = e.id) AS avg_hours FROM employees e) t WHERE total_hours > 150 AND avg_hours > 5;", "output": "SELECT e.id, SUM(h.hours) AS total_hours, AVG(h.hours) AS avg_hours FROM employees e LEFT JOIN hours h ON h.employee_id = e.id GROUP BY e.id HAVING SUM(h.hours) > 150 AND AVG(h.hours) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.salary > 60000) AS high_salary_count, (SELECT SUM(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS total_salary FROM departments d) t WHERE high_salary_count > 2 AND total_salary > 300000;", "output": "SELECT d.id, COUNT(CASE WHEN e.salary > 60000 THEN 1 END) AS high_salary_count, SUM(e.salary) AS total_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.salary > 60000 THEN 1 END) > 2 AND SUM(e.salary) > 300000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id AND o.status = 'pending') AS pending_orders, (SELECT COUNT(o2.id) FROM orders o2 WHERE o2.customer_id = c.id AND o2.status = 'completed') AS completed_orders FROM customers c) t WHERE pending_orders > 0 AND completed_orders > 10;", "output": "SELECT c.id, COUNT(CASE WHEN o.status = 'pending' THEN 1 END) AS pending_orders, COUNT(CASE WHEN o.status = 'completed' THEN 1 END) AS completed_orders FROM customers c LEFT JOIN orders o ON o.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN o.status = 'pending' THEN 1 END) > 0 AND COUNT(CASE WHEN o.status = 'completed' THEN 1 END) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id AND oi.price > 50) AS expensive_items, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE expensive_items > 1 AND total_paid > 500;", "output": "SELECT o.id, COUNT(CASE WHEN oi.price > 50 THEN 1 END) AS expensive_items, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING COUNT(CASE WHEN oi.price > 50 THEN 1 END) > 1 AND SUM(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(t.id) FROM tasks t WHERE t.employee_id = e.id AND t.status = 'done') AS done_tasks, (SELECT COUNT(t2.id) FROM tasks t2 WHERE t2.employee_id = e.id AND t2.status = 'in_progress') AS in_progress_tasks FROM employees e) t WHERE done_tasks > 4 AND in_progress_tasks < 3;", "output": "SELECT e.id, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS done_tasks, COUNT(CASE WHEN t.status = 'in_progress' THEN 1 END) AS in_progress_tasks FROM employees e LEFT JOIN tasks t ON t.employee_id = e.id GROUP BY e.id HAVING COUNT(CASE WHEN t.status = 'done' THEN 1 END) > 4 AND COUNT(CASE WHEN t.status = 'in_progress' THEN 1 END) < 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT AVG(r.rating) FROM reviews r WHERE r.customer_id = c.id) AS avg_rating, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.customer_id = c.id) AS review_count FROM customers c) t WHERE avg_rating > 3.5 AND review_count > 5;", "output": "SELECT c.id, AVG(r.rating) AS avg_rating, COUNT(r.id) AS review_count FROM customers c LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id HAVING AVG(r.rating) > 3.5 AND COUNT(r.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id AND r.rating = 5) AS five_star_reviews, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.id) AS avg_rating FROM products p) t WHERE five_star_reviews > 10 AND avg_rating > 4;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 10 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(b.amount) FROM bonuses b WHERE b.employee_id = e.id) AS total_bonus, (SELECT MAX(b2.date) FROM bonuses b2 WHERE b2.employee_id = e.id) AS last_bonus FROM employees e) t WHERE total_bonus > 2000;", "output": "SELECT e.id, SUM(b.amount) AS total_bonus, MAX(b.date) AS last_bonus FROM employees e LEFT JOIN bonuses b ON b.employee_id = e.id GROUP BY e.id HAVING SUM(b.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id) AS emp_count, (SELECT MIN(e2.hire_date) FROM employees e2 WHERE e2.department_id = d.id) AS earliest_hire FROM departments d) t WHERE emp_count > 10;", "output": "SELECT d.id, COUNT(e.id) AS emp_count, MIN(e.hire_date) AS earliest_hire FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(e.id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT SUM(oi.price*oi.quantity) FROM order_items oi WHERE oi.order_id = o.id) AS order_value, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.id) AS total_paid FROM orders o) t WHERE order_value > 1200 AND total_paid < order_value;", "output": "SELECT o.id, SUM(oi.price*oi.quantity) AS order_value, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id LEFT JOIN payments p ON p.order_id = o.id GROUP BY o.id HAVING SUM(oi.price*oi.quantity) > 1200 AND SUM(p.amount) < SUM(oi.price*oi.quantity);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(pr.id) FROM projects pr WHERE pr.manager_id = e.id) AS managed_projects, (SELECT SUM(pr2.budget) FROM projects pr2 WHERE pr2.manager_id = e.id) AS total_budget FROM employees e) t WHERE managed_projects > 2 AND total_budget > 150000;", "output": "SELECT e.id, COUNT(pr.id) AS managed_projects, SUM(pr.budget) AS total_budget FROM employees e LEFT JOIN projects pr ON pr.manager_id = e.id GROUP BY e.id HAVING COUNT(pr.id) > 2 AND SUM(pr.budget) > 150000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id AND o.status = 'completed') AS completed_orders, (SELECT AVG(r.rating) FROM reviews r WHERE r.customer_id = c.id) AS avg_rating FROM customers c) t WHERE completed_orders > 10 AND avg_rating > 4;", "output": "SELECT c.id, COUNT(CASE WHEN o.status = 'completed' THEN 1 END) AS completed_orders, AVG(r.rating) AS avg_rating FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN o.status = 'completed' THEN 1 END) > 10 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT SUM(e.salary) FROM employees e WHERE e.department_id = d.id) AS total_salary, (SELECT COUNT(e2.id) FROM employees e2 WHERE e2.department_id = d.id AND e2.salary > 60000) AS high_salary_count FROM departments d) t WHERE total_salary > 500000 AND high_salary_count > 3;", "output": "SELECT d.id, SUM(e.salary) AS total_salary, COUNT(CASE WHEN e.salary > 60000 THEN 1 END) AS high_salary_count FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING SUM(e.salary) > 500000 AND COUNT(CASE WHEN e.salary > 60000 THEN 1 END) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.product_id = p.id AND r.rating = 1) AS one_star_reviews, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.product_id = p.id AND r2.rating = 5) AS five_star_reviews FROM products p) t WHERE five_star_reviews > one_star_reviews;", "output": "SELECT p.id, COUNT(CASE WHEN r.rating = 1 THEN 1 END) AS one_star_reviews, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews FROM products p LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > COUNT(CASE WHEN r.rating = 1 THEN 1 END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(p.amount) FROM payments p WHERE p.employee_id = e.id) AS total_payment, (SELECT COUNT(p2.id) FROM payments p2 WHERE p2.employee_id = e.id) AS payment_count FROM employees e) t WHERE total_payment > 2000 AND payment_count > 2;", "output": "SELECT e.id, SUM(p.amount) AS total_payment, COUNT(p.id) AS payment_count FROM employees e LEFT JOIN payments p ON p.employee_id = e.id GROUP BY e.id HAVING SUM(p.amount) > 2000 AND COUNT(p.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(t.id) FROM tickets t WHERE t.customer_id = c.id AND t.status = 'open') AS open_tickets, (SELECT COUNT(t2.id) FROM tickets t2 WHERE t2.customer_id = c.id AND t2.status = 'closed') AS closed_tickets FROM customers c) t WHERE open_tickets > 1 AND closed_tickets > 3;", "output": "SELECT c.id, COUNT(CASE WHEN t.status = 'open' THEN 1 END) AS open_tickets, COUNT(CASE WHEN t.status = 'closed' THEN 1 END) AS closed_tickets FROM customers c LEFT JOIN tickets t ON t.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN t.status = 'open' THEN 1 END) > 1 AND COUNT(CASE WHEN t.status = 'closed' THEN 1 END) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT SUM(oi.price*oi.quantity) FROM order_items oi WHERE oi.order_id = o.id) AS order_value, (SELECT COUNT(oi2.id) FROM order_items oi2 WHERE oi2.order_id = o.id AND oi2.quantity > 10) AS bulk_items FROM orders o) t WHERE order_value > 1000 AND bulk_items > 0;", "output": "SELECT o.id, SUM(oi.price*oi.quantity) AS order_value, COUNT(CASE WHEN oi.quantity > 10 THEN 1 END) AS bulk_items FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING SUM(oi.price*oi.quantity) > 1000 AND COUNT(CASE WHEN oi.quantity > 10 THEN 1 END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT MAX(s.salary) FROM salaries s WHERE s.employee_id = e.id) AS max_salary, (SELECT MIN(s2.salary) FROM salaries s2 WHERE s2.employee_id = e.id) AS min_salary FROM employees e) t WHERE max_salary > 80000 AND min_salary > 20000;", "output": "SELECT e.id, MAX(s.salary) AS max_salary, MIN(s.salary) AS min_salary FROM employees e LEFT JOIN salaries s ON s.employee_id = e.id GROUP BY e.id HAVING MAX(s.salary) > 80000 AND MIN(s.salary) > 20000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(o.id) FROM orders o WHERE o.customer_id = c.id) AS order_count, (SELECT AVG(p.amount) FROM payments p WHERE p.customer_id = c.id) AS avg_payment FROM customers c) t WHERE order_count > 10 AND avg_payment > 500;", "output": "SELECT c.id, COUNT(o.id) AS order_count, AVG(p.amount) AS avg_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN payments p ON p.customer_id = c.id GROUP BY c.id HAVING COUNT(o.id) > 10 AND AVG(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.hire_date > '2021-01-01') AS new_hires, (SELECT AVG(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS avg_salary FROM departments d) t WHERE new_hires > 5 AND avg_salary > 45000;", "output": "SELECT d.id, COUNT(CASE WHEN e.hire_date > '2021-01-01' THEN 1 END) AS new_hires, AVG(e.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.hire_date > '2021-01-01' THEN 1 END) > 5 AND AVG(e.salary) > 45000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.customer_id, (SELECT COUNT(o2.id) FROM orders o2 WHERE o2.customer_id = o.customer_id AND o2.status = 'completed') AS completed_orders, (SELECT SUM(p.amount) FROM payments p WHERE p.customer_id = o.customer_id) AS total_paid FROM orders o) t WHERE completed_orders > 3 AND total_paid > 1500;", "output": "SELECT o.customer_id, COUNT(CASE WHEN o2.status = 'completed' THEN 1 END) AS completed_orders, SUM(p.amount) AS total_paid FROM orders o LEFT JOIN orders o2 ON o2.customer_id = o.customer_id LEFT JOIN payments p ON p.customer_id = o.customer_id GROUP BY o.customer_id HAVING COUNT(CASE WHEN o2.status = 'completed' THEN 1 END) > 3 AND SUM(p.amount) > 1500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(h.hours) FROM hours h WHERE h.employee_id = e.id) AS total_hours, (SELECT COUNT(h2.id) FROM hours h2 WHERE h2.employee_id = e.id) AS entry_count FROM employees e) t WHERE total_hours > 100 AND entry_count > 5;", "output": "SELECT e.id, SUM(h.hours) AS total_hours, COUNT(h.id) AS entry_count FROM employees e LEFT JOIN hours h ON h.employee_id = e.id GROUP BY e.id HAVING SUM(h.hours) > 100 AND COUNT(h.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT COUNT(r.id) FROM reviews r WHERE r.customer_id = c.id AND r.rating = 5) AS five_star_reviews, (SELECT COUNT(r2.id) FROM reviews r2 WHERE r2.customer_id = c.id) AS total_reviews FROM customers c) t WHERE five_star_reviews > 2 AND total_reviews > 5;", "output": "SELECT c.id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, COUNT(r.id) AS total_reviews FROM customers c LEFT JOIN reviews r ON r.customer_id = c.id GROUP BY c.id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 2 AND COUNT(r.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.id, (SELECT COUNT(e.id) FROM employees e WHERE e.department_id = d.id AND e.salary > 70000) AS high_salary_count, (SELECT SUM(e2.salary) FROM employees e2 WHERE e2.department_id = d.id) AS total_salary FROM departments d) t WHERE high_salary_count > 2 AND total_salary > 200000;", "output": "SELECT d.id, COUNT(CASE WHEN e.salary > 70000 THEN 1 END) AS high_salary_count, SUM(e.salary) AS total_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.id GROUP BY d.id HAVING COUNT(CASE WHEN e.salary > 70000 THEN 1 END) > 2 AND SUM(e.salary) > 200000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.id, (SELECT SUM(oi.quantity) FROM order_items oi WHERE oi.product_id = p.id) AS total_sold, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = p.id) AS avg_rating FROM products p) t WHERE total_sold > 500 AND avg_rating > 3.5;", "output": "SELECT p.id, SUM(oi.quantity) AS total_sold, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN order_items oi ON oi.product_id = p.id LEFT JOIN reviews r ON r.product_id = p.id GROUP BY p.id HAVING SUM(oi.quantity) > 500 AND AVG(r.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(c.id) FROM certifications c WHERE c.employee_id = e.id) AS cert_count, (SELECT MAX(c2.valid_until) FROM certifications c2 WHERE c2.employee_id = e.id) AS last_cert FROM employees e) t WHERE cert_count > 1;", "output": "SELECT e.id, COUNT(c.id) AS cert_count, MAX(c.valid_until) AS last_cert FROM employees e LEFT JOIN certifications c ON c.employee_id = e.id GROUP BY e.id HAVING COUNT(c.id) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id AND o.status = 'completed') AS completed_total, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.customer_id = c.id) AS total_refunds FROM customers c) t WHERE completed_total - total_refunds > 3000;", "output": "SELECT c.id, SUM(CASE WHEN o.status = 'completed' THEN o.amount END) AS completed_total, SUM(r.refund_amount) AS total_refunds FROM customers c LEFT JOIN orders o ON o.customer_id = c.id LEFT JOIN refunds r ON r.customer_id = c.id GROUP BY c.id HAVING SUM(CASE WHEN o.status = 'completed' THEN o.amount END) - SUM(r.refund_amount) > 3000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT COUNT(oi.id) FROM order_items oi WHERE oi.order_id = o.id AND oi.price > 100) AS expensive_items, (SELECT SUM(oi2.price*oi2.quantity) FROM order_items oi2 WHERE oi2.order_id = o.id) AS total_value FROM orders o) t WHERE expensive_items > 0 AND total_value > 200;", "output": "SELECT o.id, COUNT(CASE WHEN oi.price > 100 THEN 1 END) AS expensive_items, SUM(oi.price*oi.quantity) AS total_value FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING COUNT(CASE WHEN oi.price > 100 THEN 1 END) > 0 AND SUM(oi.price*oi.quantity) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(pr.id) FROM projects pr WHERE pr.manager_id = e.id) AS managed_projects, (SELECT SUM(pr2.budget) FROM projects pr2 WHERE pr2.manager_id = e.id) AS total_budget FROM employees e) t WHERE managed_projects > 1 AND total_budget > 120000;", "output": "SELECT e.id, COUNT(pr.id) AS managed_projects, SUM(pr.budget) AS total_budget FROM employees e LEFT JOIN projects pr ON pr.manager_id = e.id GROUP BY e.id HAVING COUNT(pr.id) > 1 AND SUM(pr.budget) > 120000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT i.invoice_id, (SELECT SUM(il.line_total) FROM invoice_lines il WHERE il.invoice_id = i.invoice_id) AS total_amount, (SELECT MAX(p.payment_date) FROM payments p WHERE p.invoice_id = i.invoice_id) AS last_payment_date FROM invoices i) t WHERE total_amount > 1000 AND last_payment_date IS NOT NULL;", "output": "SELECT i.invoice_id, SUM(il.line_total) AS total_amount, MAX(p.payment_date) AS last_payment_date FROM invoices i LEFT JOIN invoice_lines il ON il.invoice_id = i.invoice_id LEFT JOIN payments p ON p.invoice_id = i.invoice_id GROUP BY i.invoice_id HAVING SUM(il.line_total) > 1000 AND MAX(p.payment_date) IS NOT NULL;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.shipment_id, (SELECT COUNT(sp.id) FROM shipment_packages sp WHERE sp.shipment_id = s.shipment_id) AS package_count, (SELECT SUM(sp2.weight) FROM shipment_packages sp2 WHERE sp2.shipment_id = s.shipment_id) AS total_weight FROM shipments s) t WHERE package_count > 5 AND total_weight > 100;", "output": "SELECT s.shipment_id, COUNT(sp.id) AS package_count, SUM(sp.weight) AS total_weight FROM shipments s LEFT JOIN shipment_packages sp ON sp.shipment_id = s.shipment_id GROUP BY s.shipment_id HAVING COUNT(sp.id) > 5 AND SUM(sp.weight) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT u.user_id, u.username FROM users u WHERE EXISTS (SELECT * FROM sessions s WHERE s.user_id = u.user_id AND s.last_active > NOW() - INTERVAL '7 day') AND u.user_id IN (SELECT f.user_id FROM features f WHERE f.enabled = true);", "output": "SELECT DISTINCT u.user_id, u.username FROM users u JOIN sessions s ON s.user_id = u.user_id JOIN features f ON f.user_id = u.user_id WHERE s.last_active > NOW() - INTERVAL '7 day' AND f.enabled = true;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.article_id, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.article_id = a.article_id) AS comment_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.article_id = a.article_id) AS avg_rating FROM articles a) t WHERE comment_count > 50 AND avg_rating > 3.5;", "output": "SELECT a.article_id, COUNT(c.comment_id) AS comment_count, AVG(r.rating) AS avg_rating FROM articles a LEFT JOIN comments c ON c.article_id = a.article_id LEFT JOIN ratings r ON r.article_id = a.article_id GROUP BY a.article_id HAVING COUNT(c.comment_id) > 50 AND AVG(r.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT e.event_id, e.event_name FROM events e WHERE e.event_id IN (SELECT DISTINCT t.event_id FROM tickets t WHERE t.purchase_date > '2023-01-01') AND EXISTS (SELECT 1 FROM organizers o WHERE o.organizer_id = e.organizer_id AND o.active = true);", "output": "SELECT DISTINCT e.event_id, e.event_name FROM events e JOIN tickets t ON t.event_id = e.event_id JOIN organizers o ON o.organizer_id = e.organizer_id WHERE t.purchase_date > '2023-01-01' AND o.active = true;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sub.id, (SELECT SUM(p.amount) FROM subscription_payments p WHERE p.subscription_id = sub.id) AS total_paid, (SELECT MAX(p2.payment_date) FROM subscription_payments p2 WHERE p2.subscription_id = sub.id) AS last_payment FROM subscriptions sub) t WHERE total_paid > 200 AND last_payment > '2023-06-01';", "output": "SELECT sub.id, SUM(p.amount) AS total_paid, MAX(p.payment_date) AS last_payment FROM subscriptions sub LEFT JOIN subscription_payments p ON p.subscription_id = sub.id GROUP BY sub.id HAVING SUM(p.amount) > 200 AND MAX(p.payment_date) > '2023-06-01';"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.session_id, (SELECT COUNT(l.id) FROM logs l WHERE l.session_id = s.session_id AND l.level = 'ERROR') AS error_logs, (SELECT COUNT(l2.id) FROM logs l2 WHERE l2.session_id = s.session_id AND l2.level = 'WARNING') AS warning_logs FROM sessions s) t WHERE error_logs > 5 OR warning_logs > 10;", "output": "SELECT s.session_id, COUNT(CASE WHEN l.level = 'ERROR' THEN 1 END) AS error_logs, COUNT(CASE WHEN l.level = 'WARNING' THEN 1 END) AS warning_logs FROM sessions s LEFT JOIN logs l ON l.session_id = s.session_id GROUP BY s.session_id HAVING COUNT(CASE WHEN l.level = 'ERROR' THEN 1 END) > 5 OR COUNT(CASE WHEN l.level = 'WARNING' THEN 1 END) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.project_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = p.project_id AND t.status = 'done') AS completed_tasks, (SELECT SUM(t2.estimated_hours) FROM tasks t2 WHERE t2.project_id = p.project_id) AS estimated_hours FROM projects p) t WHERE completed_tasks > 10 AND estimated_hours > 500;", "output": "SELECT p.project_id, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS completed_tasks, SUM(t.estimated_hours) AS estimated_hours FROM projects p LEFT JOIN tasks t ON t.project_id = p.project_id GROUP BY p.project_id HAVING COUNT(CASE WHEN t.status = 'done' THEN 1 END) > 10 AND SUM(t.estimated_hours) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.id, (SELECT COUNT(m.id) FROM messages m WHERE m.sender_id = u.id) AS sent_messages, (SELECT COUNT(m2.id) FROM messages m2 WHERE m2.receiver_id = u.id) AS received_messages FROM users u) t WHERE sent_messages > 100 AND received_messages > 200;", "output": "SELECT u.id, COUNT(m.id) FILTER (WHERE m.sender_id = u.id) AS sent_messages, COUNT(m.id) FILTER (WHERE m.receiver_id = u.id) AS received_messages FROM users u LEFT JOIN messages m ON m.sender_id = u.id OR m.receiver_id = u.id GROUP BY u.id HAVING COUNT(m.id) FILTER (WHERE m.sender_id = u.id) > 100 AND COUNT(m.id) FILTER (WHERE m.receiver_id = u.id) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(p.amount) FROM payments p WHERE p.order_id = o.order_id) AS paid, (SELECT SUM(r.refund_amount) FROM refunds r WHERE r.order_id = o.order_id) AS refunded FROM orders o) t WHERE paid - refunded > 100;", "output": "SELECT o.order_id, SUM(p.amount) AS paid, SUM(r.refund_amount) AS refunded FROM orders o LEFT JOIN payments p ON p.order_id = o.order_id LEFT JOIN refunds r ON r.order_id = o.order_id GROUP BY o.order_id HAVING SUM(p.amount) - SUM(r.refund_amount) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.emp_id, (SELECT COUNT(a.attendance_id) FROM attendance a WHERE a.emp_id = e.emp_id AND a.status = 'present') AS present_days, (SELECT COUNT(a2.attendance_id) FROM attendance a2 WHERE a2.emp_id = e.emp_id AND a2.status = 'absent') AS absent_days FROM employees e) t WHERE present_days > 200 AND absent_days < 20;", "output": "SELECT e.emp_id, COUNT(CASE WHEN a.status = 'present' THEN 1 END) AS present_days, COUNT(CASE WHEN a.status = 'absent' THEN 1 END) AS absent_days FROM employees e LEFT JOIN attendance a ON a.emp_id = e.emp_id GROUP BY e.emp_id HAVING COUNT(CASE WHEN a.status = 'present' THEN 1 END) > 200 AND COUNT(CASE WHEN a.status = 'absent' THEN 1 END) < 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.cart_id, (SELECT COUNT(ci.item_id) FROM cart_items ci WHERE ci.cart_id = c.cart_id) AS item_count, (SELECT SUM(ci2.price*ci2.qty) FROM cart_items ci2 WHERE ci2.cart_id = c.cart_id) AS cart_value FROM carts c) t WHERE item_count > 3 AND cart_value > 100;", "output": "SELECT c.cart_id, COUNT(ci.item_id) AS item_count, SUM(ci.price*ci.qty) AS cart_value FROM carts c LEFT JOIN cart_items ci ON ci.cart_id = c.cart_id GROUP BY c.cart_id HAVING COUNT(ci.item_id) > 3 AND SUM(ci.price*ci.qty) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.id, (SELECT COUNT(a.id) FROM attendees a WHERE a.event_id = ev.id) AS attendees_count, (SELECT MAX(a2.registered_at) FROM attendees a2 WHERE a2.event_id = ev.id) AS last_registered FROM events ev) t WHERE attendees_count > 50;", "output": "SELECT ev.id, COUNT(a.id) AS attendees_count, MAX(a.registered_at) AS last_registered FROM events ev LEFT JOIN attendees a ON a.event_id = ev.id GROUP BY ev.id HAVING COUNT(a.id) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.booking_id, (SELECT SUM(p.amount) FROM payments p WHERE p.booking_id = b.booking_id) AS total_paid, (SELECT COUNT(r.id) FROM reviews r WHERE r.booking_id = b.booking_id) AS review_count FROM bookings b) t WHERE total_paid > 500 AND review_count > 2;", "output": "SELECT b.booking_id, SUM(p.amount) AS total_paid, COUNT(r.id) AS review_count FROM bookings b LEFT JOIN payments p ON p.booking_id = b.booking_id LEFT JOIN reviews r ON r.booking_id = b.booking_id GROUP BY b.booking_id HAVING SUM(p.amount) > 500 AND COUNT(r.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.login_id) FROM logins l WHERE l.user_id = u.user_id AND l.success = true) AS successful_logins, (SELECT COUNT(l2.login_id) FROM logins l2 WHERE l2.user_id = u.user_id AND l2.success = false) AS failed_logins FROM users u) t WHERE successful_logins > 5 AND failed_logins < 3;", "output": "SELECT u.user_id, COUNT(CASE WHEN l.success = true THEN 1 END) AS successful_logins, COUNT(CASE WHEN l.success = false THEN 1 END) AS failed_logins FROM users u LEFT JOIN logins l ON l.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(CASE WHEN l.success = true THEN 1 END) > 5 AND COUNT(CASE WHEN l.success = false THEN 1 END) < 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT tr.transaction_id, (SELECT SUM(td.amount) FROM transaction_details td WHERE td.transaction_id = tr.transaction_id) AS total_amount, (SELECT COUNT(td2.id) FROM transaction_details td2 WHERE td2.transaction_id = tr.transaction_id AND td2.amount > 100) AS big_items FROM transactions tr) t WHERE total_amount > 1000 AND big_items > 2;", "output": "SELECT tr.transaction_id, SUM(td.amount) AS total_amount, COUNT(CASE WHEN td.amount > 100 THEN 1 END) AS big_items FROM transactions tr LEFT JOIN transaction_details td ON td.transaction_id = tr.transaction_id GROUP BY tr.transaction_id HAVING SUM(td.amount) > 1000 AND COUNT(CASE WHEN td.amount > 100 THEN 1 END) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade, (SELECT COUNT(g2.id) FROM grades g2 WHERE g2.student_id = s.student_id AND g2.grade < 60) AS failed_courses FROM students s) t WHERE avg_grade > 75 AND failed_courses < 3;", "output": "SELECT s.student_id, AVG(g.grade) AS avg_grade, COUNT(CASE WHEN g.grade < 60 THEN 1 END) AS failed_courses FROM students s LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING AVG(g.grade) > 75 AND COUNT(CASE WHEN g.grade < 60 THEN 1 END) < 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT v.vehicle_id, (SELECT COUNT(m.maintenance_id) FROM maintenance m WHERE m.vehicle_id = v.vehicle_id) AS maintenance_count, (SELECT MAX(m2.date) FROM maintenance m2 WHERE m2.vehicle_id = v.vehicle_id) AS last_maintenance FROM vehicles v) t WHERE maintenance_count > 2;", "output": "SELECT v.vehicle_id, COUNT(m.maintenance_id) AS maintenance_count, MAX(m.date) AS last_maintenance FROM vehicles v LEFT JOIN maintenance m ON m.vehicle_id = v.vehicle_id GROUP BY v.vehicle_id HAVING COUNT(m.maintenance_id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled_students, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled_students > 20 AND avg_grade > 70;", "output": "SELECT c.course_id, COUNT(e.id) AS enrolled_students, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.id) > 20 AND AVG(g.grade) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.product_id = p.product_id AND r.rating = 5) AS five_star_reviews, (SELECT SUM(oi.quantity) FROM order_items oi WHERE oi.product_id = p.product_id) AS total_sold FROM products p) t WHERE five_star_reviews > 10 AND total_sold > 500;", "output": "SELECT p.product_id, COUNT(CASE WHEN r.rating = 5 THEN 1 END) AS five_star_reviews, SUM(oi.quantity) AS total_sold FROM products p LEFT JOIN reviews r ON r.product_id = p.product_id LEFT JOIN order_items oi ON oi.product_id = p.product_id GROUP BY p.product_id HAVING COUNT(CASE WHEN r.rating = 5 THEN 1 END) > 10 AND SUM(oi.quantity) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM users WHERE email = 'test@example.com';", "output": "SELECT user_id, username, email FROM users WHERE email = 'test@example.com';"}
{"instruction": "Optimize the SQL query", "input": "SELECT order_id, customer_id, total FROM orders WHERE total > 1000 ORDER BY total DESC;", "output": "SELECT order_id, customer_id, total FROM orders WHERE total > 1000 ORDER BY total DESC LIMIT 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM employees;", "output": "SELECT * FROM employees;"}
{"instruction": "Optimize the SQL query", "input": "SELECT p.product_id, p.name, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.product_id = p.product_id) AS review_count FROM products p WHERE EXISTS (SELECT 1 FROM order_items oi WHERE oi.product_id = p.product_id);", "output": "SELECT p.product_id, p.name, COUNT(r.review_id) AS review_count FROM products p JOIN order_items oi ON oi.product_id = p.product_id LEFT JOIN reviews r ON r.product_id = p.product_id GROUP BY p.product_id, p.name;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(o.id) FROM orders o WHERE o.user_id = u.user_id) AS order_count, (SELECT MAX(o2.order_date) FROM orders o2 WHERE o2.user_id = u.user_id) AS last_order FROM users u) t WHERE order_count > 5;", "output": "SELECT u.user_id, COUNT(o.id) AS order_count, MAX(o.order_date) AS last_order FROM users u LEFT JOIN orders o ON o.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(o.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE avg_grade > 75;", "output": "SELECT s.student_id, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING AVG(g.grade) > 75;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT SUM(h.hours) FROM hours h WHERE h.employee_id = e.id) AS total_hours, (SELECT COUNT(p.id) FROM projects p WHERE p.lead_id = e.id) AS managed_projects FROM employees e) t WHERE total_hours > 200 AND managed_projects > 3;", "output": "SELECT e.id, SUM(h.hours) AS total_hours, COUNT(p.id) AS managed_projects FROM employees e LEFT JOIN hours h ON h.employee_id = e.id LEFT JOIN projects p ON p.lead_id = e.id GROUP BY e.id HAVING SUM(h.hours) > 200 AND COUNT(p.id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.id, (SELECT SUM(oi.price*oi.quantity) FROM order_items oi WHERE oi.order_id = o.id) AS total_value FROM orders o) t WHERE total_value > 500;", "output": "SELECT o.id, SUM(oi.price*oi.quantity) AS total_value FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.id GROUP BY o.id HAVING SUM(oi.price*oi.quantity) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.id, (SELECT COUNT(c.id) FROM certifications c WHERE c.employee_id = e.id) AS cert_count, (SELECT MAX(c.valid_until) FROM certifications c WHERE c.employee_id = e.id) AS last_cert FROM employees e) t WHERE cert_count > 1;", "output": "SELECT e.id, COUNT(c.id) AS cert_count, MAX(c.valid_until) AS last_cert FROM employees e LEFT JOIN certifications c ON c.employee_id = e.id GROUP BY e.id HAVING COUNT(c.id) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM payments WHERE amount > 100;", "output": "SELECT payment_id, order_id, amount, payment_date FROM payments WHERE amount > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.id, (SELECT COUNT(a.id) FROM attendees a WHERE a.event_id = ev.id) AS attendees_count, (SELECT MAX(a2.registered_at) FROM attendees a2 WHERE a2.event_id = ev.id) AS last_registered FROM events ev) t WHERE attendees_count > 100;", "output": "SELECT ev.id, COUNT(a.id) AS attendees_count, MAX(a.registered_at) AS last_registered FROM events ev LEFT JOIN attendees a ON a.event_id = ev.id GROUP BY ev.id HAVING COUNT(a.id) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM orders o WHERE o.customer_id IN (SELECT c.id FROM customers c WHERE c.country = 'USA');", "output": "SELECT o.* FROM orders o JOIN customers c ON c.id = o.customer_id WHERE c.country = 'USA';"}
{"instruction": "Optimize the SQL query", "input": "SELECT u.user_id, u.username, (SELECT COUNT(s.id) FROM sessions s WHERE s.user_id = u.user_id) AS sessions_count FROM users u WHERE u.status = 'active';", "output": "SELECT u.user_id, u.username, COUNT(s.id) AS sessions_count FROM users u LEFT JOIN sessions s ON s.user_id = u.user_id WHERE u.status = 'active' GROUP BY u.user_id, u.username;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM logs WHERE level = 'ERROR' ORDER BY created_at DESC;", "output": "SELECT log_id, message, level, created_at FROM logs WHERE level = 'ERROR' ORDER BY created_at DESC LIMIT 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.id, (SELECT SUM(o.amount) FROM orders o WHERE o.customer_id = c.id) AS total_spent, (SELECT MAX(o.order_date) FROM orders o WHERE o.customer_id = c.id) AS last_order FROM customers c) t WHERE total_spent > 1000;", "output": "SELECT c.id, SUM(o.amount) AS total_spent, MAX(o.order_date) AS last_order FROM customers c LEFT JOIN orders o ON o.customer_id = c.id GROUP BY c.id HAVING SUM(o.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM inventory;", "output": "SELECT * FROM inventory;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.shipment_id, (SELECT COUNT(sp.id) FROM shipment_packages sp WHERE sp.shipment_id = s.shipment_id) AS package_count FROM shipments s) t WHERE package_count > 5;", "output": "SELECT s.shipment_id, COUNT(sp.id) AS package_count FROM shipments s LEFT JOIN shipment_packages sp ON sp.shipment_id = s.shipment_id GROUP BY s.shipment_id HAVING COUNT(sp.id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.article_id, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.article_id = a.article_id) AS comment_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.article_id = a.article_id) AS avg_rating FROM articles a) t WHERE comment_count > 20 AND avg_rating > 4;", "output": "SELECT a.article_id, COUNT(c.comment_id) AS comment_count, AVG(r.rating) AS avg_rating FROM articles a LEFT JOIN comments c ON c.article_id = a.article_id LEFT JOIN ratings r ON r.article_id = a.article_id GROUP BY a.article_id HAVING COUNT(c.comment_id) > 20 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM sessions s WHERE EXISTS (SELECT 1 FROM logs l WHERE l.session_id = s.session_id AND l.level = 'ERROR');", "output": "SELECT DISTINCT s.* FROM sessions s JOIN logs l ON l.session_id = s.session_id WHERE l.level = 'ERROR';"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT v.vehicle_id, (SELECT COUNT(m.maintenance_id) FROM maintenance m WHERE m.vehicle_id = v.vehicle_id) AS maintenance_count, (SELECT MAX(m2.date) FROM maintenance m2 WHERE m2.vehicle_id = v.vehicle_id) AS last_maintenance FROM vehicles v) t WHERE maintenance_count > 2;", "output": "SELECT v.vehicle_id, COUNT(m.maintenance_id) AS maintenance_count, MAX(m.date) AS last_maintenance FROM vehicles v LEFT JOIN maintenance m ON m.vehicle_id = v.vehicle_id GROUP BY v.vehicle_id HAVING COUNT(m.maintenance_id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM tickets;", "output": "SELECT * FROM tickets;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.login_id) FROM logins l WHERE l.user_id = u.user_id AND l.success = true) AS successful_logins FROM users u) t WHERE successful_logins > 10;", "output": "SELECT u.user_id, COUNT(CASE WHEN l.success = true THEN 1 END) AS successful_logins FROM users u LEFT JOIN logins l ON l.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(CASE WHEN l.success = true THEN 1 END) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.session_id, (SELECT COUNT(l.id) FROM logs l WHERE l.session_id = s.session_id AND l.level = 'INFO') AS info_logs FROM sessions s) t WHERE info_logs > 100;", "output": "SELECT s.session_id, COUNT(CASE WHEN l.level = 'INFO' THEN 1 END) AS info_logs FROM sessions s LEFT JOIN logs l ON l.session_id = s.session_id GROUP BY s.session_id HAVING COUNT(CASE WHEN l.level = 'INFO' THEN 1 END) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM categories;", "output": "SELECT * FROM categories;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT tr.transaction_id, (SELECT SUM(td.amount) FROM transaction_details td WHERE td.transaction_id = tr.transaction_id) AS total_amount, (SELECT COUNT(td2.id) FROM transaction_details td2 WHERE td2.transaction_id = tr.transaction_id AND td2.amount > 50) AS large_items FROM transactions tr) t WHERE total_amount > 500;", "output": "SELECT tr.transaction_id, SUM(td.amount) AS total_amount, COUNT(CASE WHEN td.amount > 50 THEN 1 END) AS large_items FROM transactions tr LEFT JOIN transaction_details td ON td.transaction_id = tr.transaction_id GROUP BY tr.transaction_id HAVING SUM(td.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT m.member_id, (SELECT COUNT(*) FROM messages ms WHERE ms.member_id = m.member_id AND ms.created_at >= '2024-01-01') AS msg_count, (SELECT MAX(ms2.created_at) FROM messages ms2 WHERE ms2.member_id = m.member_id) AS last_msg FROM members m WHERE EXISTS (SELECT 1 FROM memberships mb WHERE mb.member_id = m.member_id AND mb.active = TRUE) ORDER BY msg_count DESC;", "output": "SELECT m.member_id, COUNT(ms.message_id) AS msg_count, MAX(ms.created_at) AS last_msg FROM members m JOIN memberships mb ON mb.member_id = m.member_id AND mb.active = TRUE LEFT JOIN messages ms ON ms.member_id = m.member_id AND ms.created_at >= '2024-01-01' GROUP BY m.member_id ORDER BY msg_count DESC;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.purchase_id, p.user_id, (SELECT SUM(pi.quantity * pi.unit_price) FROM purchase_items pi WHERE pi.purchase_id = p.purchase_id) AS gross_amount, (SELECT COALESCE(SUM(d.amount),0) FROM discounts d WHERE d.purchase_id = p.purchase_id) AS discount_amount FROM purchases p WHERE p.created_at BETWEEN '2024-01-01' AND '2024-12-31') t WHERE gross_amount - discount_amount > 500;", "output": "SELECT p.purchase_id, p.user_id, SUM(pi.quantity * pi.unit_price) AS gross_amount, COALESCE(SUM(d.amount),0) AS discount_amount FROM purchases p LEFT JOIN purchase_items pi ON pi.purchase_id = p.purchase_id LEFT JOIN discounts d ON d.purchase_id = p.purchase_id WHERE p.created_at >= '2024-01-01' AND p.created_at <= '2024-12-31' GROUP BY p.purchase_id, p.user_id HAVING SUM(pi.quantity * pi.unit_price) - COALESCE(SUM(d.amount),0) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT DISTINCT u.user_id FROM users u WHERE u.user_id IN (SELECT ad.user_id FROM ad_clicks ad WHERE ad.clicked_at >= '2025-01-01') AND EXISTS (SELECT 1 FROM pageviews pv WHERE pv.user_id = u.user_id AND pv.url LIKE '%/checkout%');", "output": "SELECT DISTINCT u.user_id FROM users u JOIN ad_clicks ad ON ad.user_id = u.user_id AND ad.clicked_at >= '2025-01-01' JOIN pageviews pv ON pv.user_id = u.user_id AND pv.url LIKE '%/checkout%';"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT w.warehouse_id, (SELECT SUM(CASE WHEN im.direction = 'IN' THEN im.quantity ELSE -im.quantity END) FROM inventory_movements im WHERE im.warehouse_id = w.warehouse_id) AS stock_level, (SELECT COUNT(*) FROM inventory_movements im2 WHERE im2.warehouse_id = w.warehouse_id AND im2.moved_at >= '2025-01-01') AS tx_count FROM warehouses w) t WHERE stock_level > 0 AND tx_count > 50;", "output": "SELECT w.warehouse_id, SUM(CASE WHEN im.direction = 'IN' THEN im.quantity ELSE -im.quantity END) AS stock_level, COUNT(CASE WHEN im.moved_at >= '2025-01-01' THEN 1 END) AS tx_count FROM warehouses w LEFT JOIN inventory_movements im ON im.warehouse_id = w.warehouse_id GROUP BY w.warehouse_id HAVING SUM(CASE WHEN im.direction = 'IN' THEN im.quantity ELSE -im.quantity END) > 0 AND COUNT(CASE WHEN im.moved_at >= '2025-01-01' THEN 1 END) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.delivery_id, (SELECT MAX(s.status_time) FROM delivery_status s WHERE s.delivery_id = d.delivery_id) AS last_status_time, (SELECT COUNT(*) FROM delivery_status s2 WHERE s2.delivery_id = d.delivery_id AND s2.status = 'FAILED') AS fails FROM deliveries d) x WHERE fails = 0;", "output": "SELECT d.delivery_id, MAX(s.status_time) AS last_status_time, COUNT(CASE WHEN s.status = 'FAILED' THEN 1 END) AS fails FROM deliveries d LEFT JOIN delivery_status s ON s.delivery_id = d.delivery_id GROUP BY d.delivery_id HAVING COUNT(CASE WHEN s.status = 'FAILED' THEN 1 END) = 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM sensor_readings;", "output": "SELECT * FROM sensor_readings;"}
{"instruction": "Optimize the SQL query", "input": "SELECT s.sensor_id, (SELECT AVG(r.value) FROM readings r WHERE r.sensor_id = s.sensor_id AND r.recorded_at >= '2025-01-01') AS avg_recent, (SELECT MAX(r2.value) FROM readings r2 WHERE r2.sensor_id = s.sensor_id) AS max_val FROM sensors s HAVING avg_recent IS NOT NULL;", "output": "SELECT s.sensor_id, AVG(r.value) AS avg_recent, MAX(r.value) AS max_val FROM sensors s LEFT JOIN readings r ON r.sensor_id = s.sensor_id AND r.recorded_at >= '2025-01-01' GROUP BY s.sensor_id HAVING AVG(r.value) IS NOT NULL;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.alert_id, (SELECT COUNT(*) FROM alert_events ae WHERE ae.alert_id = a.alert_id AND ae.event_type = 'TRIGGER') AS triggers, (SELECT COUNT(*) FROM alert_events ae2 WHERE ae2.alert_id = a.alert_id AND ae2.event_type = 'RESOLVE') AS resolves FROM alerts a) t WHERE triggers > resolves;", "output": "SELECT a.alert_id, COUNT(CASE WHEN ae.event_type = 'TRIGGER' THEN 1 END) AS triggers, COUNT(CASE WHEN ae.event_type = 'RESOLVE' THEN 1 END) AS resolves FROM alerts a LEFT JOIN alert_events ae ON ae.alert_id = a.alert_id GROUP BY a.alert_id HAVING COUNT(CASE WHEN ae.event_type = 'TRIGGER' THEN 1 END) > COUNT(CASE WHEN ae.event_type = 'RESOLVE' THEN 1 END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT inv.invoice_id, (SELECT SUM(il.amount) FROM invoice_lines il WHERE il.invoice_id = inv.invoice_id) AS total_lines, (SELECT SUM(p.amount) FROM payments p WHERE p.invoice_id = inv.invoice_id) AS total_paid FROM invoices inv WHERE (SELECT SUM(il2.amount) FROM invoice_lines il2 WHERE il2.invoice_id = inv.invoice_id) - (SELECT COALESCE(SUM(p2.amount),0) FROM payments p2 WHERE p2.invoice_id = inv.invoice_id) > 0;", "output": "SELECT inv.invoice_id, SUM(il.amount) AS total_lines, COALESCE(SUM(p.amount),0) AS total_paid FROM invoices inv LEFT JOIN invoice_lines il ON il.invoice_id = inv.invoice_id LEFT JOIN payments p ON p.invoice_id = inv.invoice_id GROUP BY inv.invoice_id HAVING SUM(il.amount) - COALESCE(SUM(p.amount),0) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pr.repo_id, (SELECT COUNT(c.commit_id) FROM commits c WHERE c.repo_id = pr.repo_id AND c.authored_at >= '2024-01-01') AS commits_year, (SELECT COUNT(p.pr_id) FROM pull_requests p WHERE p.repo_id = pr.repo_id AND p.state = 'open') AS open_prs, (SELECT COUNT(st.star_id) FROM stars st WHERE st.repo_id = pr.repo_id) AS stars FROM repos pr) t WHERE commits_year > 100 AND open_prs < 20;", "output": "SELECT pr.repo_id, COUNT(CASE WHEN c.authored_at >= '2024-01-01' THEN 1 END) AS commits_year, COUNT(CASE WHEN p.state = 'open' THEN 1 END) AS open_prs, COUNT(st.star_id) AS stars FROM repos pr LEFT JOIN commits c ON c.repo_id = pr.repo_id LEFT JOIN pull_requests p ON p.repo_id = pr.repo_id LEFT JOIN stars st ON st.repo_id = pr.repo_id GROUP BY pr.repo_id HAVING COUNT(CASE WHEN c.authored_at >= '2024-01-01' THEN 1 END) > 100 AND COUNT(CASE WHEN p.state = 'open' THEN 1 END) < 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT u.user_id FROM users u WHERE (SELECT COUNT(*) FROM followers f WHERE f.followee_id = u.user_id) > 1000 AND (SELECT COUNT(*) FROM followers f2 WHERE f2.follower_id = u.user_id) > 100;", "output": "SELECT u.user_id FROM users u LEFT JOIN followers f1 ON f1.followee_id = u.user_id LEFT JOIN followers f2 ON f2.follower_id = u.user_id GROUP BY u.user_id HAVING COUNT(f1.followee_id) > 1000 AND COUNT(f2.follower_id) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.playlist_id, (SELECT COUNT(pt.track_id) FROM playlist_tracks pt WHERE pt.playlist_id = pl.playlist_id) AS tracks, (SELECT SUM(t.duration_sec) FROM tracks t WHERE t.track_id IN (SELECT pt2.track_id FROM playlist_tracks pt2 WHERE pt2.playlist_id = pl.playlist_id)) AS duration FROM playlists pl) t WHERE tracks > 20 AND duration > 3600;", "output": "SELECT pl.playlist_id, COUNT(pt.track_id) AS tracks, SUM(t.duration_sec) AS duration FROM playlists pl LEFT JOIN playlist_tracks pt ON pt.playlist_id = pl.playlist_id LEFT JOIN tracks t ON t.track_id = pt.track_id GROUP BY pl.playlist_id HAVING COUNT(pt.track_id) > 20 AND SUM(t.duration_sec) > 3600;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.device_id, (SELECT COUNT(u.update_id) FROM firmware_updates u WHERE u.device_id = d.device_id) AS update_count, (SELECT MAX(u2.applied_at) FROM firmware_updates u2 WHERE u2.device_id = d.device_id) AS last_update FROM devices d) t WHERE update_count > 0;", "output": "SELECT d.device_id, COUNT(u.update_id) AS update_count, MAX(u.applied_at) AS last_update FROM devices d LEFT JOIN firmware_updates u ON u.device_id = d.device_id GROUP BY d.device_id HAVING COUNT(u.update_id) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.bug_id, (SELECT COUNT(t.test_id) FROM test_runs t WHERE t.bug_id = b.bug_id AND t.status = 'failed') AS fails, (SELECT COUNT(t2.test_id) FROM test_runs t2 WHERE t2.bug_id = b.bug_id AND t2.status = 'passed') AS passes FROM bugs b) t WHERE fails > passes;", "output": "SELECT b.bug_id, COUNT(CASE WHEN t.status = 'failed' THEN 1 END) AS fails, COUNT(CASE WHEN t.status = 'passed' THEN 1 END) AS passes FROM bugs b LEFT JOIN test_runs t ON t.bug_id = b.bug_id GROUP BY b.bug_id HAVING COUNT(CASE WHEN t.status = 'failed' THEN 1 END) > COUNT(CASE WHEN t.status = 'passed' THEN 1 END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT a.artifact_id, a.pipeline_id FROM build_artifacts a WHERE a.created_at = a.created_at;", "output": "SELECT a.artifact_id, a.pipeline_id FROM build_artifacts a;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT m.host_id, (SELECT AVG(c.usage_percent) FROM cpu_metrics c WHERE c.host_id = m.host_id AND c.recorded_at >= '2025-01-01') AS avg_cpu, (SELECT AVG(mm.usage_percent) FROM memory_metrics mm WHERE mm.host_id = m.host_id AND mm.recorded_at >= '2025-01-01') AS avg_mem FROM machines m) t WHERE avg_cpu > 70 AND avg_mem > 75;", "output": "SELECT m.host_id, AVG(c.usage_percent) AS avg_cpu, AVG(mm.usage_percent) AS avg_mem FROM machines m LEFT JOIN cpu_metrics c ON c.host_id = m.host_id AND c.recorded_at >= '2025-01-01' LEFT JOIN memory_metrics mm ON mm.host_id = m.host_id AND mm.recorded_at >= '2025-01-01' GROUP BY m.host_id HAVING AVG(c.usage_percent) > 70 AND AVG(mm.usage_percent) > 75;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT n.node_id, (SELECT COUNT(e.event_id) FROM network_events e WHERE e.node_id = n.node_id AND e.severity = 'critical') AS crits, (SELECT COUNT(e2.event_id) FROM network_events e2 WHERE e2.node_id = n.node_id AND e2.severity = 'warning') AS warns FROM nodes n) t WHERE crits > 0 OR warns > 10;", "output": "SELECT n.node_id, COUNT(CASE WHEN e.severity = 'critical' THEN 1 END) AS crits, COUNT(CASE WHEN e.severity = 'warning' THEN 1 END) AS warns FROM nodes n LEFT JOIN network_events e ON e.node_id = n.node_id GROUP BY n.node_id HAVING COUNT(CASE WHEN e.severity = 'critical' THEN 1 END) > 0 OR COUNT(CASE WHEN e.severity = 'warning' THEN 1 END) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT u.user_id, (SELECT COUNT(*) FROM subscriptions s WHERE s.user_id = u.user_id AND s.status = 'active') AS active_subs, (SELECT COUNT(*) FROM cancellations c WHERE c.user_id = u.user_id AND c.created_at >= '2024-01-01') AS cancels FROM users u WHERE active_subs > 0;", "output": "SELECT u.user_id, COUNT(CASE WHEN s.status = 'active' THEN 1 END) AS active_subs, COUNT(CASE WHEN c.created_at >= '2024-01-01' THEN 1 END) AS cancels FROM users u LEFT JOIN subscriptions s ON s.user_id = u.user_id LEFT JOIN cancellations c ON c.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(CASE WHEN s.status = 'active' THEN 1 END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.project_id, p.org_id, (SELECT COUNT(*) FROM issues i WHERE i.project_id = p.project_id AND i.state = 'open') AS open_issues, (SELECT MAX(i2.updated_at) FROM issues i2 WHERE i2.project_id = p.project_id) AS last_issue_time FROM projects p WHERE p.visibility IN ('public','internal')) t WHERE open_issues < 50 ORDER BY last_issue_time DESC;", "output": "SELECT p.project_id, p.org_id, COUNT(CASE WHEN i.state = 'open' THEN 1 END) AS open_issues, MAX(i.updated_at) AS last_issue_time FROM projects p LEFT JOIN issues i ON i.project_id = p.project_id WHERE p.visibility IN ('public','internal') GROUP BY p.project_id, p.org_id HAVING COUNT(CASE WHEN i.state = 'open' THEN 1 END) < 50 ORDER BY last_issue_time DESC;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT acc.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = acc.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = acc.account_id AND t2.type = 'debit') AS debits FROM accounts acc) z WHERE credits - debits > 0;", "output": "SELECT acc.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts acc LEFT JOIN transactions t ON t.account_id = acc.account_id GROUP BY acc.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) - SUM(CASE WHEN t.type = 'debit' THEN t.amount END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT l.listen_id, l.user_id, (SELECT COUNT(*) FROM listens li WHERE li.user_id = l.user_id AND li.played_at >= '2025-01-01') AS plays_2025 FROM listens l) t WHERE plays_2025 > 100;", "output": "SELECT l.user_id, COUNT(li.listen_id) AS plays_2025 FROM listens l JOIN listens li ON li.user_id = l.user_id AND li.played_at >= '2025-01-01' GROUP BY l.user_id HAVING COUNT(li.listen_id) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.store_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.store_id = s.store_id AND o.status IN ('paid','shipped')) AS good_orders, (SELECT COUNT(o2.order_id) FROM orders o2 WHERE o2.store_id = s.store_id AND o2.status = 'cancelled') AS cancelled FROM stores s) t WHERE good_orders >= 100 AND cancelled < 10;", "output": "SELECT s.store_id, COUNT(CASE WHEN o.status IN ('paid','shipped') THEN 1 END) AS good_orders, COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) AS cancelled FROM stores s LEFT JOIN orders o ON o.store_id = s.store_id GROUP BY s.store_id HAVING COUNT(CASE WHEN o.status IN ('paid','shipped') THEN 1 END) >= 100 AND COUNT(CASE WHEN o.status = 'cancelled' THEN 1 END) < 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT k.course_key, (SELECT AVG(e.score) FROM exam_results e WHERE e.course_key = k.course_key) AS avg_score, (SELECT COUNT(*) FROM enrollments en WHERE en.course_key = k.course_key) AS enrolled FROM course_keys k) t WHERE avg_score >= 80 AND enrolled > 50;", "output": "SELECT k.course_key, AVG(e.score) AS avg_score, COUNT(en.student_id) AS enrolled FROM course_keys k LEFT JOIN exam_results e ON e.course_key = k.course_key LEFT JOIN enrollments en ON en.course_key = k.course_key GROUP BY k.course_key HAVING AVG(e.score) >= 80 AND COUNT(en.student_id) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM geolocation_points;", "output": "SELECT * FROM geolocation_points;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT t.tx_id, t.user_id, (SELECT COUNT(*) FROM tx_tags tt WHERE tt.tx_id = t.tx_id AND tt.tag = 'highrisk') AS risk_tags, (SELECT SUM(tf.fee_amount) FROM tx_fees tf WHERE tf.tx_id = t.tx_id) AS total_fees FROM transactions t) q WHERE risk_tags > 0 AND total_fees > 10;", "output": "SELECT t.tx_id, t.user_id, COUNT(CASE WHEN tt.tag = 'highrisk' THEN 1 END) AS risk_tags, SUM(tf.fee_amount) AS total_fees FROM transactions t LEFT JOIN tx_tags tt ON tt.tx_id = t.tx_id LEFT JOIN tx_fees tf ON tf.tx_id = t.tx_id GROUP BY t.tx_id, t.user_id HAVING COUNT(CASE WHEN tt.tag = 'highrisk' THEN 1 END) > 0 AND SUM(tf.fee_amount) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT r.route_id, (SELECT COUNT(*) FROM deliveries d WHERE d.route_id = r.route_id AND d.delivered = TRUE) AS delivered_cnt, (SELECT COUNT(*) FROM deliveries d2 WHERE d2.route_id = r.route_id AND d2.delivered = FALSE) AS pending_cnt FROM routes r) t WHERE delivered_cnt > pending_cnt;", "output": "SELECT r.route_id, COUNT(CASE WHEN d.delivered = TRUE THEN 1 END) AS delivered_cnt, COUNT(CASE WHEN d.delivered = FALSE THEN 1 END) AS pending_cnt FROM routes r LEFT JOIN deliveries d ON d.route_id = r.route_id GROUP BY r.route_id HAVING COUNT(CASE WHEN d.delivered = TRUE THEN 1 END) > COUNT(CASE WHEN d.delivered = FALSE THEN 1 END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(s.session_id) FROM sessions s WHERE s.user_id = u.user_id AND s.start_time >= '2025-01-01') AS recent_sessions, (SELECT COUNT(p.page_id) FROM pageviews p WHERE p.user_id = u.user_id AND p.url LIKE '%checkout%') AS checkout_views FROM users u) t WHERE recent_sessions > 2 AND checkout_views > 0;", "output": "SELECT u.user_id, COUNT(CASE WHEN s.start_time >= '2025-01-01' THEN 1 END) AS recent_sessions, COUNT(CASE WHEN p.url LIKE '%checkout%' THEN 1 END) AS checkout_views FROM users u LEFT JOIN sessions s ON s.user_id = u.user_id LEFT JOIN pageviews p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(CASE WHEN s.start_time >= '2025-01-01' THEN 1 END) > 2 AND COUNT(CASE WHEN p.url LIKE '%checkout%' THEN 1 END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.group_id, (SELECT COUNT(m.member_id) FROM group_members m WHERE m.group_id = g.group_id) AS members_count, (SELECT COUNT(p.post_id) FROM posts p WHERE p.group_id = g.group_id) AS posts_count FROM groups g) t WHERE members_count > 100 AND posts_count > 500;", "output": "SELECT g.group_id, COUNT(m.member_id) AS members_count, COUNT(p.post_id) AS posts_count FROM groups g LEFT JOIN group_members m ON m.group_id = g.group_id LEFT JOIN posts p ON p.group_id = g.group_id GROUP BY g.group_id HAVING COUNT(m.member_id) > 100 AND COUNT(p.post_id) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS total_spent, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.customer_id = c.customer_id) AS reviews_written FROM customers c) t WHERE total_spent > 10000;", "output": "SELECT c.customer_id, SUM(o.total) AS total_spent, COUNT(r.review_id) AS reviews_written FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN reviews r ON r.customer_id = c.customer_id GROUP BY c.customer_id HAVING SUM(o.total) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.post_id, (SELECT COUNT(l.like_id) FROM likes l WHERE l.post_id = p.post_id) AS like_count, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.post_id = p.post_id) AS comment_count FROM posts p) t WHERE like_count > 100 OR comment_count > 50;", "output": "SELECT p.post_id, COUNT(l.like_id) AS like_count, COUNT(c.comment_id) AS comment_count FROM posts p LEFT JOIN likes l ON l.post_id = p.post_id LEFT JOIN comments c ON c.post_id = p.post_id GROUP BY p.post_id HAVING COUNT(l.like_id) > 100 OR COUNT(c.comment_id) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.store_id, (SELECT SUM(o.total) FROM orders o WHERE o.store_id = s.store_id AND o.status = 'completed') AS completed_sales, (SELECT SUM(o2.total) FROM orders o2 WHERE o2.store_id = s.store_id AND o2.status = 'cancelled') AS cancelled_sales FROM stores s) t WHERE completed_sales > cancelled_sales;", "output": "SELECT s.store_id, SUM(CASE WHEN o.status = 'completed' THEN o.total END) AS completed_sales, SUM(CASE WHEN o.status = 'cancelled' THEN o.total END) AS cancelled_sales FROM stores s LEFT JOIN orders o ON o.store_id = s.store_id GROUP BY s.store_id HAVING SUM(CASE WHEN o.status = 'completed' THEN o.total END) > SUM(CASE WHEN o.status = 'cancelled' THEN o.total END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id AND r.status = 'completed') AS completed_rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE completed_rides > 100 AND avg_rating > 4.5;", "output": "SELECT d.driver_id, COUNT(CASE WHEN r.status = 'completed' THEN 1 END) AS completed_rides, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(CASE WHEN r.status = 'completed' THEN 1 END) > 100 AND AVG(r.rating) > 4.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS booking_count, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE booking_count > 200;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS booking_count, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.project_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = p.project_id) AS task_count, (SELECT COUNT(t2.task_id) FROM tasks t2 WHERE t2.project_id = p.project_id AND t2.status = 'done') AS completed_tasks FROM projects p) t WHERE task_count > 50 AND completed_tasks > 40;", "output": "SELECT p.project_id, COUNT(t.task_id) AS task_count, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS completed_tasks FROM projects p LEFT JOIN tasks t ON t.project_id = p.project_id GROUP BY p.project_id HAVING COUNT(t.task_id) > 50 AND COUNT(CASE WHEN t.status = 'done' THEN 1 END) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = c.class_id) AS student_count, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = c.class_id) AS avg_grade FROM classes c) t WHERE student_count > 20;", "output": "SELECT c.class_id, COUNT(st.student_id) AS student_count, AVG(g.grade) AS avg_grade FROM classes c LEFT JOIN students st ON st.class_id = c.class_id LEFT JOIN grades g ON g.class_id = c.class_id GROUP BY c.class_id HAVING COUNT(st.student_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM logs WHERE level = 'WARN';", "output": "SELECT log_id, level, message, created_at FROM logs WHERE level = 'WARN';"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT f.flight_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.flight_id = f.flight_id) AS sold_tickets, (SELECT COUNT(t2.ticket_id) FROM tickets t2 WHERE t2.flight_id = f.flight_id AND t2.status = 'cancelled') AS cancelled_tickets FROM flights f) t WHERE sold_tickets > 100;", "output": "SELECT f.flight_id, COUNT(t.ticket_id) AS sold_tickets, COUNT(CASE WHEN t.status = 'cancelled' THEN 1 END) AS cancelled_tickets FROM flights f LEFT JOIN tickets t ON t.flight_id = f.flight_id GROUP BY f.flight_id HAVING COUNT(t.ticket_id) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM products;", "output": "SELECT * FROM products;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(e.exam_id) FROM exams e WHERE e.student_id = s.student_id) AS exam_count, (SELECT AVG(e2.score) FROM exams e2 WHERE e2.student_id = s.student_id) AS avg_score FROM students s) t WHERE exam_count > 3;", "output": "SELECT s.student_id, COUNT(e.exam_id) AS exam_count, AVG(e.score) AS avg_score FROM students s LEFT JOIN exams e ON e.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(e.exam_id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS post_count, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.user_id = u.user_id) AS comment_count FROM users u) t WHERE post_count > 5 OR comment_count > 10;", "output": "SELECT u.user_id, COUNT(p.post_id) AS post_count, COUNT(c.comment_id) AS comment_count FROM users u LEFT JOIN posts p ON p.user_id = u.user_id LEFT JOIN comments c ON c.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(p.post_id) > 5 OR COUNT(c.comment_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.department_id, (SELECT SUM(e.salary) FROM employees e WHERE e.department_id = d.department_id) AS total_salary, (SELECT COUNT(e2.id) FROM employees e2 WHERE e2.department_id = d.department_id) AS emp_count FROM departments d) t WHERE total_salary > 500000;", "output": "SELECT d.department_id, SUM(e.salary) AS total_salary, COUNT(e.id) AS emp_count FROM departments d LEFT JOIN employees e ON e.department_id = d.department_id GROUP BY d.department_id HAVING SUM(e.salary) > 500000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.book_id = b.book_id) AS review_count, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.book_id = b.book_id) AS avg_rating FROM books b) t WHERE review_count > 10 AND avg_rating > 3;", "output": "SELECT b.book_id, COUNT(r.review_id) AS review_count, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN reviews r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(r.review_id) > 10 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.player_id) FROM players p WHERE p.game_id = g.game_id) AS player_count, (SELECT MAX(s.score) FROM scores s WHERE s.game_id = g.game_id) AS max_score FROM games g) t WHERE player_count > 5;", "output": "SELECT g.game_id, COUNT(p.player_id) AS player_count, MAX(s.score) AS max_score FROM games g LEFT JOIN players p ON p.game_id = g.game_id LEFT JOIN scores s ON s.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.player_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM payments;", "output": "SELECT * FROM payments;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 30;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 30;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, o.customer_id, (SELECT SUM(oi.price * oi.quantity) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS return_count FROM orders o) t WHERE total_value > 1000 AND return_count = 0 ORDER BY total_value DESC;", "output": "SELECT o.order_id, o.customer_id, SUM(oi.price * oi.quantity) AS total_value, COUNT(r.return_id) AS return_count FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id, o.customer_id HAVING SUM(oi.price * oi.quantity) > 1000 AND COUNT(r.return_id) = 0 ORDER BY total_value DESC;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, e.department_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary, (SELECT MAX(p.project_deadline) FROM projects p WHERE p.lead_id = e.employee_id) AS last_deadline FROM employees e) t WHERE avg_salary > 5000;", "output": "SELECT e.employee_id, e.department_id, AVG(s.salary) AS avg_salary, MAX(p.project_deadline) AS last_deadline FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id LEFT JOIN projects p ON p.lead_id = e.employee_id GROUP BY e.employee_id, e.department_id HAVING AVG(s.salary) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.user_id = u.user_id) AS orders_count, (SELECT MAX(o2.order_date) FROM orders o2 WHERE o2.user_id = u.user_id) AS last_order FROM users u) t WHERE orders_count > 5;", "output": "SELECT u.user_id, COUNT(o.order_id) AS orders_count, MAX(o.order_date) AS last_order FROM users u LEFT JOIN orders o ON o.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(o.order_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.category_id, (SELECT COUNT(p.product_id) FROM products p WHERE p.category_id = c.category_id) AS product_count, (SELECT AVG(p2.price) FROM products p2 WHERE p2.category_id = c.category_id) AS avg_price FROM categories c) t WHERE product_count > 10;", "output": "SELECT c.category_id, COUNT(p.product_id) AS product_count, AVG(p.price) AS avg_price FROM categories c LEFT JOIN products p ON p.category_id = c.category_id GROUP BY c.category_id HAVING COUNT(p.product_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT t.team_id, (SELECT COUNT(p.player_id) FROM players p WHERE p.team_id = t.team_id) AS player_count, (SELECT AVG(p2.age) FROM players p2 WHERE p2.team_id = t.team_id) AS avg_age FROM teams t) t2 WHERE player_count > 15;", "output": "SELECT t.team_id, COUNT(p.player_id) AS player_count, AVG(p.age) AS avg_age FROM teams t LEFT JOIN players p ON p.team_id = t.team_id GROUP BY t.team_id HAVING COUNT(p.player_id) > 15;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT AVG(g.score) FROM grades g WHERE g.student_id = s.student_id) AS avg_score, (SELECT COUNT(c.course_id) FROM enrollments c WHERE c.student_id = s.student_id) AS courses_taken FROM students s) t WHERE avg_score > 70;", "output": "SELECT s.student_id, AVG(g.score) AS avg_score, COUNT(c.course_id) AS courses_taken FROM students s LEFT JOIN grades g ON g.student_id = s.student_id LEFT JOIN enrollments c ON c.student_id = s.student_id GROUP BY s.student_id HAVING AVG(g.score) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.project_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = p.project_id AND t.status = 'done') AS completed_tasks, (SELECT COUNT(t2.task_id) FROM tasks t2 WHERE t2.project_id = p.project_id) AS total_tasks FROM projects p) t WHERE completed_tasks = total_tasks;", "output": "SELECT p.project_id, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS completed_tasks, COUNT(t.task_id) AS total_tasks FROM projects p LEFT JOIN tasks t ON t.project_id = p.project_id GROUP BY p.project_id HAVING COUNT(CASE WHEN t.status = 'done' THEN 1 END) = COUNT(t.task_id);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books_count, (SELECT AVG(r.rating) FROM reviews r WHERE r.author_id = a.author_id) AS avg_rating FROM authors a) t WHERE books_count > 3;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books_count, AVG(r.rating) AS avg_rating FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN reviews r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.department_id, (SELECT SUM(e.salary) FROM employees e WHERE e.department_id = d.department_id) AS total_salary, (SELECT COUNT(e2.employee_id) FROM employees e2 WHERE e2.department_id = d.department_id) AS emp_count FROM departments d) t WHERE emp_count > 10;", "output": "SELECT d.department_id, SUM(e.salary) AS total_salary, COUNT(e.employee_id) AS emp_count FROM departments d LEFT JOIN employees e ON e.department_id = d.department_id GROUP BY d.department_id HAVING COUNT(e.employee_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.customer_id = c.customer_id) AS orders_count, (SELECT SUM(o2.total) FROM orders o2 WHERE o2.customer_id = c.customer_id) AS total_spent FROM customers c) t WHERE total_spent > 5000;", "output": "SELECT c.customer_id, COUNT(o.order_id) AS orders_count, SUM(o.total) AS total_spent FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id GROUP BY c.customer_id HAVING SUM(o.total) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, e.department_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.lead_id = e.employee_id) AS projects_led, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE projects_led > 2;", "output": "SELECT e.employee_id, e.department_id, COUNT(p.project_id) AS projects_led, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN projects p ON p.lead_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id, e.department_id HAVING COUNT(p.project_id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.login_id) FROM logins l WHERE l.user_id = u.user_id) AS logins_count, (SELECT MAX(l2.login_time) FROM logins l2 WHERE l2.user_id = u.user_id) AS last_login FROM users u) t WHERE logins_count > 10;", "output": "SELECT u.user_id, COUNT(l.login_id) AS logins_count, MAX(l.login_time) AS last_login FROM users u LEFT JOIN logins l ON l.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(l.login_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.product_id = p.product_id) AS reviews_count, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.product_id) AS avg_rating FROM products p) t WHERE reviews_count > 20;", "output": "SELECT p.product_id, COUNT(r.review_id) AS reviews_count, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.product_id GROUP BY p.product_id HAVING COUNT(r.review_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.group_id, (SELECT COUNT(m.member_id) FROM group_members m WHERE m.group_id = g.group_id) AS member_count, (SELECT MAX(p.post_date) FROM posts p WHERE p.group_id = g.group_id) AS last_post_date FROM groups g) t WHERE member_count > 5;", "output": "SELECT g.group_id, COUNT(m.member_id) AS member_count, MAX(p.post_date) AS last_post_date FROM groups g LEFT JOIN group_members m ON m.group_id = g.group_id LEFT JOIN posts p ON p.group_id = g.group_id GROUP BY g.group_id HAVING COUNT(m.member_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.article_id, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.article_id = a.article_id) AS comment_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.article_id = a.article_id) AS avg_rating FROM articles a) t WHERE comment_count > 50;", "output": "SELECT a.article_id, COUNT(c.comment_id) AS comment_count, AVG(r.rating) AS avg_rating FROM articles a LEFT JOIN comments c ON c.article_id = a.article_id LEFT JOIN ratings r ON r.article_id = a.article_id GROUP BY a.article_id HAVING COUNT(c.comment_id) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(a.attendee_id) FROM attendees a WHERE a.event_id = ev.event_id) AS attendees_count, (SELECT MAX(a2.registered_at) FROM attendees a2 WHERE a2.event_id = ev.event_id) AS last_registered FROM events ev) t WHERE attendees_count > 200;", "output": "SELECT ev.event_id, COUNT(a.attendee_id) AS attendees_count, MAX(a.registered_at) AS last_registered FROM events ev LEFT JOIN attendees a ON a.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(a.attendee_id) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shop_id, (SELECT SUM(s.amount) FROM sales s WHERE s.shop_id = sh.shop_id) AS total_sales, (SELECT COUNT(r.return_id) FROM returns r WHERE r.shop_id = sh.shop_id) AS return_count FROM shops sh) t WHERE total_sales > 10000;", "output": "SELECT sh.shop_id, SUM(s.amount) AS total_sales, COUNT(r.return_id) AS return_count FROM shops sh LEFT JOIN sales s ON s.shop_id = sh.shop_id LEFT JOIN returns r ON r.shop_id = sh.shop_id GROUP BY sh.shop_id HAVING SUM(s.amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled_count, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled_count > 10;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled_count, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT l.library_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.library_id = l.library_id) AS book_count, (SELECT COUNT(m.member_id) FROM members m WHERE m.library_id = l.library_id) AS member_count FROM libraries l) t WHERE book_count > 1000;", "output": "SELECT l.library_id, COUNT(b.book_id) AS book_count, COUNT(m.member_id) AS member_count FROM libraries l LEFT JOIN books b ON b.library_id = l.library_id LEFT JOIN members m ON m.library_id = l.library_id GROUP BY l.library_id HAVING COUNT(b.book_id) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.player_id) FROM players p WHERE p.game_id = g.game_id) AS player_count, (SELECT AVG(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS avg_score FROM games g) t WHERE player_count > 10;", "output": "SELECT g.game_id, COUNT(p.player_id) AS player_count, AVG(sc.score) AS avg_score FROM games g LEFT JOIN players p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.player_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, o.customer_id, o.order_date, (SELECT COUNT(oi.item_id) FROM order_items oi WHERE oi.order_id = o.order_id) AS item_count, ROW_NUMBER() OVER (PARTITION BY o.customer_id ORDER BY o.order_date DESC) AS rn FROM orders o) t WHERE rn = 1 AND item_count > 5;", "output": "SELECT o.order_id, o.customer_id, o.order_date, COUNT(oi.item_id) AS item_count FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id WHERE o.order_id IN (SELECT order_id FROM (SELECT o2.order_id, ROW_NUMBER() OVER (PARTITION BY o2.customer_id ORDER BY o2.order_date DESC) AS rn FROM orders o2) x WHERE rn = 1) GROUP BY o.order_id, o.customer_id, o.order_date HAVING COUNT(oi.item_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, e.department_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary, RANK() OVER (PARTITION BY e.department_id ORDER BY (SELECT AVG(s2.salary) FROM salaries s2 WHERE s2.employee_id = e.employee_id) DESC) AS salary_rank FROM employees e) t WHERE salary_rank <= 3;", "output": "SELECT e.employee_id, e.department_id, AVG(s.salary) AS avg_salary, RANK() OVER (PARTITION BY e.department_id ORDER BY AVG(s.salary) DESC) AS salary_rank FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id, e.department_id HAVING RANK() OVER (PARTITION BY e.department_id ORDER BY AVG(s.salary) DESC) <= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.user_id = u.user_id) AS orders_count, DENSE_RANK() OVER (ORDER BY (SELECT COUNT(o2.order_id) FROM orders o2 WHERE o2.user_id = u.user_id) DESC) AS rnk FROM users u) t WHERE rnk <= 10;", "output": "SELECT u.user_id, COUNT(o.order_id) AS orders_count, DENSE_RANK() OVER (ORDER BY COUNT(o.order_id) DESC) AS rnk FROM users u LEFT JOIN orders o ON o.user_id = u.user_id GROUP BY u.user_id HAVING DENSE_RANK() OVER (ORDER BY COUNT(o.order_id) DESC) <= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, p.category_id, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = p.product_id) AS avg_rating, NTILE(4) OVER (ORDER BY (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.product_id) DESC) AS quartile FROM products p) x WHERE quartile = 1;", "output": "SELECT p.product_id, p.category_id, AVG(r.rating) AS avg_rating, NTILE(4) OVER (ORDER BY AVG(r.rating) DESC) AS quartile FROM products p LEFT JOIN reviews r ON r.product_id = p.product_id GROUP BY p.product_id, p.category_id HAVING NTILE(4) OVER (ORDER BY AVG(r.rating) DESC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT AVG(g.score) FROM grades g WHERE g.student_id = s.student_id) AS avg_score, ROW_NUMBER() OVER (ORDER BY (SELECT AVG(g2.score) FROM grades g2 WHERE g2.student_id = s.student_id) DESC) AS rn FROM students s) t WHERE rn <= 5;", "output": "SELECT s.student_id, AVG(g.score) AS avg_score, ROW_NUMBER() OVER (ORDER BY AVG(g.score) DESC) AS rn FROM students s LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING ROW_NUMBER() OVER (ORDER BY AVG(g.score) DESC) <= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS total_spent, RANK() OVER (ORDER BY (SELECT SUM(o2.total) FROM orders o2 WHERE o2.customer_id = c.customer_id) DESC) AS spend_rank FROM customers c) t WHERE spend_rank <= 20;", "output": "SELECT c.customer_id, SUM(o.total) AS total_spent, RANK() OVER (ORDER BY SUM(o.total) DESC) AS spend_rank FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id GROUP BY c.customer_id HAVING RANK() OVER (ORDER BY SUM(o.total) DESC) <= 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT f.flight_id, (SELECT AVG(t.price) FROM tickets t WHERE t.flight_id = f.flight_id) AS avg_price, ROW_NUMBER() OVER (PARTITION BY f.airline_id ORDER BY (SELECT AVG(t2.price) FROM tickets t2 WHERE t2.flight_id = f.flight_id) ASC) AS rn FROM flights f) t WHERE rn = 1;", "output": "SELECT f.flight_id, AVG(t.price) AS avg_price, ROW_NUMBER() OVER (PARTITION BY f.airline_id ORDER BY AVG(t.price) ASC) AS rn FROM flights f LEFT JOIN tickets t ON t.flight_id = f.flight_id GROUP BY f.flight_id, f.airline_id HAVING ROW_NUMBER() OVER (PARTITION BY f.airline_id ORDER BY AVG(t.price) ASC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.artist_id, (SELECT COUNT(al.album_id) FROM albums al WHERE al.artist_id = a.artist_id) AS album_count, RANK() OVER (ORDER BY (SELECT COUNT(al2.album_id) FROM albums al2 WHERE al2.artist_id = a.artist_id) DESC) AS rnk FROM artists a) t WHERE rnk <= 3;", "output": "SELECT a.artist_id, COUNT(al.album_id) AS album_count, RANK() OVER (ORDER BY COUNT(al.album_id) DESC) AS rnk FROM artists a LEFT JOIN albums al ON al.artist_id = a.artist_id GROUP BY a.artist_id HAVING RANK() OVER (ORDER BY COUNT(al.album_id) DESC) <= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS ride_count, DENSE_RANK() OVER (ORDER BY (SELECT COUNT(r2.ride_id) FROM rides r2 WHERE r2.driver_id = d.driver_id) DESC) AS rnk FROM drivers d) t WHERE rnk <= 10;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS ride_count, DENSE_RANK() OVER (ORDER BY COUNT(r.ride_id) DESC) AS rnk FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING DENSE_RANK() OVER (ORDER BY COUNT(r.ride_id) DESC) <= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT AVG(b.price) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS avg_price, NTILE(5) OVER (ORDER BY (SELECT AVG(b2.price) FROM bookings b2 WHERE b2.hotel_id = h.hotel_id) DESC) AS quintile FROM hotels h) t WHERE quintile = 1;", "output": "SELECT h.hotel_id, AVG(b.price) AS avg_price, NTILE(5) OVER (ORDER BY AVG(b.price) DESC) AS quintile FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING NTILE(5) OVER (ORDER BY AVG(b.price) DESC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pr.project_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = pr.project_id AND t.status = 'done') AS done_tasks, (SELECT COUNT(t2.task_id) FROM tasks t2 WHERE t2.project_id = pr.project_id) AS total_tasks, RANK() OVER (ORDER BY (SELECT COUNT(t3.task_id) FROM tasks t3 WHERE t3.project_id = pr.project_id AND t3.status = 'done') DESC) AS completion_rank FROM projects pr) t WHERE done_tasks = total_tasks;", "output": "SELECT pr.project_id, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS done_tasks, COUNT(t.task_id) AS total_tasks, RANK() OVER (ORDER BY COUNT(CASE WHEN t.status = 'done' THEN 1 END) DESC) AS completion_rank FROM projects pr LEFT JOIN tasks t ON t.project_id = pr.project_id GROUP BY pr.project_id HAVING COUNT(CASE WHEN t.status = 'done' THEN 1 END) = COUNT(t.task_id);" }
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.class_id, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = c.class_id) AS avg_grade, ROW_NUMBER() OVER (PARTITION BY c.school_id ORDER BY (SELECT AVG(g2.grade) FROM grades g2 WHERE g2.class_id = c.class_id) DESC) AS rn FROM classes c) t WHERE rn <= 2;", "output": "SELECT c.class_id, AVG(g.grade) AS avg_grade, ROW_NUMBER() OVER (PARTITION BY c.school_id ORDER BY AVG(g.grade) DESC) AS rn FROM classes c LEFT JOIN grades g ON g.class_id = c.class_id GROUP BY c.class_id, c.school_id HAVING ROW_NUMBER() OVER (PARTITION BY c.school_id ORDER BY AVG(g.grade) DESC) <= 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS post_count, RANK() OVER (ORDER BY (SELECT COUNT(p2.post_id) FROM posts p2 WHERE p2.user_id = u.user_id) DESC) AS rnk FROM users u) t WHERE rnk <= 50;", "output": "SELECT u.user_id, COUNT(p.post_id) AS post_count, RANK() OVER (ORDER BY COUNT(p.post_id) DESC) AS rnk FROM users u LEFT JOIN posts p ON p.user_id = u.user_id GROUP BY u.user_id HAVING RANK() OVER (ORDER BY COUNT(p.post_id) DESC) <= 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT v.vehicle_id, (SELECT COUNT(m.maintenance_id) FROM maintenance m WHERE m.vehicle_id = v.vehicle_id) AS maintenance_count, ROW_NUMBER() OVER (ORDER BY (SELECT COUNT(m2.maintenance_id) FROM maintenance m2 WHERE m2.vehicle_id = v.vehicle_id) DESC) AS rn FROM vehicles v) t WHERE rn <= 5;", "output": "SELECT v.vehicle_id, COUNT(m.maintenance_id) AS maintenance_count, ROW_NUMBER() OVER (ORDER BY COUNT(m.maintenance_id) DESC) AS rn FROM vehicles v LEFT JOIN maintenance m ON m.vehicle_id = v.vehicle_id GROUP BY v.vehicle_id HAVING ROW_NUMBER() OVER (ORDER BY COUNT(m.maintenance_id) DESC) <= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT AVG(g.score) FROM grades g WHERE g.course_id = c.course_id) AS avg_score, NTILE(3) OVER (ORDER BY (SELECT AVG(g2.score) FROM grades g2 WHERE g2.course_id = c.course_id) DESC) AS tertile FROM courses c) t WHERE tertile = 1;", "output": "SELECT c.course_id, AVG(g.score) AS avg_score, NTILE(3) OVER (ORDER BY AVG(g.score) DESC) AS tertile FROM courses c LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING NTILE(3) OVER (ORDER BY AVG(g.score) DESC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.song_id, (SELECT AVG(r.rating) FROM ratings r WHERE r.song_id = s.song_id) AS avg_rating, ROW_NUMBER() OVER (PARTITION BY s.album_id ORDER BY (SELECT AVG(r2.rating) FROM ratings r2 WHERE r2.song_id = s.song_id) DESC) AS rn FROM songs s) t WHERE rn <= 3;", "output": "SELECT s.song_id, AVG(r.rating) AS avg_rating, ROW_NUMBER() OVER (PARTITION BY s.album_id ORDER BY AVG(r.rating) DESC) AS rn FROM songs s LEFT JOIN ratings r ON r.song_id = s.song_id GROUP BY s.song_id, s.album_id HAVING ROW_NUMBER() OVER (PARTITION BY s.album_id ORDER BY AVG(r.rating) DESC) <= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS book_count, DENSE_RANK() OVER (ORDER BY (SELECT COUNT(b2.book_id) FROM books b2 WHERE b2.author_id = a.author_id) DESC) AS rnk FROM authors a) t WHERE rnk <= 5;", "output": "SELECT a.author_id, COUNT(b.book_id) AS book_count, DENSE_RANK() OVER (ORDER BY COUNT(b.book_id) DESC) AS rnk FROM authors a LEFT JOIN books b ON b.author_id = a.author_id GROUP BY a.author_id HAVING DENSE_RANK() OVER (ORDER BY COUNT(b.book_id) DESC) <= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, o.customer_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS return_count, ROW_NUMBER() OVER (PARTITION BY o.customer_id ORDER BY o.order_date DESC) AS rn FROM orders o) t WHERE rn = 1 AND total_value > 500 AND return_count = 0;", "output": "SELECT o.order_id, o.customer_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS return_count FROM (SELECT order_id, customer_id, order_date, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC) AS rn FROM orders) o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id WHERE o.rn = 1 GROUP BY o.order_id, o.customer_id HAVING SUM(oi.price * oi.qty) > 500 AND COUNT(r.return_id) = 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, e.department_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary, RANK() OVER (PARTITION BY e.department_id ORDER BY (SELECT AVG(s2.salary) FROM salaries s2 WHERE s2.employee_id = e.employee_id) DESC) AS salary_rank, (SELECT COUNT(p.project_id) FROM projects p WHERE p.lead_id = e.employee_id) AS projects_led FROM employees e) t WHERE salary_rank <= 3 AND projects_led > 2;", "output": "SELECT e.employee_id, e.department_id, AVG(s.salary) AS avg_salary, RANK() OVER (PARTITION BY e.department_id ORDER BY AVG(s.salary) DESC) AS salary_rank, COUNT(p.project_id) AS projects_led FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id LEFT JOIN projects p ON p.lead_id = e.employee_id GROUP BY e.employee_id, e.department_id HAVING COUNT(p.project_id) > 2 AND RANK() OVER (PARTITION BY e.department_id ORDER BY AVG(s.salary) DESC) <= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.user_id = u.user_id) AS orders_count, DENSE_RANK() OVER (ORDER BY (SELECT COUNT(o2.order_id) FROM orders o2 WHERE o2.user_id = u.user_id) DESC) AS rnk, (SELECT MAX(p.post_date) FROM posts p WHERE p.user_id = u.user_id) AS last_post FROM users u) t WHERE rnk <= 20;", "output": "SELECT u.user_id, COUNT(o.order_id) AS orders_count, DENSE_RANK() OVER (ORDER BY COUNT(o.order_id) DESC) AS rnk, MAX(p.post_date) AS last_post FROM users u LEFT JOIN orders o ON o.user_id = u.user_id LEFT JOIN posts p ON p.user_id = u.user_id GROUP BY u.user_id HAVING DENSE_RANK() OVER (ORDER BY COUNT(o.order_id) DESC) <= 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = p.product_id) AS avg_rating, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.product_id = p.product_id) AS sales_count, NTILE(4) OVER (ORDER BY (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.product_id) DESC) AS quartile FROM products p) t WHERE quartile = 1 AND sales_count > 100;", "output": "SELECT p.product_id, AVG(r.rating) AS avg_rating, COUNT(s.sale_id) AS sales_count, NTILE(4) OVER (ORDER BY AVG(r.rating) DESC) AS quartile FROM products p LEFT JOIN reviews r ON r.product_id = p.product_id LEFT JOIN sales s ON s.product_id = p.product_id GROUP BY p.product_id HAVING COUNT(s.sale_id) > 100 AND NTILE(4) OVER (ORDER BY AVG(r.rating) DESC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT AVG(g.score) FROM grades g WHERE g.student_id = s.student_id) AS avg_score, (SELECT COUNT(e.exam_id) FROM exams e WHERE e.student_id = s.student_id) AS exam_count, ROW_NUMBER() OVER (ORDER BY (SELECT AVG(g2.score) FROM grades g2 WHERE g2.student_id = s.student_id) DESC) AS rn FROM students s) t WHERE rn <= 5 AND exam_count > 3;", "output": "SELECT s.student_id, AVG(g.score) AS avg_score, COUNT(e.exam_id) AS exam_count, ROW_NUMBER() OVER (ORDER BY AVG(g.score) DESC) AS rn FROM students s LEFT JOIN grades g ON g.student_id = s.student_id LEFT JOIN exams e ON e.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(e.exam_id) > 3 AND ROW_NUMBER() OVER (ORDER BY AVG(g.score) DESC) <= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS total_spent, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.customer_id = c.customer_id) AS review_count, RANK() OVER (ORDER BY (SELECT SUM(o2.total) FROM orders o2 WHERE o2.customer_id = c.customer_id) DESC) AS spend_rank FROM customers c) t WHERE spend_rank <= 10 AND review_count > 5;", "output": "SELECT c.customer_id, SUM(o.total) AS total_spent, COUNT(r.review_id) AS review_count, RANK() OVER (ORDER BY SUM(o.total) DESC) AS spend_rank FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN reviews r ON r.customer_id = c.customer_id GROUP BY c.customer_id HAVING COUNT(r.review_id) > 5 AND RANK() OVER (ORDER BY SUM(o.total) DESC) <= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT f.flight_id, (SELECT AVG(t.price) FROM tickets t WHERE t.flight_id = f.flight_id) AS avg_price, (SELECT COUNT(t2.ticket_id) FROM tickets t2 WHERE t2.flight_id = f.flight_id AND t2.status = 'cancelled') AS cancelled_count, ROW_NUMBER() OVER (PARTITION BY f.airline_id ORDER BY (SELECT AVG(t3.price) FROM tickets t3 WHERE t3.flight_id = f.flight_id) ASC) AS rn FROM flights f) t WHERE rn = 1 AND cancelled_count < 5;", "output": "SELECT f.flight_id, AVG(t.price) AS avg_price, COUNT(CASE WHEN t.status = 'cancelled' THEN 1 END) AS cancelled_count, ROW_NUMBER() OVER (PARTITION BY f.airline_id ORDER BY AVG(t.price) ASC) AS rn FROM flights f LEFT JOIN tickets t ON t.flight_id = f.flight_id GROUP BY f.flight_id, f.airline_id HAVING COUNT(CASE WHEN t.status = 'cancelled' THEN 1 END) < 5 AND ROW_NUMBER() OVER (PARTITION BY f.airline_id ORDER BY AVG(t.price) ASC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.artist_id, (SELECT COUNT(al.album_id) FROM albums al WHERE al.artist_id = a.artist_id) AS album_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.artist_id = a.artist_id) AS avg_rating, RANK() OVER (ORDER BY (SELECT COUNT(al2.album_id) FROM albums al2 WHERE al2.artist_id = a.artist_id) DESC) AS rnk FROM artists a) t WHERE rnk <= 5;", "output": "SELECT a.artist_id, COUNT(al.album_id) AS album_count, AVG(r.rating) AS avg_rating, RANK() OVER (ORDER BY COUNT(al.album_id) DESC) AS rnk FROM artists a LEFT JOIN albums al ON al.artist_id = a.artist_id LEFT JOIN ratings r ON r.artist_id = a.artist_id GROUP BY a.artist_id HAVING RANK() OVER (ORDER BY COUNT(al.album_id) DESC) <= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS ride_count, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating, DENSE_RANK() OVER (ORDER BY (SELECT COUNT(r3.ride_id) FROM rides r3 WHERE r3.driver_id = d.driver_id) DESC) AS rnk FROM drivers d) t WHERE rnk <= 10 AND avg_rating > 4.5;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS ride_count, AVG(r.rating) AS avg_rating, DENSE_RANK() OVER (ORDER BY COUNT(r.ride_id) DESC) AS rnk FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING AVG(r.rating) > 4.5 AND DENSE_RANK() OVER (ORDER BY COUNT(r.ride_id) DESC) <= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT AVG(b.price) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS avg_price, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS review_count, NTILE(5) OVER (ORDER BY (SELECT AVG(b2.price) FROM bookings b2 WHERE b2.hotel_id = h.hotel_id) DESC) AS quintile FROM hotels h) t WHERE quintile = 1 AND review_count > 50;", "output": "SELECT h.hotel_id, AVG(b.price) AS avg_price, COUNT(r.review_id) AS review_count, NTILE(5) OVER (ORDER BY AVG(b.price) DESC) AS quintile FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(r.review_id) > 50 AND NTILE(5) OVER (ORDER BY AVG(b.price) DESC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pr.project_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = pr.project_id AND t.status = 'done') AS done_tasks, (SELECT COUNT(t2.task_id) FROM tasks t2 WHERE t2.project_id = pr.project_id) AS total_tasks, RANK() OVER (ORDER BY (SELECT COUNT(t3.task_id) FROM tasks t3 WHERE t3.project_id = pr.project_id AND t3.status = 'done') DESC) AS completion_rank, (SELECT MAX(m.member_id) FROM members m WHERE m.project_id = pr.project_id) AS last_member FROM projects pr) t WHERE done_tasks = total_tasks;", "output": "SELECT pr.project_id, COUNT(CASE WHEN t.status = 'done' THEN 1 END) AS done_tasks, COUNT(t.task_id) AS total_tasks, MAX(m.member_id) AS last_member, RANK() OVER (ORDER BY COUNT(CASE WHEN t.status = 'done' THEN 1 END) DESC) AS completion_rank FROM projects pr LEFT JOIN tasks t ON t.project_id = pr.project_id LEFT JOIN members m ON m.project_id = pr.project_id GROUP BY pr.project_id HAVING COUNT(CASE WHEN t.status = 'done' THEN 1 END) = COUNT(t.task_id);" }
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.class_id, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = c.class_id) AS avg_grade, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = c.class_id) AS student_count, ROW_NUMBER() OVER (PARTITION BY c.school_id ORDER BY (SELECT AVG(g2.grade) FROM grades g2 WHERE g2.class_id = c.class_id) DESC) AS rn FROM classes c) t WHERE rn <= 3;", "output": "SELECT c.class_id, AVG(g.grade) AS avg_grade, COUNT(st.student_id) AS student_count, ROW_NUMBER() OVER (PARTITION BY c.school_id ORDER BY AVG(g.grade) DESC) AS rn FROM classes c LEFT JOIN grades g ON g.class_id = c.class_id LEFT JOIN students st ON st.class_id = c.class_id GROUP BY c.class_id, c.school_id HAVING ROW_NUMBER() OVER (PARTITION BY c.school_id ORDER BY AVG(g.grade) DESC) <= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS post_count, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.user_id = u.user_id) AS comment_count, RANK() OVER (ORDER BY (SELECT COUNT(p2.post_id) FROM posts p2 WHERE p2.user_id = u.user_id) DESC) AS rnk FROM users u) t WHERE rnk <= 50 AND comment_count > 100;", "output": "SELECT u.user_id, COUNT(p.post_id) AS post_count, COUNT(c.comment_id) AS comment_count, RANK() OVER (ORDER BY COUNT(p.post_id) DESC) AS rnk FROM users u LEFT JOIN posts p ON p.user_id = u.user_id LEFT JOIN comments c ON c.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(c.comment_id) > 100 AND RANK() OVER (ORDER BY COUNT(p.post_id) DESC) <= 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, o.customer_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS return_count, (SELECT AVG(p.rating) FROM products pr JOIN reviews p ON p.product_id = pr.product_id WHERE pr.product_id IN (SELECT oi2.product_id FROM order_items oi2 WHERE oi2.order_id = o.order_id)) AS avg_product_rating, ROW_NUMBER() OVER (PARTITION BY o.customer_id ORDER BY o.order_date DESC) AS rn FROM orders o) t WHERE rn = 1 AND total_value > 1000 AND return_count = 0 AND avg_product_rating > 4;", "output": "SELECT o.order_id, o.customer_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS return_count, AVG(p.rating) AS avg_product_rating FROM (SELECT order_id, customer_id, order_date, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY order_date DESC) AS rn FROM orders) o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id LEFT JOIN reviews p ON p.product_id = oi.product_id WHERE o.rn = 1 GROUP BY o.order_id, o.customer_id HAVING SUM(oi.price * oi.qty) > 1000 AND COUNT(r.return_id) = 0 AND AVG(p.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, e.department_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary, (SELECT COUNT(p.project_id) FROM projects p WHERE p.lead_id = e.employee_id) AS projects_led, RANK() OVER (PARTITION BY e.department_id ORDER BY (SELECT AVG(s2.salary) FROM salaries s2 WHERE s2.employee_id = e.employee_id) DESC) AS salary_rank, (SELECT COUNT(c.cert_id) FROM certifications c WHERE c.employee_id = e.employee_id) AS certs FROM employees e) t WHERE salary_rank <= 3 AND projects_led > 2 AND certs >= 1;", "output": "SELECT e.employee_id, e.department_id, AVG(s.salary) AS avg_salary, COUNT(p.project_id) AS projects_led, COUNT(c.cert_id) AS certs, RANK() OVER (PARTITION BY e.department_id ORDER BY AVG(s.salary) DESC) AS salary_rank FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id LEFT JOIN projects p ON p.lead_id = e.employee_id LEFT JOIN certifications c ON c.employee_id = e.employee_id GROUP BY e.employee_id, e.department_id HAVING COUNT(p.project_id) > 2 AND COUNT(c.cert_id) >= 1 AND RANK() OVER (PARTITION BY e.department_id ORDER BY AVG(s.salary) DESC) <= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.user_id = u.user_id) AS orders_count, (SELECT MAX(o2.order_date) FROM orders o2 WHERE o2.user_id = u.user_id) AS last_order, (SELECT SUM(p.amount) FROM payments p WHERE p.user_id = u.user_id) AS total_paid, DENSE_RANK() OVER (ORDER BY (SELECT SUM(o3.total) FROM orders o3 WHERE o3.user_id = u.user_id) DESC) AS rnk FROM users u) t WHERE rnk <= 10 AND total_paid > 500;", "output": "SELECT u.user_id, COUNT(o.order_id) AS orders_count, MAX(o.order_date) AS last_order, SUM(p.amount) AS total_paid, DENSE_RANK() OVER (ORDER BY SUM(o.total) DESC) AS rnk FROM users u LEFT JOIN orders o ON o.user_id = u.user_id LEFT JOIN payments p ON p.user_id = u.user_id GROUP BY u.user_id HAVING SUM(p.amount) > 500 AND DENSE_RANK() OVER (ORDER BY SUM(o.total) DESC) <= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, p.category_id, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = p.product_id) AS avg_rating, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.product_id = p.product_id) AS sales_count, NTILE(4) OVER (ORDER BY (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.product_id) DESC) AS quartile, (SELECT SUM(inv.stock) FROM inventory inv WHERE inv.product_id = p.product_id) AS total_stock FROM products p) t WHERE quartile = 1 AND sales_count > 100 AND total_stock > 50;", "output": "SELECT p.product_id, p.category_id, AVG(r.rating) AS avg_rating, COUNT(s.sale_id) AS sales_count, SUM(inv.stock) AS total_stock, NTILE(4) OVER (ORDER BY AVG(r.rating) DESC) AS quartile FROM products p LEFT JOIN reviews r ON r.product_id = p.product_id LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN inventory inv ON inv.product_id = p.product_id GROUP BY p.product_id, p.category_id HAVING COUNT(s.sale_id) > 100 AND SUM(inv.stock) > 50 AND NTILE(4) OVER (ORDER BY AVG(r.rating) DESC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT AVG(g.score) FROM grades g WHERE g.student_id = s.student_id) AS avg_score, (SELECT COUNT(e.exam_id) FROM exams e WHERE e.student_id = s.student_id) AS exam_count, (SELECT SUM(a.attendance) FROM attendance a WHERE a.student_id = s.student_id) AS total_attendance, ROW_NUMBER() OVER (ORDER BY (SELECT AVG(g2.score) FROM grades g2 WHERE g2.student_id = s.student_id) DESC) AS rn FROM students s) t WHERE rn <= 5 AND exam_count > 3 AND total_attendance >= 90;", "output": "SELECT s.student_id, AVG(g.score) AS avg_score, COUNT(e.exam_id) AS exam_count, SUM(a.attendance) AS total_attendance, ROW_NUMBER() OVER (ORDER BY AVG(g.score) DESC) AS rn FROM students s LEFT JOIN grades g ON g.student_id = s.student_id LEFT JOIN exams e ON e.student_id = s.student_id LEFT JOIN attendance a ON a.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(e.exam_id) > 3 AND SUM(a.attendance) >= 90 AND ROW_NUMBER() OVER (ORDER BY AVG(g.score) DESC) <= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS total_spent, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.customer_id = c.customer_id) AS review_count, (SELECT AVG(f.feedback_score) FROM feedback f WHERE f.customer_id = c.customer_id) AS avg_feedback, RANK() OVER (ORDER BY (SELECT SUM(o2.total) FROM orders o2 WHERE o2.customer_id = c.customer_id) DESC) AS spend_rank FROM customers c) t WHERE spend_rank <= 20 AND avg_feedback > 3;", "output": "SELECT c.customer_id, SUM(o.total) AS total_spent, COUNT(r.review_id) AS review_count, AVG(f.feedback_score) AS avg_feedback, RANK() OVER (ORDER BY SUM(o.total) DESC) AS spend_rank FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN reviews r ON r.customer_id = c.customer_id LEFT JOIN feedback f ON f.customer_id = c.customer_id GROUP BY c.customer_id HAVING AVG(f.feedback_score) > 3 AND RANK() OVER (ORDER BY SUM(o.total) DESC) <= 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT f.flight_id, (SELECT AVG(t.price) FROM tickets t WHERE t.flight_id = f.flight_id) AS avg_price, (SELECT COUNT(t2.ticket_id) FROM tickets t2 WHERE t2.flight_id = f.flight_id AND t2.status = 'cancelled') AS cancelled_count, (SELECT SUM(b.baggage_weight) FROM baggage b WHERE b.flight_id = f.flight_id) AS total_baggage, ROW_NUMBER() OVER (PARTITION BY f.airline_id ORDER BY (SELECT AVG(t3.price) FROM tickets t3 WHERE t3.flight_id = f.flight_id) ASC) AS rn FROM flights f) t WHERE rn = 1 AND cancelled_count < 5 AND total_baggage < 10000;", "output": "SELECT f.flight_id, AVG(t.price) AS avg_price, COUNT(CASE WHEN t.status = 'cancelled' THEN 1 END) AS cancelled_count, SUM(b.baggage_weight) AS total_baggage, ROW_NUMBER() OVER (PARTITION BY f.airline_id ORDER BY AVG(t.price) ASC) AS rn FROM flights f LEFT JOIN tickets t ON t.flight_id = f.flight_id LEFT JOIN baggage b ON b.flight_id = f.flight_id GROUP BY f.flight_id, f.airline_id HAVING COUNT(CASE WHEN t.status = 'cancelled' THEN 1 END) < 5 AND SUM(b.baggage_weight) < 10000 AND ROW_NUMBER() OVER (PARTITION BY f.airline_id ORDER BY AVG(t.price) ASC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.artist_id, (SELECT COUNT(al.album_id) FROM albums al WHERE al.artist_id = a.artist_id) AS album_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.artist_id = a.artist_id) AS avg_rating, (SELECT COUNT(s.song_id) FROM songs s WHERE s.artist_id = a.artist_id) AS song_count, RANK() OVER (ORDER BY (SELECT COUNT(al2.album_id) FROM albums al2 WHERE al2.artist_id = a.artist_id) DESC) AS rnk FROM artists a) t WHERE rnk <= 5 AND song_count > 50;", "output": "SELECT a.artist_id, COUNT(al.album_id) AS album_count, AVG(r.rating) AS avg_rating, COUNT(s.song_id) AS song_count, RANK() OVER (ORDER BY COUNT(al.album_id) DESC) AS rnk FROM artists a LEFT JOIN albums al ON al.artist_id = a.artist_id LEFT JOIN ratings r ON r.artist_id = a.artist_id LEFT JOIN songs s ON s.artist_id = a.artist_id GROUP BY a.artist_id HAVING COUNT(s.song_id) > 50 AND RANK() OVER (ORDER BY COUNT(al.album_id) DESC) <= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS ride_count, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.driver_id = d.driver_id) AS total_earnings, DENSE_RANK() OVER (ORDER BY (SELECT COUNT(r3.ride_id) FROM rides r3 WHERE r3.driver_id = d.driver_id) DESC) AS rnk FROM drivers d) t WHERE rnk <= 10 AND avg_rating > 4.5 AND total_earnings > 10000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS ride_count, AVG(r.rating) AS avg_rating, SUM(p.payment_amount) AS total_earnings, DENSE_RANK() OVER (ORDER BY COUNT(r.ride_id) DESC) AS rnk FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING AVG(r.rating) > 4.5 AND SUM(p.payment_amount) > 10000 AND DENSE_RANK() OVER (ORDER BY COUNT(r.ride_id) DESC) <= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT AVG(b.price) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS avg_price, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS review_count, (SELECT SUM(s.staff_id) FROM staff s WHERE s.hotel_id = h.hotel_id) AS staff_count, NTILE(5) OVER (ORDER BY (SELECT AVG(b2.price) FROM bookings b2 WHERE b2.hotel_id = h.hotel_id) DESC) AS quintile FROM hotels h) t WHERE quintile = 1 AND review_count > 50 AND staff_count > 100;", "output": "SELECT h.hotel_id, AVG(b.price) AS avg_price, COUNT(r.review_id) AS review_count, COUNT(s.staff_id) AS staff_count, NTILE(5) OVER (ORDER BY AVG(b.price) DESC) AS quintile FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id LEFT JOIN staff s ON s.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(r.review_id) > 50 AND COUNT(s.staff_id) > 100 AND NTILE(5) OVER (ORDER BY AVG(b.price) DESC) = 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, e.department_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary, RANK() OVER (PARTITION BY e.department_id ORDER BY (SELECT AVG(s2.salary) FROM salaries s2 WHERE s2.employee_id = e.employee_id) DESC) AS rnk FROM employees e) t WHERE rnk <= 3 AND avg_salary IS NOT NULL;", "output": "SELECT * FROM (SELECT e.employee_id, e.department_id, AVG(s.salary) AS avg_salary, RANK() OVER (PARTITION BY e.department_id ORDER BY AVG(s.salary) DESC) AS rnk FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id, e.department_id) q WHERE q.rnk <= 3 AND q.avg_salary IS NOT NULL;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.user_id, (SELECT MAX(s2.start_date) FROM subscriptions s2 WHERE s2.user_id = s.user_id) AS last_start, (SELECT COUNT(e.event_id) FROM subscription_events e WHERE e.user_id = s.user_id AND e.event_type = 'renewal') AS renewals, ROW_NUMBER() OVER (PARTITION BY s.user_id ORDER BY s.created_at DESC) AS rn FROM subscriptions s) t WHERE rn = 1 AND renewals >= 2;", "output": "SELECT u.user_id, (SELECT MAX(s2.start_date) FROM subscriptions s2 WHERE s2.user_id = u.user_id) AS last_start, COUNT(CASE WHEN e.event_type = 'renewal' THEN 1 END) AS renewals FROM (SELECT DISTINCT user_id FROM subscriptions) u LEFT JOIN subscription_events e ON e.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(CASE WHEN e.event_type = 'renewal' THEN 1 END) >= 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS pkg_cnt, (SELECT SUM(p2.weight_kg) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) x WHERE pkg_cnt > 5 AND total_weight > 100;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS pkg_cnt, SUM(p.weight_kg) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 5 AND SUM(p.weight_kg) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pr.product_id, (SELECT COUNT(rv.review_id) FROM reviews rv WHERE rv.product_id = pr.product_id AND rv.rating = 5) AS five_star, (SELECT SUM(oi.quantity) FROM order_items oi WHERE oi.product_id = pr.product_id) AS units FROM products pr) t WHERE five_star >= 10 AND units > 500;", "output": "SELECT pr.product_id, COUNT(CASE WHEN rv.rating = 5 THEN 1 END) AS five_star, SUM(oi.quantity) AS units FROM products pr LEFT JOIN reviews rv ON rv.product_id = pr.product_id LEFT JOIN order_items oi ON oi.product_id = pr.product_id GROUP BY pr.product_id HAVING COUNT(CASE WHEN rv.rating = 5 THEN 1 END) >= 10 AND SUM(oi.quantity) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT DISTINCT u.user_id FROM users u WHERE u.user_id IN (SELECT f.followee_id FROM follows f) AND EXISTS (SELECT 1 FROM posts p WHERE p.user_id = u.user_id AND p.created_at >= '2025-01-01');", "output": "SELECT DISTINCT u.user_id FROM users u JOIN follows f ON f.followee_id = u.user_id JOIN posts p ON p.user_id = u.user_id WHERE p.created_at >= '2025-01-01';"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS last_value, (SELECT MAX(r2.recorded_at) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS last_time FROM sensors sn) t WHERE last_value > 50;", "output": "SELECT sn.sensor_id, MAX(r.value) AS last_value, MAX(r.recorded_at) AS last_time FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.tx_type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.tx_type = 'debit') AS debits FROM accounts a WHERE credits - debits > 0;", "output": "SELECT a.account_id, SUM(CASE WHEN t.tx_type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.tx_type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.tx_type = 'credit' THEN t.amount END) - SUM(CASE WHEN t.tx_type = 'debit' THEN t.amount END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(*) FROM followers f WHERE f.followee_id = u.user_id) AS followers_cnt, (SELECT COUNT(*) FROM followers f2 WHERE f2.follower_id = u.user_id) AS following_cnt FROM users u) t WHERE followers_cnt >= 1000 AND following_cnt >= 100;", "output": "SELECT u.user_id, COUNT(f1.followee_id) AS followers_cnt, COUNT(f2.follower_id) AS following_cnt FROM users u LEFT JOIN followers f1 ON f1.followee_id = u.user_id LEFT JOIN followers f2 ON f2.follower_id = u.user_id GROUP BY u.user_id HAVING COUNT(f1.followee_id) >= 1000 AND COUNT(f2.follower_id) >= 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.session_id, (SELECT COUNT(l.id) FROM logs l WHERE l.session_id = s.session_id AND l.level = 'ERROR') AS err_cnt, (SELECT COUNT(l2.id) FROM logs l2 WHERE l2.session_id = s.session_id AND l2.level = 'WARN') AS warn_cnt FROM sessions s) t WHERE err_cnt > 0 OR warn_cnt > 10;", "output": "SELECT s.session_id, COUNT(CASE WHEN l.level = 'ERROR' THEN 1 END) AS err_cnt, COUNT(CASE WHEN l.level = 'WARN' THEN 1 END) AS warn_cnt FROM sessions s LEFT JOIN logs l ON l.session_id = s.session_id GROUP BY s.session_id HAVING COUNT(CASE WHEN l.level = 'ERROR' THEN 1 END) > 0 OR COUNT(CASE WHEN l.level = 'WARN' THEN 1 END) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.article_id, a.category_id, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.article_id = a.article_id) AS cmts, ROW_NUMBER() OVER (PARTITION BY a.category_id ORDER BY (SELECT COUNT(c2.comment_id) FROM comments c2 WHERE c2.article_id = a.article_id) DESC) AS rn FROM articles a) z WHERE rn <= 3;", "output": "SELECT * FROM (SELECT a.article_id, a.category_id, COUNT(c.comment_id) AS cmts, ROW_NUMBER() OVER (PARTITION BY a.category_id ORDER BY COUNT(c.comment_id) DESC) AS rn FROM articles a LEFT JOIN comments c ON c.article_id = a.article_id GROUP BY a.article_id, a.category_id) q WHERE q.rn <= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.patient_id, (SELECT COUNT(appt.id) FROM appointments appt WHERE appt.patient_id = p.patient_id) AS visit_cnt, (SELECT MAX(appt2.visit_date) FROM appointments appt2 WHERE appt2.patient_id = p.patient_id) AS last_visit FROM patients p) t WHERE visit_cnt > 2;", "output": "SELECT p.patient_id, COUNT(a.id) AS visit_cnt, MAX(a.visit_date) AS last_visit FROM patients p LEFT JOIN appointments a ON a.patient_id = p.patient_id GROUP BY p.patient_id HAVING COUNT(a.id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) x WHERE enrolled >= 30 AND avg_grade >= 70;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) >= 30 AND AVG(g.grade) >= 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM warehouses;", "output": "SELECT * FROM warehouses;"}
{"instruction": "Optimize the SQL query", "input": "SELECT order_id, total FROM orders WHERE status = 'paid';", "output": "SELECT order_id, total FROM orders WHERE status = 'paid';"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM events WHERE event_date >= '2025-01-01';", "output": "SELECT * FROM events WHERE event_date >= '2025-01-01';"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.service_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.service_id = s.service_id AND t.priority = 'high') AS high_tickets, (SELECT COUNT(t2.ticket_id) FROM tickets t2 WHERE t2.service_id = s.service_id AND t2.status = 'open') AS open_tickets FROM services s) t WHERE high_tickets > 10 OR open_tickets > 50;", "output": "SELECT s.service_id, COUNT(CASE WHEN t.priority = 'high' THEN 1 END) AS high_tickets, COUNT(CASE WHEN t.status = 'open' THEN 1 END) AS open_tickets FROM services s LEFT JOIN tickets t ON t.service_id = s.service_id GROUP BY s.service_id HAVING COUNT(CASE WHEN t.priority = 'high' THEN 1 END) > 10 OR COUNT(CASE WHEN t.status = 'open' THEN 1 END) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT inv.invoice_id, (SELECT SUM(il.line_total) FROM invoice_lines il WHERE il.invoice_id = inv.invoice_id) AS total_lines, (SELECT SUM(p.amount) FROM payments p WHERE p.invoice_id = inv.invoice_id) AS total_paid FROM invoices inv) t WHERE total_lines - total_paid > 0;", "output": "SELECT inv.invoice_id, SUM(il.line_total) AS total_lines, COALESCE(SUM(p.amount),0) AS total_paid FROM invoices inv LEFT JOIN invoice_lines il ON il.invoice_id = inv.invoice_id LEFT JOIN payments p ON p.invoice_id = inv.invoice_id GROUP BY inv.invoice_id HAVING SUM(il.line_total) - COALESCE(SUM(p.amount),0) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM tasks tk WHERE tk.assignee_id IN (SELECT u.user_id FROM users u WHERE u.active = TRUE);", "output": "SELECT tk.* FROM tasks tk JOIN users u ON u.user_id = tk.assignee_id AND u.active = TRUE;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches_played, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches_played > 50 AND avg_score > 20;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches_played, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 50 AND AVG(sc.score) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrow_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrow_count > 10 AND avg_rating >= 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrow_count, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 10 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS rest_count, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) x WHERE rest_count > 100 AND avg_rating > 3;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS rest_count, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 100 AND AVG(rv.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS play_count, (SELECT SUM(s.score) FROM scores s WHERE s.game_id = g.game_id) AS total_score FROM games g) t WHERE play_count > 5 AND total_score > 100;", "output": "SELECT g.game_id, COUNT(p.play_id) AS play_count, SUM(s.score) AS total_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores s ON s.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 5 AND SUM(s.score) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS book_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS avg_rating FROM authors a) y WHERE book_count >= 3 AND avg_rating >= 4;", "output": "SELECT a.author_id, COUNT(b.book_id) AS book_count, AVG(r.rating) AS avg_rating FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) >= 3 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(emp.employee_id) FROM employees emp WHERE emp.company_id = co.company_id) AS emp_count, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS total_salary FROM companies co) t WHERE emp_count > 100 AND total_salary > 1000000;", "output": "SELECT co.company_id, COUNT(emp.employee_id) AS emp_count, SUM(s.salary) AS total_salary FROM companies co LEFT JOIN employees emp ON emp.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(emp.employee_id) > 100 AND SUM(s.salary) > 1000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sale_count, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS total_sales FROM stores st) t WHERE sale_count > 200 AND total_sales > 50000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sale_count, SUM(s.amount) AS total_sales FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 200 AND SUM(s.amount) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS posts_count, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.user_id = u.user_id) AS comments_count, RANK() OVER (ORDER BY (SELECT COUNT(p2.post_id) FROM posts p2 WHERE p2.user_id = u.user_id) DESC) AS rnk FROM users u) t WHERE rnk <= 10 AND comments_count > 50;", "output": "SELECT u.user_id, COUNT(p.post_id) AS posts_count, COUNT(c.comment_id) AS comments_count, RANK() OVER (ORDER BY COUNT(p.post_id) DESC) AS rnk FROM users u LEFT JOIN posts p ON p.user_id = u.user_id LEFT JOIN comments c ON c.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(c.comment_id) > 50 AND RANK() OVER (ORDER BY COUNT(p.post_id) DESC) <= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, o.customer_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS return_count FROM orders o) t WHERE total_value > 500 AND return_count = 0;", "output": "SELECT o.order_id, o.customer_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS return_count FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id, o.customer_id HAVING SUM(oi.price * oi.qty) > 500 AND COUNT(r.return_id) = 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, e.department_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE avg_salary > 60000;", "output": "SELECT e.employee_id, e.department_id, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id, e.department_id HAVING AVG(s.salary) > 60000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.customer_id = c.customer_id) AS order_count, (SELECT SUM(o2.total) FROM orders o2 WHERE o2.customer_id = c.customer_id) AS total_spent FROM customers c) t WHERE order_count > 5 AND total_spent > 2000;", "output": "SELECT c.customer_id, COUNT(o.order_id) AS order_count, SUM(o.total) AS total_spent FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id GROUP BY c.customer_id HAVING COUNT(o.order_id) > 5 AND SUM(o.total) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.product_id = p.product_id) AS review_count, (SELECT AVG(r2.rating) FROM reviews r2 WHERE r2.product_id = p.product_id) AS avg_rating FROM products p) t WHERE review_count > 20 AND avg_rating > 4;", "output": "SELECT p.product_id, COUNT(r.review_id) AS review_count, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN reviews r ON r.product_id = p.product_id GROUP BY p.product_id HAVING COUNT(r.review_id) > 20 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade, (SELECT COUNT(e.exam_id) FROM exams e WHERE e.student_id = s.student_id) AS exam_count FROM students s) t WHERE avg_grade > 80 AND exam_count >= 3;", "output": "SELECT s.student_id, AVG(g.grade) AS avg_grade, COUNT(e.exam_id) AS exam_count FROM students s LEFT JOIN grades g ON g.student_id = s.student_id LEFT JOIN exams e ON e.student_id = s.student_id GROUP BY s.student_id HAVING AVG(g.grade) > 80 AND COUNT(e.exam_id) >= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS book_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS avg_rating FROM authors a) t WHERE book_count > 5 AND avg_rating > 3;", "output": "SELECT a.author_id, COUNT(b.book_id) AS book_count, AVG(r.rating) AS avg_rating FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 5 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM warehouses;", "output": "SELECT * FROM warehouses;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM orders WHERE order_date BETWEEN '2025-01-01' AND '2025-12-31';", "output": "SELECT * FROM orders WHERE order_date BETWEEN '2025-01-01' AND '2025-12-31';"}
{"instruction": "Optimize the SQL query", "input": "SELECT order_id, total FROM orders WHERE status = 'paid';", "output": "SELECT order_id, total FROM orders WHERE status = 'paid';"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM events WHERE event_date >= '2025-01-01';", "output": "SELECT * FROM events WHERE event_date >= '2025-01-01';"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS booking_count, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE booking_count > 200 AND avg_rating >= 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS booking_count, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 200 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS ride_count, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE ride_count > 100 AND avg_rating >= 4.5;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS ride_count, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 100 AND AVG(r.rating) >= 4.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS rest_count, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE rest_count > 500 AND avg_rating > 3;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS rest_count, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 500 AND AVG(rv.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS play_count, (SELECT SUM(s.score) FROM scores s WHERE s.game_id = g.game_id) AS total_score FROM games g) t WHERE play_count > 10 AND total_score > 200;", "output": "SELECT g.game_id, COUNT(p.play_id) AS play_count, SUM(s.score) AS total_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores s ON s.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 10 AND SUM(s.score) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS emp_count, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS total_salary FROM companies co) t WHERE emp_count > 500 AND total_salary > 5000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS emp_count, SUM(s.salary) AS total_salary FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 500 AND SUM(s.salary) > 5000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sale_count, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS total_sales FROM stores st) t WHERE sale_count > 1000 AND total_sales > 100000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sale_count, SUM(s.amount) AS total_sales FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 1000 AND SUM(s.amount) > 100000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches_played, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches_played > 30 AND avg_score > 25;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches_played, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 30 AND AVG(sc.score) > 25;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrow_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrow_count > 20 AND avg_rating > 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrow_count, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 20 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.user_id = u.user_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.user_id = u.user_id AND t2.type = 'debit') AS debits FROM users u) t WHERE credits - debits > 100;", "output": "SELECT u.user_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM users u LEFT JOIN transactions t ON t.user_id = u.user_id GROUP BY u.user_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) - SUM(CASE WHEN t.type = 'debit' THEN t.amount END) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.department_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.department_id = d.department_id) AS emp_count, (SELECT AVG(s.salary) FROM salaries s WHERE s.department_id = d.department_id) AS avg_salary FROM departments d) t WHERE emp_count > 20 AND avg_salary > 70000;", "output": "SELECT d.department_id, COUNT(e.employee_id) AS emp_count, AVG(s.salary) AS avg_salary FROM departments d LEFT JOIN employees e ON e.department_id = d.department_id LEFT JOIN salaries s ON s.department_id = d.department_id GROUP BY d.department_id HAVING COUNT(e.employee_id) > 20 AND AVG(s.salary) > 70000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT MAX(t.date) FROM transactions t WHERE t.account_id = a.account_id) AS last_tx, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id) AS total_amount FROM accounts a) t WHERE total_amount > 1000;", "output": "SELECT a.account_id, MAX(t.date) AS last_tx, SUM(t.amount) AS total_amount FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(t.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pr.project_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = pr.project_id) AS task_count, (SELECT SUM(t2.hours) FROM tasks t2 WHERE t2.project_id = pr.project_id) AS total_hours FROM projects pr) t WHERE task_count > 10 AND total_hours > 100;", "output": "SELECT pr.project_id, COUNT(t.task_id) AS task_count, SUM(t.hours) AS total_hours FROM projects pr LEFT JOIN tasks t ON t.project_id = pr.project_id GROUP BY pr.project_id HAVING COUNT(t.task_id) > 10 AND SUM(t.hours) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS student_count, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE student_count > 20 AND avg_grade >= 75;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS student_count, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 20 AND AVG(g.grade) >= 75;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.login_id) FROM logins l WHERE l.user_id = u.user_id) AS login_count, (SELECT MAX(l2.login_time) FROM logins l2 WHERE l2.user_id = u.user_id) AS last_login FROM users u) t WHERE login_count > 5;", "output": "SELECT u.user_id, COUNT(l.login_id) AS login_count, MAX(l.login_time) AS last_login FROM users u LEFT JOIN logins l ON l.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(l.login_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT SUM(s.amount) FROM sales s WHERE s.product_id = p.product_id) AS total_sales, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = p.product_id) AS avg_rating FROM products p) t WHERE total_sales > 1000 AND avg_rating > 4;", "output": "SELECT p.product_id, SUM(s.amount) AS total_sales, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews r ON r.product_id = p.product_id GROUP BY p.product_id HAVING SUM(s.amount) > 1000 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.customer_id = c.customer_id) AS order_count FROM customers c) t WHERE order_count > 3;", "output": "SELECT c.customer_id, COUNT(o.order_id) AS order_count FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id GROUP BY c.customer_id HAVING COUNT(o.order_id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE avg_salary > 50000;", "output": "SELECT e.employee_id, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING AVG(s.salary) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exam_count FROM students s) t WHERE avg_grade >= 80 AND exam_count >= 2;", "output": "SELECT s.student_id, AVG(g.grade) AS avg_grade, COUNT(ex.exam_id) AS exam_count FROM students s LEFT JOIN grades g ON g.student_id = s.student_id LEFT JOIN exams ex ON ex.student_id = s.student_id GROUP BY s.student_id HAVING AVG(g.grade) >= 80 AND COUNT(ex.exam_id) >= 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS booking_count, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE booking_count > 100 AND avg_rating >= 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS booking_count, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 100 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS ride_count, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE ride_count > 50 AND avg_rating > 4.2;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS ride_count, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 50 AND AVG(r.rating) > 4.2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS rest_count FROM cities c) t WHERE rest_count > 200;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS rest_count FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS play_count FROM games g) t WHERE play_count > 10;", "output": "SELECT g.game_id, COUNT(p.play_id) AS play_count FROM games g LEFT JOIN plays p ON p.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS emp_count FROM companies co) t WHERE emp_count > 100;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS emp_count FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT SUM(s.amount) FROM sales s WHERE s.store_id = st.store_id) AS total_sales FROM stores st) t WHERE total_sales > 10000;", "output": "SELECT st.store_id, SUM(s.amount) AS total_sales FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING SUM(s.amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches_played FROM players pl) t WHERE matches_played > 20;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches_played FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrow_count FROM books b) t WHERE borrow_count > 5;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrow_count FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS student_count FROM classes cl) t WHERE student_count > 25;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS student_count FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 25;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pr.project_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = pr.project_id) AS task_count FROM projects pr) t WHERE task_count > 8;", "output": "SELECT pr.project_id, COUNT(t.task_id) AS task_count FROM projects pr LEFT JOIN tasks t ON t.project_id = pr.project_id GROUP BY pr.project_id HAVING COUNT(t.task_id) > 8;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id) AS total_amount FROM accounts a) t WHERE total_amount > 1000;", "output": "SELECT a.account_id, SUM(t.amount) AS total_amount FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(t.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.patient_id, (SELECT COUNT(appt.appointment_id) FROM appointments appt WHERE appt.patient_id = p.patient_id) AS appointment_count FROM patients p) t WHERE appointment_count > 2;", "output": "SELECT p.patient_id, COUNT(appt.appointment_id) AS appointment_count FROM patients p LEFT JOIN appointments appt ON appt.patient_id = p.patient_id GROUP BY p.patient_id HAVING COUNT(appt.appointment_id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS ticket_count FROM events ev) t WHERE ticket_count > 50;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS ticket_count FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.supplier_id, (SELECT COUNT(p.product_id) FROM products p WHERE p.supplier_id = s.supplier_id) AS product_count FROM suppliers s) t WHERE product_count > 10;", "output": "SELECT s.supplier_id, COUNT(p.product_id) AS product_count FROM suppliers s LEFT JOIN products p ON p.supplier_id = s.supplier_id GROUP BY s.supplier_id HAVING COUNT(p.product_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.user_id = u.user_id) AS order_count, (SELECT SUM(p.amount) FROM payments p WHERE p.user_id = u.user_id) AS total_paid FROM users u) t WHERE order_count > 5 AND total_paid > 500;", "output": "SELECT u.user_id, COUNT(o.order_id) AS order_count, SUM(p.amount) AS total_paid FROM users u LEFT JOIN orders o ON o.user_id = u.user_id LEFT JOIN payments p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(o.order_id) > 5 AND SUM(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS project_count FROM employees e) t WHERE avg_salary > 60000 AND project_count >= 2;", "output": "SELECT e.employee_id, AVG(s.salary) AS avg_salary, COUNT(p.project_id) AS project_count FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id LEFT JOIN projects p ON p.employee_id = e.employee_id GROUP BY e.employee_id HAVING AVG(s.salary) > 60000 AND COUNT(p.project_id) >= 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exam_count, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE exam_count > 3 AND avg_grade >= 75;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exam_count, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 3 AND AVG(g.grade) >= 75;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS booking_count, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating, (SELECT SUM(s.staff_id) FROM staff s WHERE s.hotel_id = h.hotel_id) AS staff_count FROM hotels h) t WHERE booking_count > 100 AND avg_rating > 4 AND staff_count > 50;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS booking_count, AVG(r.rating) AS avg_rating, COUNT(s.staff_id) AS staff_count FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id LEFT JOIN staff s ON s.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 100 AND AVG(r.rating) > 4 AND COUNT(s.staff_id) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS ride_count, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS total_earned FROM drivers d) t WHERE ride_count > 50 AND avg_rating >= 4.5 AND total_earned > 5000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS ride_count, AVG(r.rating) AS avg_rating, SUM(p.amount) AS total_earned FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 50 AND AVG(r.rating) >= 4.5 AND SUM(p.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS total_spent, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.customer_id = c.customer_id) AS review_count FROM customers c) t WHERE total_spent > 1000 AND review_count >= 5;", "output": "SELECT c.customer_id, SUM(o.total) AS total_spent, COUNT(r.review_id) AS review_count FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN reviews r ON r.customer_id = c.customer_id GROUP BY c.customer_id HAVING SUM(o.total) > 1000 AND COUNT(r.review_id) >= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT SUM(s.amount) FROM sales s WHERE s.product_id = p.product_id) AS total_sales, (SELECT COUNT(rv.review_id) FROM reviews rv WHERE rv.product_id = p.product_id) AS review_count FROM products p) t WHERE total_sales > 500 AND review_count >= 10;", "output": "SELECT p.product_id, SUM(s.amount) AS total_sales, COUNT(rv.review_id) AS review_count FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews rv ON rv.product_id = p.product_id GROUP BY p.product_id HAVING SUM(s.amount) > 500 AND COUNT(rv.review_id) >= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches_played, (SELECT SUM(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS total_score FROM players pl) t WHERE matches_played > 20 AND total_score > 200;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches_played, SUM(sc.score) AS total_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20 AND SUM(sc.score) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrow_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrow_count > 5 AND avg_rating >= 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrow_count, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 5 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS student_count, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE student_count > 20 AND avg_grade >= 70;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS student_count, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 20 AND AVG(g.grade) >= 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS emp_count, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS total_salary FROM companies co) t WHERE emp_count > 100 AND total_salary > 1000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS emp_count, SUM(s.salary) AS total_salary FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 100 AND SUM(s.salary) > 1000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sale_count, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS total_sales FROM stores st) t WHERE sale_count > 200 AND total_sales > 5000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sale_count, SUM(s.amount) AS total_sales FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 200 AND SUM(s.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.supplier_id, (SELECT COUNT(p.product_id) FROM products p WHERE p.supplier_id = s.supplier_id) AS product_count FROM suppliers s) t WHERE product_count > 15;", "output": "SELECT s.supplier_id, COUNT(p.product_id) AS product_count FROM suppliers s LEFT JOIN products p ON p.supplier_id = s.supplier_id GROUP BY s.supplier_id HAVING COUNT(p.product_id) > 15;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS ticket_count, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE ticket_count > 50 AND total_revenue > 10000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS ticket_count, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50 AND SUM(p.payment_amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits - debits > 0;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) - SUM(CASE WHEN t.type = 'debit' THEN t.amount END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 100 AND avg_val > 50;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 100 AND AVG(r.value) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS book_count, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE book_count > 2 AND rating_sum > 10;", "output": "SELECT a.author_id, COUNT(b.book_id) AS book_count, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 2 AND SUM(r.rating) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrollment_count, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrollment_count > 30 AND avg_grade >= 65;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrollment_count, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 30 AND AVG(g.grade) >= 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS pkg_count, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE pkg_count > 5 AND total_weight > 100;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS pkg_count, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 5 AND SUM(p.weight) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(m.message_id) FROM messages m WHERE m.user_id = u.user_id) AS msg_count, (SELECT MAX(m2.sent_at) FROM messages m2 WHERE m2.user_id = u.user_id) AS last_msg FROM users u) t WHERE msg_count > 100;", "output": "SELECT u.user_id, COUNT(m.message_id) AS msg_count, MAX(m.sent_at) AS last_msg FROM users u LEFT JOIN messages m ON m.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(m.message_id) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.customer_id = c.customer_id) AS order_count, (SELECT MAX(p.payment_date) FROM payments p WHERE p.customer_id = c.customer_id) AS last_payment FROM customers c) t WHERE order_count > 10;", "output": "SELECT c.customer_id, COUNT(o.order_id) AS order_count, MAX(p.payment_date) AS last_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN payments p ON p.customer_id = c.customer_id GROUP BY c.customer_id HAVING COUNT(o.order_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS project_count, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE project_count > 2 AND avg_salary > 50000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS project_count, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 2 AND AVG(s.salary) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS course_count, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE course_count > 3 AND avg_grade > 70;", "output": "SELECT s.student_id, COUNT(c.course_id) AS course_count, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 3 AND AVG(g.grade) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT SUM(s.amount) FROM sales s WHERE s.product_id = p.product_id) AS total_sales, (SELECT COUNT(rv.review_id) FROM reviews rv WHERE rv.product_id = p.product_id) AS review_count FROM products p) t WHERE total_sales > 500 AND review_count > 20;", "output": "SELECT p.product_id, SUM(s.amount) AS total_sales, COUNT(rv.review_id) AS review_count FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews rv ON rv.product_id = p.product_id GROUP BY p.product_id HAVING SUM(s.amount) > 500 AND COUNT(rv.review_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS booking_count, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE booking_count > 200 AND avg_rating >= 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS booking_count, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 200 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS ride_count, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE ride_count > 100 AND avg_rating > 4.5;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS ride_count, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 100 AND AVG(r.rating) > 4.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS play_count, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS total_score FROM games g) t WHERE play_count > 10 AND total_score > 200;", "output": "SELECT g.game_id, COUNT(p.play_id) AS play_count, SUM(sc.score) AS total_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 10 AND SUM(sc.score) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS rest_count, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE rest_count > 500 AND avg_rating > 3;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS rest_count, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 500 AND AVG(rv.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS emp_count, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS total_salary FROM companies co) t WHERE emp_count > 500 AND total_salary > 5000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS emp_count, SUM(s.salary) AS total_salary FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 500 AND SUM(s.salary) > 5000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sale_count, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS total_sales FROM stores st) t WHERE sale_count > 1000 AND total_sales > 100000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sale_count, SUM(s.amount) AS total_sales FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 1000 AND SUM(s.amount) > 100000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches_played, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches_played > 30 AND avg_score > 25;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches_played, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 30 AND AVG(sc.score) > 25;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrow_count, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrow_count > 20 AND avg_rating > 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrow_count, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 20 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.patient_id, (SELECT COUNT(appt.appointment_id) FROM appointments appt WHERE appt.patient_id = p.patient_id) AS appointment_count, (SELECT MAX(appt2.date) FROM appointments appt2 WHERE appt2.patient_id = p.patient_id) AS last_appointment FROM patients p) t WHERE appointment_count > 2;", "output": "SELECT p.patient_id, COUNT(appt.appointment_id) AS appointment_count, MAX(appt.date) AS last_appointment FROM patients p LEFT JOIN appointments appt ON appt.patient_id = p.patient_id GROUP BY p.patient_id HAVING COUNT(appt.appointment_id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS ticket_count, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE ticket_count > 50 AND total_revenue > 10000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS ticket_count, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50 AND SUM(p.payment_amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits - debits > 0;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) - SUM(CASE WHEN t.type = 'debit' THEN t.amount END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS pkg_count, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE pkg_count > 5 AND total_weight > 100;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS pkg_count, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 5 AND SUM(p.weight) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS book_count, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE book_count > 2 AND rating_sum > 10;", "output": "SELECT a.author_id, COUNT(b.book_id) AS book_count, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 2 AND SUM(r.rating) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(f.follow_id) FROM follows f WHERE f.user_id = u.user_id) AS followers, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS posts FROM users u) t WHERE followers > 100 AND posts > 10;", "output": "SELECT u.user_id, COUNT(f.follow_id) AS followers, COUNT(p.post_id) AS posts FROM users u LEFT JOIN follows f ON f.user_id = u.user_id LEFT JOIN posts p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(f.follow_id) > 100 AND COUNT(p.post_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS return_count FROM orders o) t WHERE total_value > 200 AND return_count = 0;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS return_count FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 200 AND COUNT(r.return_id) = 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS proj_count FROM employees e) t WHERE avg_salary > 50000 AND proj_count >= 1;", "output": "SELECT e.employee_id, AVG(s.salary) AS avg_salary, COUNT(p.project_id) AS proj_count FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id LEFT JOIN projects p ON p.employee_id = e.employee_id GROUP BY e.employee_id HAVING AVG(s.salary) > 50000 AND COUNT(p.project_id) >= 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE exams > 2 AND avg_grade > 75;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 2 AND AVG(g.grade) > 75;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS rating FROM hotels h) t WHERE bookings > 300 AND rating >= 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 300 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS earnings FROM drivers d) t WHERE rides > 100 AND avg_rating >= 4.5 AND earnings > 1000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS avg_rating, SUM(p.amount) AS earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 100 AND AVG(r.rating) >= 4.5 AND SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS total, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.customer_id = c.customer_id) AS reviews FROM customers c) t WHERE total > 500 AND reviews > 3;", "output": "SELECT c.customer_id, SUM(o.total) AS total, COUNT(r.review_id) AS reviews FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN reviews r ON r.customer_id = c.customer_id GROUP BY c.customer_id HAVING SUM(o.total) > 500 AND COUNT(r.review_id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.product_id = p.product_id) AS sales, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.product_id = p.product_id) AS avg_rating FROM products p) t WHERE sales > 50 AND avg_rating > 4;", "output": "SELECT p.product_id, COUNT(s.sale_id) AS sales, AVG(rv.rating) AS avg_rating FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews rv ON rv.product_id = p.product_id GROUP BY p.product_id HAVING COUNT(s.sale_id) > 50 AND AVG(rv.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 20 AND avg_score > 30;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20 AND AVG(sc.score) > 30;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 5 AND avg_rating >= 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 5 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE students > 25 AND avg_grade > 70;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 25 AND AVG(g.grade) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 100 AND payroll > 1000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 100 AND SUM(s.salary) > 1000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS total FROM stores st) t WHERE sales > 200 AND total > 10000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS total FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 200 AND SUM(s.amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE tickets > 50 AND revenue > 5000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50 AND SUM(p.payment_amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.supplier_id, (SELECT COUNT(p.product_id) FROM products p WHERE p.supplier_id = s.supplier_id) AS products, (SELECT SUM(p2.price) FROM products p2 WHERE p2.supplier_id = s.supplier_id) AS total_value FROM suppliers s) t WHERE products > 10 AND total_value > 1000;", "output": "SELECT s.supplier_id, COUNT(p.product_id) AS products, SUM(p.price) AS total_value FROM suppliers s LEFT JOIN products p ON p.supplier_id = s.supplier_id GROUP BY s.supplier_id HAVING COUNT(p.product_id) > 10 AND SUM(p.price) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS weight FROM shipments sh) t WHERE packages > 5 AND weight > 100;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 5 AND SUM(p.weight) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 20 AND avg_grade > 65;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 20 AND AVG(g.grade) > 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 100 AND avg_val > 50;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 100 AND AVG(r.value) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.login_id) FROM logins l WHERE l.user_id = u.user_id) AS logins, (SELECT MAX(l2.login_time) FROM logins l2 WHERE l2.user_id = u.user_id) AS last_login FROM users u) t WHERE logins > 5;", "output": "SELECT u.user_id, COUNT(l.login_id) AS logins, MAX(l.login_time) AS last_login FROM users u LEFT JOIN logins l ON l.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(l.login_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT SUM(s.amount) FROM sales s WHERE s.product_id = p.product_id) AS total_sales, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = p.product_id) AS avg_rating FROM products p) t WHERE total_sales > 1000 AND avg_rating > 4;", "output": "SELECT p.product_id, SUM(s.amount) AS total_sales, AVG(r.rating) AS avg_rating FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews r ON r.product_id = p.product_id GROUP BY p.product_id HAVING SUM(s.amount) > 1000 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.customer_id = c.customer_id) AS orders FROM customers c) t WHERE orders > 3;", "output": "SELECT c.customer_id, COUNT(o.order_id) AS orders FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id GROUP BY c.customer_id HAVING COUNT(o.order_id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS salary FROM employees e) t WHERE salary > 50000;", "output": "SELECT e.employee_id, AVG(s.salary) AS salary FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING AVG(s.salary) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams FROM students s) t WHERE avg_grade >= 80 AND exams >= 2;", "output": "SELECT s.student_id, AVG(g.grade) AS avg_grade, COUNT(ex.exam_id) AS exams FROM students s LEFT JOIN grades g ON g.student_id = s.student_id LEFT JOIN exams ex ON ex.student_id = s.student_id GROUP BY s.student_id HAVING AVG(g.grade) >= 80 AND COUNT(ex.exam_id) >= 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS rating FROM hotels h) t WHERE bookings > 100 AND rating >= 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 100 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS rating FROM drivers d) t WHERE rides > 50 AND rating > 4.2;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 50 AND AVG(r.rating) > 4.2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants FROM cities c) t WHERE restaurants > 200;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays FROM games g) t WHERE plays > 10;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays FROM games g LEFT JOIN plays p ON p.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees FROM companies co) t WHERE employees > 100;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT SUM(s.amount) FROM sales s WHERE s.store_id = st.store_id) AS sales FROM stores st) t WHERE sales > 10000;", "output": "SELECT st.store_id, SUM(s.amount) AS sales FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING SUM(s.amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches FROM players pl) t WHERE matches > 20;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows FROM books b) t WHERE borrows > 5;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS students FROM classes cl) t WHERE students > 25;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS students FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 25;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pr.project_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = pr.project_id) AS tasks FROM projects pr) t WHERE tasks > 8;", "output": "SELECT pr.project_id, COUNT(t.task_id) AS tasks FROM projects pr LEFT JOIN tasks t ON t.project_id = pr.project_id GROUP BY pr.project_id HAVING COUNT(t.task_id) > 8;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id) AS total FROM accounts a) t WHERE total > 1000;", "output": "SELECT a.account_id, SUM(t.amount) AS total FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(t.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.patient_id, (SELECT COUNT(appt.appointment_id) FROM appointments appt WHERE appt.patient_id = p.patient_id) AS appts FROM patients p) t WHERE appts > 2;", "output": "SELECT p.patient_id, COUNT(appt.appointment_id) AS appts FROM patients p LEFT JOIN appointments appt ON appt.patient_id = p.patient_id GROUP BY p.patient_id HAVING COUNT(appt.appointment_id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS tickets FROM events ev) t WHERE tickets > 50;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS tickets FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.supplier_id, (SELECT COUNT(p.product_id) FROM products p WHERE p.supplier_id = s.supplier_id) AS products FROM suppliers s) t WHERE products > 10;", "output": "SELECT s.supplier_id, COUNT(p.product_id) AS products FROM suppliers s LEFT JOIN products p ON p.supplier_id = s.supplier_id GROUP BY s.supplier_id HAVING COUNT(p.product_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.user_id = u.user_id) AS orders, (SELECT SUM(p.amount) FROM payments p WHERE p.user_id = u.user_id) AS total_paid FROM users u) t WHERE orders > 5 AND total_paid > 500;", "output": "SELECT u.user_id, COUNT(o.order_id) AS orders, SUM(p.amount) AS total_paid FROM users u LEFT JOIN orders o ON o.user_id = u.user_id LEFT JOIN payments p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(o.order_id) > 5 AND SUM(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS salary, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects FROM employees e) t WHERE salary > 60000 AND projects >= 2;", "output": "SELECT e.employee_id, AVG(s.salary) AS salary, COUNT(p.project_id) AS projects FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id LEFT JOIN projects p ON p.employee_id = e.employee_id GROUP BY e.employee_id HAVING AVG(s.salary) > 60000 AND COUNT(p.project_id) >= 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS grade FROM students s) t WHERE exams > 3 AND grade >= 75;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 3 AND AVG(g.grade) >= 75;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS rating FROM hotels h) t WHERE bookings > 100 AND rating > 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 100 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS rating, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS earnings FROM drivers d) t WHERE rides > 50 AND rating >= 4.5 AND earnings > 5000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS rating, SUM(p.amount) AS earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 50 AND AVG(r.rating) >= 4.5 AND SUM(p.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS spent, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.customer_id = c.customer_id) AS reviews FROM customers c) t WHERE spent > 1000 AND reviews >= 5;", "output": "SELECT c.customer_id, SUM(o.total) AS spent, COUNT(r.review_id) AS reviews FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN reviews r ON r.customer_id = c.customer_id GROUP BY c.customer_id HAVING SUM(o.total) > 1000 AND COUNT(r.review_id) >= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT SUM(s.amount) FROM sales s WHERE s.product_id = p.product_id) AS sales, (SELECT COUNT(rv.review_id) FROM reviews rv WHERE rv.product_id = p.product_id) AS reviews FROM products p) t WHERE sales > 500 AND reviews >= 10;", "output": "SELECT p.product_id, SUM(s.amount) AS sales, COUNT(rv.review_id) AS reviews FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews rv ON rv.product_id = p.product_id GROUP BY p.product_id HAVING SUM(s.amount) > 500 AND COUNT(rv.review_id) >= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT SUM(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS score FROM players pl) t WHERE matches > 20 AND score > 200;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, SUM(sc.score) AS score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20 AND SUM(sc.score) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS rating FROM books b) t WHERE borrows > 5 AND rating >= 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 5 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS grade FROM classes cl) t WHERE students > 20 AND grade >= 70;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS students, AVG(g.grade) AS grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 20 AND AVG(g.grade) >= 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 100 AND payroll > 1000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 100 AND SUM(s.salary) > 1000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 200 AND revenue > 5000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 200 AND SUM(s.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.supplier_id, (SELECT COUNT(p.product_id) FROM products p WHERE p.supplier_id = s.supplier_id) AS products FROM suppliers s) t WHERE products > 15;", "output": "SELECT s.supplier_id, COUNT(p.product_id) AS products FROM suppliers s LEFT JOIN products p ON p.supplier_id = s.supplier_id GROUP BY s.supplier_id HAVING COUNT(p.product_id) > 15;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE tickets > 50 AND revenue > 10000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50 AND SUM(p.payment_amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits - debits > 0;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) - SUM(CASE WHEN t.type = 'debit' THEN t.amount END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 100 AND avg_val > 50;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 100 AND AVG(r.value) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE books > 2 AND rating_sum > 10;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 2 AND SUM(r.rating) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS grade FROM courses c) t WHERE enrolled > 30 AND grade >= 65;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 30 AND AVG(g.grade) >= 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS weight FROM shipments sh) t WHERE packages > 5 AND weight > 100;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 5 AND SUM(p.weight) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(m.message_id) FROM messages m WHERE m.user_id = u.user_id) AS messages, (SELECT MAX(m2.sent_at) FROM messages m2 WHERE m2.user_id = u.user_id) AS last_msg FROM users u) t WHERE messages > 100;", "output": "SELECT u.user_id, COUNT(m.message_id) AS messages, MAX(m.sent_at) AS last_msg FROM users u LEFT JOIN messages m ON m.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(m.message_id) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.customer_id = c.customer_id) AS orders, (SELECT MAX(p.payment_date) FROM payments p WHERE p.customer_id = c.customer_id) AS last_payment FROM customers c) t WHERE orders > 10;", "output": "SELECT c.customer_id, COUNT(o.order_id) AS orders, MAX(p.payment_date) AS last_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN payments p ON p.customer_id = c.customer_id GROUP BY c.customer_id HAVING COUNT(o.order_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS salary FROM employees e) t WHERE projects > 2 AND salary > 50000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, AVG(s.salary) AS salary FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 2 AND AVG(s.salary) > 50000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS grade FROM students s) t WHERE courses > 3 AND grade > 70;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, AVG(g.grade) AS grade FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 3 AND AVG(g.grade) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT SUM(s.amount) FROM sales s WHERE s.product_id = p.product_id) AS sales, (SELECT COUNT(rv.review_id) FROM reviews rv WHERE rv.product_id = p.product_id) AS reviews FROM products p) t WHERE sales > 500 AND reviews > 20;", "output": "SELECT p.product_id, SUM(s.amount) AS sales, COUNT(rv.review_id) AS reviews FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews rv ON rv.product_id = p.product_id GROUP BY p.product_id HAVING SUM(s.amount) > 500 AND COUNT(rv.review_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS rating FROM hotels h) t WHERE bookings > 200 AND rating >= 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 200 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS rating FROM drivers d) t WHERE rides > 100 AND rating > 4.5;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 100 AND AVG(r.rating) > 4.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS score FROM games g) t WHERE plays > 10 AND score > 200;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 10 AND SUM(sc.score) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS rating FROM cities c) t WHERE restaurants > 500 AND rating > 3;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 500 AND AVG(rv.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 500 AND payroll > 5000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 500 AND SUM(s.salary) > 5000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 1000 AND revenue > 100000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 1000 AND SUM(s.amount) > 100000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 30 AND avg_score > 25;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 30 AND AVG(sc.score) > 25;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS rating FROM books b) t WHERE borrows > 20 AND rating > 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 20 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.patient_id, (SELECT COUNT(appt.appointment_id) FROM appointments appt WHERE appt.patient_id = p.patient_id) AS appointments, (SELECT MAX(appt2.date) FROM appointments appt2 WHERE appt2.patient_id = p.patient_id) AS last_appt FROM patients p) t WHERE appointments > 2;", "output": "SELECT p.patient_id, COUNT(appt.appointment_id) AS appointments, MAX(appt.date) AS last_appt FROM patients p LEFT JOIN appointments appt ON appt.patient_id = p.patient_id GROUP BY p.patient_id HAVING COUNT(appt.appointment_id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE tickets > 50 AND revenue > 10000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50 AND SUM(p.payment_amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits - debits > 0;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) - SUM(CASE WHEN t.type = 'debit' THEN t.amount END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS weight FROM shipments sh) t WHERE packages > 5 AND weight > 100;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 5 AND SUM(p.weight) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(f.follow_id) FROM follows f WHERE f.user_id = u.user_id) AS followers, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS posts FROM users u) t WHERE followers > 100 AND posts > 10;", "output": "SELECT u.user_id, COUNT(f.follow_id) AS followers, COUNT(p.post_id) AS posts FROM users u LEFT JOIN follows f ON f.user_id = u.user_id LEFT JOIN posts p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(f.follow_id) > 100 AND COUNT(p.post_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS returns FROM orders o) t WHERE total_value > 200 AND returns = 0;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS returns FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 200 AND COUNT(r.return_id) = 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS salary, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects FROM employees e) t WHERE salary > 50000 AND projects > 1;", "output": "SELECT e.employee_id, AVG(s.salary) AS salary, COUNT(p.project_id) AS projects FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id LEFT JOIN projects p ON p.employee_id = e.employee_id GROUP BY e.employee_id HAVING AVG(s.salary) > 50000 AND COUNT(p.project_id) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS grade FROM students s) t WHERE exams > 2 AND grade > 75;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 2 AND AVG(g.grade) > 75;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS rating FROM hotels h) t WHERE bookings > 300 AND rating >= 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 300 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS rating, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS earnings FROM drivers d) t WHERE rides > 100 AND rating >= 4.5 AND earnings > 1000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS rating, SUM(p.amount) AS earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 100 AND AVG(r.rating) >= 4.5 AND SUM(p.amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS spent, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.customer_id = c.customer_id) AS reviews FROM customers c) t WHERE spent > 500 AND reviews > 3;", "output": "SELECT c.customer_id, SUM(o.total) AS spent, COUNT(r.review_id) AS reviews FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN reviews r ON r.customer_id = c.customer_id GROUP BY c.customer_id HAVING SUM(o.total) > 500 AND COUNT(r.review_id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.product_id = p.product_id) AS sales, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.product_id = p.product_id) AS rating FROM products p) t WHERE sales > 50 AND rating > 4;", "output": "SELECT p.product_id, COUNT(s.sale_id) AS sales, AVG(rv.rating) AS rating FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews rv ON rv.product_id = p.product_id GROUP BY p.product_id HAVING COUNT(s.sale_id) > 50 AND AVG(rv.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 20 AND avg_score > 30;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20 AND AVG(sc.score) > 30;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS rating FROM books b) t WHERE borrows > 5 AND rating >= 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 5 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS grade FROM classes cl) t WHERE students > 25 AND grade > 70;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS students, AVG(g.grade) AS grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 25 AND AVG(g.grade) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 100 AND payroll > 1000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 100 AND SUM(s.salary) > 1000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 200 AND revenue > 10000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 200 AND SUM(s.amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE tickets > 50 AND revenue > 5000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50 AND SUM(p.payment_amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.supplier_id, (SELECT COUNT(p.product_id) FROM products p WHERE p.supplier_id = s.supplier_id) AS products, (SELECT SUM(p2.price) FROM products p2 WHERE p2.supplier_id = s.supplier_id) AS value FROM suppliers s) t WHERE products > 10 AND value > 1000;", "output": "SELECT s.supplier_id, COUNT(p.product_id) AS products, SUM(p.price) AS value FROM suppliers s LEFT JOIN products p ON p.supplier_id = s.supplier_id GROUP BY s.supplier_id HAVING COUNT(p.product_id) > 10 AND SUM(p.price) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS weight FROM shipments sh) t WHERE packages > 5 AND weight > 100;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 5 AND SUM(p.weight) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS grade FROM courses c) t WHERE enrolled > 20 AND grade > 65;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 20 AND AVG(g.grade) > 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 100 AND avg_val > 50;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 100 AND AVG(r.value) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.user_id = u.user_id) AS orders, (SELECT SUM(p.amount) FROM payments p WHERE p.user_id = u.user_id) AS paid FROM users u) t WHERE orders > 5 AND paid > 500;", "output": "SELECT u.user_id, COUNT(o.order_id) AS orders, SUM(p.amount) AS paid FROM users u LEFT JOIN orders o ON o.user_id = u.user_id LEFT JOIN payments p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(o.order_id) > 5 AND SUM(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS salary, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects FROM employees e) t WHERE salary > 60000 AND projects >= 2;", "output": "SELECT e.employee_id, AVG(s.salary) AS salary, COUNT(p.project_id) AS projects FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id LEFT JOIN projects p ON p.employee_id = e.employee_id GROUP BY e.employee_id HAVING AVG(s.salary) > 60000 AND COUNT(p.project_id) >= 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS grade FROM students s) t WHERE exams > 3 AND grade >= 75;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 3 AND AVG(g.grade) >= 75;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS rating FROM hotels h) t WHERE bookings > 100 AND rating > 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 100 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS rating, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS earnings FROM drivers d) t WHERE rides > 50 AND rating >= 4.5 AND earnings > 5000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS rating, SUM(p.amount) AS earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 50 AND AVG(r.rating) >= 4.5 AND SUM(p.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS spent, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.customer_id = c.customer_id) AS reviews FROM customers c) t WHERE spent > 1000 AND reviews >= 5;", "output": "SELECT c.customer_id, SUM(o.total) AS spent, COUNT(r.review_id) AS reviews FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN reviews r ON r.customer_id = c.customer_id GROUP BY c.customer_id HAVING SUM(o.total) > 1000 AND COUNT(r.review_id) >= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT SUM(s.amount) FROM sales s WHERE s.product_id = p.product_id) AS sales, (SELECT COUNT(rv.review_id) FROM reviews rv WHERE rv.product_id = p.product_id) AS reviews FROM products p) t WHERE sales > 500 AND reviews >= 10;", "output": "SELECT p.product_id, SUM(s.amount) AS sales, COUNT(rv.review_id) AS reviews FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews rv ON rv.product_id = p.product_id GROUP BY p.product_id HAVING SUM(s.amount) > 500 AND COUNT(rv.review_id) >= 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT SUM(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS score FROM players pl) t WHERE matches > 20 AND score > 200;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, SUM(sc.score) AS score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20 AND SUM(sc.score) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS rating FROM books b) t WHERE borrows > 5 AND rating >= 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 5 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS grade FROM classes cl) t WHERE students > 20 AND grade >= 70;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS students, AVG(g.grade) AS grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 20 AND AVG(g.grade) >= 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 100 AND payroll > 1000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 100 AND SUM(s.salary) > 1000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 200 AND revenue > 5000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 200 AND SUM(s.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.supplier_id, (SELECT COUNT(p.product_id) FROM products p WHERE p.supplier_id = s.supplier_id) AS products FROM suppliers s) t WHERE products > 15;", "output": "SELECT s.supplier_id, COUNT(p.product_id) AS products FROM suppliers s LEFT JOIN products p ON p.supplier_id = s.supplier_id GROUP BY s.supplier_id HAVING COUNT(p.product_id) > 15;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE tickets > 50 AND revenue > 10000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50 AND SUM(p.payment_amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits - debits > 0;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) - SUM(CASE WHEN t.type = 'debit' THEN t.amount END) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 100 AND avg_val > 50;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 100 AND AVG(r.value) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE books > 2 AND rating_sum > 10;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 2 AND SUM(r.rating) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS grade FROM courses c) t WHERE enrolled > 30 AND grade >= 65;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 30 AND AVG(g.grade) >= 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS weight FROM shipments sh) t WHERE packages > 5 AND weight > 100;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 5 AND SUM(p.weight) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(m.message_id) FROM messages m WHERE m.user_id = u.user_id) AS messages, (SELECT MAX(m2.sent_at) FROM messages m2 WHERE m2.user_id = u.user_id) AS last_msg FROM users u) t WHERE messages > 50;", "output": "SELECT u.user_id, COUNT(m.message_id) AS messages, MAX(m.sent_at) AS last_msg FROM users u LEFT JOIN messages m ON m.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(m.message_id) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.customer_id = c.customer_id) AS orders, (SELECT MAX(p.payment_date) FROM payments p WHERE p.customer_id = c.customer_id) AS last_payment FROM customers c) t WHERE orders > 5;", "output": "SELECT c.customer_id, COUNT(o.order_id) AS orders, MAX(p.payment_date) AS last_payment FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN payments p ON p.customer_id = c.customer_id GROUP BY c.customer_id HAVING COUNT(o.order_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS salary FROM employees e) t WHERE projects > 1 AND salary > 40000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, AVG(s.salary) AS salary FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 1 AND AVG(s.salary) > 40000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS grade FROM students s) t WHERE courses > 2 AND grade > 70;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, AVG(g.grade) AS grade FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 2 AND AVG(g.grade) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT SUM(s.amount) FROM sales s WHERE s.product_id = p.product_id) AS sales, (SELECT COUNT(rv.review_id) FROM reviews rv WHERE rv.product_id = p.product_id) AS reviews FROM products p) t WHERE sales > 100 AND reviews > 10;", "output": "SELECT p.product_id, SUM(s.amount) AS sales, COUNT(rv.review_id) AS reviews FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews rv ON rv.product_id = p.product_id GROUP BY p.product_id HAVING SUM(s.amount) > 100 AND COUNT(rv.review_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS rating FROM hotels h) t WHERE bookings > 50 AND rating > 3;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 50 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS rating FROM drivers d) t WHERE rides > 10 AND rating >= 4;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 10 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS score FROM games g) t WHERE plays > 5 AND score > 50;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 5 AND SUM(sc.score) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS rating FROM cities c) t WHERE restaurants > 50 AND rating > 2;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 50 AND AVG(rv.rating) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 200 AND payroll > 2000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 200 AND SUM(s.salary) > 2000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 100 AND revenue > 5000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 100 AND SUM(s.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 15 AND avg_score > 20;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 15 AND AVG(sc.score) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS rating FROM books b) t WHERE borrows > 2 AND rating >= 3;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 2 AND AVG(r.rating) >= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS grade FROM classes cl) t WHERE students > 10 AND grade >= 60;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS students, AVG(g.grade) AS grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 10 AND AVG(g.grade) >= 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE tickets > 20 AND revenue > 1000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 20 AND SUM(p.payment_amount) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 80 AND avg_val > 40;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 80 AND AVG(r.value) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE books > 1 AND rating_sum > 5;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 1 AND SUM(r.rating) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(f.friend_id) FROM friends f WHERE f.user_id = u.user_id) AS friends, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS posts FROM users u) t WHERE friends > 50 AND posts > 5;", "output": "SELECT u.user_id, COUNT(f.friend_id) AS friends, COUNT(p.post_id) AS posts FROM users u LEFT JOIN friends f ON f.user_id = u.user_id LEFT JOIN posts p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(f.friend_id) > 50 AND COUNT(p.post_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS returns FROM orders o) t WHERE total_value > 300 AND returns = 0;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS returns FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 300 AND COUNT(r.return_id) = 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS salary, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects FROM employees e) t WHERE salary > 55000 AND projects > 1;", "output": "SELECT e.employee_id, AVG(s.salary) AS salary, COUNT(p.project_id) AS projects FROM employees e LEFT JOIN salaries s ON s.employee_id = e.employee_id LEFT JOIN projects p ON p.employee_id = e.employee_id GROUP BY e.employee_id HAVING AVG(s.salary) > 55000 AND COUNT(p.project_id) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS grade FROM students s) t WHERE exams > 4 AND grade > 65;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 4 AND AVG(g.grade) > 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS rating FROM hotels h) t WHERE bookings > 150 AND rating >= 3.5;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 150 AND AVG(r.rating) >= 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS rating FROM drivers d) t WHERE rides > 20 AND rating >= 4.2;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 20 AND AVG(r.rating) >= 4.2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS score FROM games g) t WHERE plays > 20 AND score > 300;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 20 AND SUM(sc.score) > 300;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS rating FROM cities c) t WHERE restaurants > 200 AND rating > 3;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 200 AND AVG(rv.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 300 AND payroll > 4000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 300 AND SUM(s.salary) > 4000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 300 AND revenue > 15000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 300 AND SUM(s.amount) > 15000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 10 AND avg_score > 25;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 10 AND AVG(sc.score) > 25;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS rating FROM books b) t WHERE borrows > 15 AND rating >= 3.5;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 15 AND AVG(r.rating) >= 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS grade FROM classes cl) t WHERE students > 40 AND grade >= 75;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS students, AVG(g.grade) AS grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 40 AND AVG(g.grade) >= 75;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE tickets > 100 AND revenue > 20000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 100 AND SUM(p.payment_amount) > 20000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 70 AND avg_val > 35;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 70 AND AVG(r.value) > 35;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE books > 3 AND rating_sum > 20;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 3 AND SUM(r.rating) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS grade FROM courses c) t WHERE enrolled > 15 AND grade > 60;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 15 AND AVG(g.grade) > 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.like_id) FROM likes l WHERE l.user_id = u.user_id) AS likes, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.user_id = u.user_id) AS comments FROM users u) t WHERE likes > 100 AND comments > 50;", "output": "SELECT u.user_id, COUNT(l.like_id) AS likes, COUNT(c.comment_id) AS comments FROM users u LEFT JOIN likes l ON l.user_id = u.user_id LEFT JOIN comments c ON c.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(l.like_id) > 100 AND COUNT(c.comment_id) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(sh.shipment_id) FROM shipments sh WHERE sh.order_id = o.order_id) AS shipments FROM orders o) t WHERE total_value > 500 AND shipments > 0;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(sh.shipment_id) AS shipments FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN shipments sh ON sh.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 500 AND COUNT(sh.shipment_id) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE projects > 2 AND avg_salary > 45000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 2 AND AVG(s.salary) > 45000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE exams > 2 AND avg_grade >= 70;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 2 AND AVG(g.grade) >= 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE bookings > 250 AND avg_rating >= 3.5;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 250 AND AVG(r.rating) >= 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS total_earnings FROM drivers d) t WHERE rides > 30 AND avg_rating >= 4 AND total_earnings > 2000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS avg_rating, SUM(p.amount) AS total_earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 30 AND AVG(r.rating) >= 4 AND SUM(p.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.customer_id, (SELECT SUM(o.total) FROM orders o WHERE o.customer_id = c.customer_id) AS total_spent, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.customer_id = c.customer_id) AS reviews FROM customers c) t WHERE total_spent > 2000 AND reviews > 3;", "output": "SELECT c.customer_id, SUM(o.total) AS total_spent, COUNT(r.review_id) AS reviews FROM customers c LEFT JOIN orders o ON o.customer_id = c.customer_id LEFT JOIN reviews r ON r.customer_id = c.customer_id GROUP BY c.customer_id HAVING SUM(o.total) > 2000 AND COUNT(r.review_id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT p.product_id, (SELECT SUM(s.amount) FROM sales s WHERE s.product_id = p.product_id) AS total_sales, (SELECT COUNT(rv.review_id) FROM reviews rv WHERE rv.product_id = p.product_id) AS total_reviews FROM products p) t WHERE total_sales > 1000 AND total_reviews >= 5;", "output": "SELECT p.product_id, SUM(s.amount) AS total_sales, COUNT(rv.review_id) AS total_reviews FROM products p LEFT JOIN sales s ON s.product_id = p.product_id LEFT JOIN reviews rv ON rv.product_id = p.product_id GROUP BY p.product_id HAVING SUM(s.amount) > 1000 AND COUNT(rv.review_id) >= 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 40 AND avg_score > 15;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 40 AND AVG(sc.score) > 15;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 8 AND avg_rating > 3;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 8 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 30 AND avg_grade >= 60;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 30 AND AVG(g.grade) >= 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 50 AND total_revenue > 5000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50 AND SUM(p.payment_amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 120 AND avg_val > 70;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 120 AND AVG(r.value) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS total_ratings FROM authors a) t WHERE books > 5 AND total_ratings > 15;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS total_ratings FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 5 AND SUM(r.rating) > 15;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 10 AND avg_grade >= 55;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 10 AND AVG(g.grade) >= 55;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 5 AND total_weight > 100;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 5 AND SUM(p.weight) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS posts, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.user_id = u.user_id) AS comments FROM users u) t WHERE posts > 20 AND comments > 5;", "output": "SELECT u.user_id, COUNT(p.post_id) AS posts, COUNT(c.comment_id) AS comments FROM users u LEFT JOIN posts p ON p.user_id = u.user_id LEFT JOIN comments c ON c.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(p.post_id) > 20 AND COUNT(c.comment_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS returns FROM orders o) t WHERE total_value > 100 AND returns = 0;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS returns FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 100 AND COUNT(r.return_id) = 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE projects > 1 AND avg_salary > 30000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 1 AND AVG(s.salary) > 30000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE exams > 1 AND avg_grade > 60;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 1 AND AVG(g.grade) > 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE bookings > 80 AND avg_rating >= 3;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 80 AND AVG(r.rating) >= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE rides > 15 AND avg_rating >= 4;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 15 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS score FROM games g) t WHERE plays > 10 AND score > 100;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 10 AND SUM(sc.score) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE restaurants > 100 AND avg_rating > 2;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 100 AND AVG(rv.rating) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 150 AND payroll > 1500000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 150 AND SUM(s.salary) > 1500000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 50 AND revenue > 3000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 50 AND SUM(s.amount) > 3000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 5 AND avg_score > 10;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 5 AND AVG(sc.score) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 3 AND avg_rating >= 2.5;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 3 AND AVG(r.rating) >= 2.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 15 AND avg_grade >= 55;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 15 AND AVG(g.grade) >= 55;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 20 AND total_revenue > 2000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 20 AND SUM(p.payment_amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 60 AND avg_val > 30;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 60 AND AVG(r.value) > 30;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS total_ratings FROM authors a) t WHERE books > 2 AND total_ratings > 5;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS total_ratings FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 2 AND SUM(r.rating) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 5 AND avg_grade >= 50;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 5 AND AVG(g.grade) >= 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 2 AND total_weight > 20;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 2 AND SUM(p.weight) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(o.order_id) FROM orders o WHERE o.user_id = u.user_id) AS orders, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.user_id = u.user_id) AS total_paid FROM users u) t WHERE orders > 10 AND total_paid > 500;", "output": "SELECT u.user_id, COUNT(o.order_id) AS orders, SUM(p.payment_amount) AS total_paid FROM users u LEFT JOIN orders o ON o.user_id = u.user_id LEFT JOIN payments p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(o.order_id) > 10 AND SUM(p.payment_amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(a.attendance_id) FROM attendance a WHERE a.employee_id = e.employee_id) AS days_present, (SELECT SUM(b.bonus) FROM bonuses b WHERE b.employee_id = e.employee_id) AS total_bonus FROM employees e) t WHERE days_present > 20 AND total_bonus > 1000;", "output": "SELECT e.employee_id, COUNT(a.attendance_id) AS days_present, SUM(b.bonus) AS total_bonus FROM employees e LEFT JOIN attendance a ON a.employee_id = e.employee_id LEFT JOIN bonuses b ON b.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(a.attendance_id) > 20 AND SUM(b.bonus) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE courses > 3 AND avg_grade > 60;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 3 AND AVG(g.grade) > 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.hotel_id = h.hotel_id) AS total_revenue FROM hotels h) t WHERE bookings > 50 AND total_revenue > 10000;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, SUM(p.payment_amount) AS total_revenue FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN payments p ON p.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 50 AND SUM(p.payment_amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS total_earnings FROM drivers d) t WHERE rides > 25 AND total_earnings > 500;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, SUM(p.amount) AS total_earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 25 AND SUM(p.amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT AVG(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS avg_score FROM games g) t WHERE plays > 15 AND avg_score > 20;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, AVG(sc.score) AS avg_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 15 AND AVG(sc.score) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE restaurants > 50 AND avg_rating > 2.5;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 50 AND AVG(rv.rating) > 2.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 100 AND payroll > 2000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 100 AND SUM(s.salary) > 2000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 40 AND revenue > 2000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 40 AND SUM(s.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 8 AND avg_score > 12;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 8 AND AVG(sc.score) > 12;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 6 AND avg_rating > 3;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 6 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 25 AND avg_grade >= 65;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 25 AND AVG(g.grade) >= 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 30 AND total_revenue > 4000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 30 AND SUM(p.payment_amount) > 4000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 90 AND avg_val > 40;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 90 AND AVG(r.value) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS total_ratings FROM authors a) t WHERE books > 4 AND total_ratings > 12;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS total_ratings FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 4 AND SUM(r.rating) > 12;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 8 AND avg_grade >= 55;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 8 AND AVG(g.grade) >= 55;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 4 AND total_weight > 50;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 4 AND SUM(p.weight) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.like_id) FROM likes l WHERE l.user_id = u.user_id) AS likes, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.user_id = u.user_id) AS comments FROM users u) t WHERE likes > 200 AND comments > 20;", "output": "SELECT u.user_id, COUNT(l.like_id) AS likes, COUNT(c.comment_id) AS comments FROM users u LEFT JOIN likes l ON l.user_id = u.user_id LEFT JOIN comments c ON c.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(l.like_id) > 200 AND COUNT(c.comment_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(sh.shipment_id) FROM shipments sh WHERE sh.order_id = o.order_id) AS shipments FROM orders o) t WHERE total_value > 250 AND shipments > 0;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(sh.shipment_id) AS shipments FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN shipments sh ON sh.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 250 AND COUNT(sh.shipment_id) > 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE projects > 5 AND avg_salary > 60000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 5 AND AVG(s.salary) > 60000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE exams > 3 AND avg_grade > 70;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 3 AND AVG(g.grade) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE bookings > 300 AND avg_rating >= 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 300 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE rides > 50 AND avg_rating >= 4.5;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 50 AND AVG(r.rating) >= 4.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS total_score FROM games g) t WHERE plays > 30 AND total_score > 500;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS total_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 30 AND SUM(sc.score) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE restaurants > 300 AND avg_rating > 3.5;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 300 AND AVG(rv.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 500 AND payroll > 5000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 500 AND SUM(s.salary) > 5000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 200 AND revenue > 5000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 200 AND SUM(s.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 20 AND avg_score > 30;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20 AND AVG(sc.score) > 30;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 20 AND avg_rating >= 4;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 20 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE students > 60 AND avg_grade >= 70;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 60 AND AVG(g.grade) >= 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 150 AND total_revenue > 30000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 150 AND SUM(p.payment_amount) > 30000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 80 AND avg_val > 50;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 80 AND AVG(r.value) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE books > 10 AND rating_sum > 40;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 10 AND SUM(r.rating) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 20 AND avg_grade >= 60;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 20 AND AVG(g.grade) >= 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 10 AND total_weight > 200;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 10 AND SUM(p.weight) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(f.friend_id) FROM friends f WHERE f.user_id = u.user_id) AS friends, (SELECT COUNT(m.message_id) FROM messages m WHERE m.user_id = u.user_id) AS messages FROM users u) t WHERE friends > 100 AND messages > 20;", "output": "SELECT u.user_id, COUNT(f.friend_id) AS friends, COUNT(m.message_id) AS messages FROM users u LEFT JOIN friends f ON f.user_id = u.user_id LEFT JOIN messages m ON m.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(f.friend_id) > 100 AND COUNT(m.message_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(p.payment_id) FROM payments p WHERE p.order_id = o.order_id) AS payments FROM orders o) t WHERE total_value > 600 AND payments > 1;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(p.payment_id) AS payments FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN payments p ON p.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 600 AND COUNT(p.payment_id) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT SUM(b.bonus) FROM bonuses b WHERE b.employee_id = e.employee_id) AS total_bonus FROM employees e) t WHERE projects > 2 AND total_bonus > 1000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, SUM(b.bonus) AS total_bonus FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN bonuses b ON b.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 2 AND SUM(b.bonus) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE courses > 4 AND avg_grade > 65;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 4 AND AVG(g.grade) > 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE bookings > 400 AND avg_rating >= 4.2;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 400 AND AVG(r.rating) >= 4.2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS total_earnings FROM drivers d) t WHERE rides > 70 AND total_earnings > 7000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, SUM(p.amount) AS total_earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 70 AND SUM(p.amount) > 7000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT AVG(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS avg_score FROM games g) t WHERE plays > 40 AND avg_score > 35;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, AVG(sc.score) AS avg_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 40 AND AVG(sc.score) > 35;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT SUM(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS rating_sum FROM cities c) t WHERE restaurants > 250 AND rating_sum > 1000;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, SUM(rv.rating) AS rating_sum FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 250 AND SUM(rv.rating) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 600 AND payroll > 6000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 600 AND SUM(s.salary) > 6000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 250 AND revenue > 8000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 250 AND SUM(s.amount) > 8000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 25 AND avg_score > 28;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 25 AND AVG(sc.score) > 28;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 25 AND avg_rating >= 3.8;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 25 AND AVG(r.rating) >= 3.8;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 70 AND avg_grade >= 68;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 70 AND AVG(g.grade) >= 68;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 120 AND total_revenue > 25000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 120 AND SUM(p.payment_amount) > 25000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 100 AND avg_val > 55;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 100 AND AVG(r.value) > 55;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE books > 12 AND rating_sum > 30;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 12 AND SUM(r.rating) > 30;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 12 AND avg_grade >= 62;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 12 AND AVG(g.grade) >= 62;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 15 AND total_weight > 120;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 15 AND SUM(p.weight) > 120;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(a.attendance_id) FROM attendance a WHERE a.employee_id = e.employee_id) AS days_present, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE days_present > 20 AND avg_salary > 45000;", "output": "SELECT e.employee_id, COUNT(a.attendance_id) AS days_present, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN attendance a ON a.employee_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(a.attendance_id) > 20 AND AVG(s.salary) > 45000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE courses > 2 AND avg_grade > 55;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 2 AND AVG(g.grade) > 55;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.hotel_id = h.hotel_id) AS total_revenue FROM hotels h) t WHERE bookings > 100 AND total_revenue > 5000;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, SUM(p.payment_amount) AS total_revenue FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN payments p ON p.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 100 AND SUM(p.payment_amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS total_earnings FROM drivers d) t WHERE rides > 30 AND total_earnings > 2000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, SUM(p.amount) AS total_earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 30 AND SUM(p.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT AVG(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS avg_score FROM games g) t WHERE plays > 12 AND avg_score > 18;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, AVG(sc.score) AS avg_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 12 AND AVG(sc.score) > 18;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE restaurants > 120 AND avg_rating > 2.8;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 120 AND AVG(rv.rating) > 2.8;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 200 AND payroll > 2500000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 200 AND SUM(s.salary) > 2500000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 60 AND revenue > 2500;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 60 AND SUM(s.amount) > 2500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 15 AND avg_score > 22;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 15 AND AVG(sc.score) > 22;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 10 AND avg_rating >= 3;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 10 AND AVG(r.rating) >= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 35 AND avg_grade >= 60;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 35 AND AVG(g.grade) >= 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 80 AND total_revenue > 15000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 80 AND SUM(p.payment_amount) > 15000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 70 AND avg_val > 35;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 70 AND AVG(r.value) > 35;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS total_ratings FROM authors a) t WHERE books > 6 AND total_ratings > 20;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS total_ratings FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 6 AND SUM(r.rating) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 18 AND avg_grade >= 58;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 18 AND AVG(g.grade) >= 58;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 8 AND total_weight > 90;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 8 AND SUM(p.weight) > 90;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS posts, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.user_id = u.user_id) AS comments FROM users u) t WHERE posts > 15 AND comments > 10;", "output": "SELECT u.user_id, COUNT(p.post_id) AS posts, COUNT(c.comment_id) AS comments FROM users u LEFT JOIN posts p ON p.user_id = u.user_id LEFT JOIN comments c ON c.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(p.post_id) > 15 AND COUNT(c.comment_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS returns FROM orders o) t WHERE total_value > 400 AND returns = 0;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS returns FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 400 AND COUNT(r.return_id) = 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT SUM(b.bonus) FROM bonuses b WHERE b.employee_id = e.employee_id) AS total_bonus FROM employees e) t WHERE projects > 3 AND total_bonus > 1500;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, SUM(b.bonus) AS total_bonus FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN bonuses b ON b.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 3 AND SUM(b.bonus) > 1500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE exams > 5 AND avg_grade > 72;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 5 AND AVG(g.grade) > 72;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE bookings > 150 AND avg_rating >= 3.2;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 150 AND AVG(r.rating) >= 3.2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE rides > 35 AND avg_rating >= 4;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 35 AND AVG(r.rating) >= 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS total_score FROM games g) t WHERE plays > 20 AND total_score > 250;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS total_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 20 AND SUM(sc.score) > 250;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE restaurants > 200 AND avg_rating > 3;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 200 AND AVG(rv.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 350 AND payroll > 3500000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 350 AND SUM(s.salary) > 3500000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 100 AND revenue > 4000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 100 AND SUM(s.amount) > 4000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 18 AND avg_score > 20;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 18 AND AVG(sc.score) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 12 AND avg_rating >= 3.2;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 12 AND AVG(r.rating) >= 3.2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 40 AND avg_grade >= 65;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 40 AND AVG(g.grade) >= 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 90 AND total_revenue > 18000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 90 AND SUM(p.payment_amount) > 18000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 95 AND avg_val > 45;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 95 AND AVG(r.value) > 45;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE books > 7 AND rating_sum > 25;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 7 AND SUM(r.rating) > 25;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 20 AND avg_grade >= 57;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 20 AND AVG(g.grade) >= 57;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 12 AND total_weight > 70;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 12 AND SUM(p.weight) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.login_id) FROM logins l WHERE l.user_id = u.user_id) AS logins, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS posts FROM users u) t WHERE logins > 50 AND posts > 5;", "output": "SELECT u.user_id, COUNT(l.login_id) AS logins, COUNT(p.post_id) AS posts FROM users u LEFT JOIN logins l ON l.user_id = u.user_id LEFT JOIN posts p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(l.login_id) > 50 AND COUNT(p.post_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(sh.shipment_id) FROM shipments sh WHERE sh.order_id = o.order_id) AS shipments FROM orders o) t WHERE total_value > 700 AND shipments > 1;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(sh.shipment_id) AS shipments FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN shipments sh ON sh.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 700 AND COUNT(sh.shipment_id) > 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.employee_id = e.employee_id) AS tasks, (SELECT SUM(w.hours) FROM worklogs w WHERE w.employee_id = e.employee_id) AS hours FROM employees e) t WHERE tasks > 5 AND hours > 120;", "output": "SELECT e.employee_id, COUNT(t.task_id) AS tasks, SUM(w.hours) AS hours FROM employees e LEFT JOIN tasks t ON t.employee_id = e.employee_id LEFT JOIN worklogs w ON w.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(t.task_id) > 5 AND SUM(w.hours) > 120;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams FROM students s) t WHERE courses > 3 AND exams > 2;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, COUNT(ex.exam_id) AS exams FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN exams ex ON ex.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 3 AND COUNT(ex.exam_id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT COUNT(r.review_id) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS reviews FROM hotels h) t WHERE bookings > 60 AND reviews > 20;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, COUNT(r.review_id) AS reviews FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 60 AND COUNT(r.review_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS total_earnings FROM drivers d) t WHERE rides > 40 AND total_earnings > 3000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, SUM(p.amount) AS total_earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 40 AND SUM(p.amount) > 3000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT AVG(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS avg_score FROM games g) t WHERE plays > 10 AND avg_score > 40;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, AVG(sc.score) AS avg_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 10 AND AVG(sc.score) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT SUM(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS rating_sum FROM cities c) t WHERE restaurants > 80 AND rating_sum > 150;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, SUM(rv.rating) AS rating_sum FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 80 AND SUM(rv.rating) > 150;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT AVG(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS avg_salary FROM companies co) t WHERE employees > 120 AND avg_salary > 40000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, AVG(s.salary) AS avg_salary FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 120 AND AVG(s.salary) > 40000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 30 AND revenue > 1200;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 30 AND SUM(s.amount) > 1200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT SUM(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS total_score FROM players pl) t WHERE matches > 20 AND total_score > 300;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, SUM(sc.score) AS total_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20 AND SUM(sc.score) > 300;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 15 AND avg_rating > 3.5;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 15 AND AVG(r.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT SUM(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS total_grades FROM classes cl) t WHERE total_students > 25 AND total_grades > 2000;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, SUM(g.grade) AS total_grades FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 25 AND SUM(g.grade) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE total_tickets > 70 AND revenue > 12000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 70 AND SUM(p.payment_amount) > 12000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 90 AND avg_val > 55;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 90 AND AVG(r.value) > 55;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT AVG(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS avg_rating FROM authors a) t WHERE books > 4 AND avg_rating > 2.5;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, AVG(r.rating) AS avg_rating FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 4 AND AVG(r.rating) > 2.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT SUM(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS total_grades FROM courses c) t WHERE enrolled > 15 AND total_grades > 700;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, SUM(g.grade) AS total_grades FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 15 AND SUM(g.grade) > 700;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 10 AND total_weight > 80;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 10 AND SUM(p.weight) > 80;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(m.message_id) FROM messages m WHERE m.user_id = u.user_id) AS messages, (SELECT COUNT(f.friend_id) FROM friends f WHERE f.user_id = u.user_id) AS friends FROM users u) t WHERE messages > 100 AND friends > 20;", "output": "SELECT u.user_id, COUNT(m.message_id) AS messages, COUNT(f.friend_id) AS friends FROM users u LEFT JOIN messages m ON m.user_id = u.user_id LEFT JOIN friends f ON f.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(m.message_id) > 100 AND COUNT(f.friend_id) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS returns FROM orders o) t WHERE total_value > 1000 AND returns < 2;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS returns FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 1000 AND COUNT(r.return_id) < 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT SUM(b.bonus) FROM bonuses b WHERE b.employee_id = e.employee_id) AS total_bonus FROM employees e) t WHERE projects > 5 AND total_bonus > 2000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, SUM(b.bonus) AS total_bonus FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN bonuses b ON b.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 5 AND SUM(b.bonus) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT SUM(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS total_grades FROM students s) t WHERE exams > 3 AND total_grades > 180;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, SUM(g.grade) AS total_grades FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 3 AND SUM(g.grade) > 180;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.hotel_id = h.hotel_id) AS total_revenue FROM hotels h) t WHERE bookings > 200 AND total_revenue > 10000;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, SUM(p.payment_amount) AS total_revenue FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN payments p ON p.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 200 AND SUM(p.payment_amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r2.rating) FROM rides r2 WHERE r2.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE rides > 60 AND avg_rating > 4;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 60 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS total_score FROM games g) t WHERE plays > 30 AND total_score > 400;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS total_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 30 AND SUM(sc.score) > 400;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE restaurants > 150 AND avg_rating > 3.5;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 150 AND AVG(rv.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT AVG(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS avg_salary FROM companies co) t WHERE employees > 300 AND avg_salary > 42000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, AVG(s.salary) AS avg_salary FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 300 AND AVG(s.salary) > 42000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 120 AND revenue > 5000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 120 AND SUM(s.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 25 AND avg_score > 30;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 25 AND AVG(sc.score) > 30;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 20 AND avg_rating >= 3;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 20 AND AVG(r.rating) >= 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT SUM(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS total_grades FROM classes cl) t WHERE total_students > 50 AND total_grades > 2500;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, SUM(g.grade) AS total_grades FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 50 AND SUM(g.grade) > 2500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE total_tickets > 110 AND revenue > 22000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 110 AND SUM(p.payment_amount) > 22000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 85 AND avg_val > 60;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 85 AND AVG(r.value) > 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS total_ratings FROM authors a) t WHERE books > 9 AND total_ratings > 40;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS total_ratings FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 9 AND SUM(r.rating) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 25 AND avg_grade >= 70;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 25 AND AVG(g.grade) >= 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 20 AND total_weight > 150;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 20 AND SUM(p.weight) > 150;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.user_id = u.user_id) AS comments, (SELECT COUNT(l.like_id) FROM likes l WHERE l.user_id = u.user_id) AS likes FROM users u) t WHERE comments > 50 AND likes > 200;", "output": "SELECT u.user_id, COUNT(c.comment_id) AS comments, COUNT(l.like_id) AS likes FROM users u LEFT JOIN comments c ON c.user_id = u.user_id LEFT JOIN likes l ON l.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(c.comment_id) > 50 AND COUNT(l.like_id) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT SUM(sh.shipping_cost) FROM shippings sh WHERE sh.order_id = o.order_id) AS shipping FROM orders o) t WHERE total_value > 1500 AND shipping < 200;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, SUM(sh.shipping_cost) AS shipping FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN shippings sh ON sh.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 1500 AND SUM(sh.shipping_cost) < 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(a.attendance_id) FROM attendance a WHERE a.employee_id = e.employee_id) AS attendance_days, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE attendance_days > 20 AND avg_salary > 35000;", "output": "SELECT e.employee_id, COUNT(a.attendance_id) AS attendance_days, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN attendance a ON a.employee_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(a.attendance_id) > 20 AND AVG(s.salary) > 35000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams FROM students s) t WHERE courses > 4 AND exams > 3;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, COUNT(ex.exam_id) AS exams FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN exams ex ON ex.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 4 AND COUNT(ex.exam_id) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE bookings > 120 AND avg_rating > 3.7;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 120 AND AVG(r.rating) > 3.7;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS earnings FROM drivers d) t WHERE rides > 80 AND earnings > 6000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, SUM(p.amount) AS earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 80 AND SUM(p.amount) > 6000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT AVG(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS avg_score FROM games g) t WHERE plays > 25 AND avg_score > 50;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, AVG(sc.score) AS avg_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 25 AND AVG(sc.score) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT SUM(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS total_rating FROM cities c) t WHERE restaurants > 100 AND total_rating > 300;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, SUM(rv.rating) AS total_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 100 AND SUM(rv.rating) > 300;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 500 AND payroll > 8000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 500 AND SUM(s.salary) > 8000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 70 AND revenue > 2500;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 70 AND SUM(s.amount) > 2500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT SUM(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS total_score FROM players pl) t WHERE matches > 35 AND total_score > 500;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, SUM(sc.score) AS total_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 35 AND SUM(sc.score) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 25 AND avg_rating > 3.2;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 25 AND AVG(r.rating) > 3.2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 60 AND avg_grade > 65;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 60 AND AVG(g.grade) > 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS revenue FROM events ev) t WHERE total_tickets > 150 AND revenue > 30000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 150 AND SUM(p.payment_amount) > 30000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 100 AND avg_val > 60;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 100 AND AVG(r.value) > 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS total_ratings FROM authors a) t WHERE books > 15 AND total_ratings > 60;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS total_ratings FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 15 AND SUM(r.rating) > 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT SUM(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS total_grades FROM courses c) t WHERE enrolled > 30 AND total_grades > 900;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, SUM(g.grade) AS total_grades FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 30 AND SUM(g.grade) > 900;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 18 AND total_weight > 120;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 18 AND SUM(p.weight) > 120;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS posts, (SELECT COUNT(f.friend_id) FROM friends f WHERE f.user_id = u.user_id) AS friends FROM users u) t WHERE posts > 20 AND friends > 10;", "output": "SELECT u.user_id, COUNT(p.post_id) AS posts, COUNT(f.friend_id) AS friends FROM users u LEFT JOIN posts p ON p.user_id = u.user_id LEFT JOIN friends f ON f.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(p.post_id) > 20 AND COUNT(f.friend_id) > 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.order_id = o.order_id) AS payments FROM orders o) t WHERE total_value > 1200 AND payments > 2;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, SUM(p.payment_amount) AS payments FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN payments p ON p.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 1200 AND SUM(p.payment_amount) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT AVG(b.bonus) FROM bonuses b WHERE b.employee_id = e.employee_id) AS avg_bonus FROM employees e) t WHERE projects > 6 AND avg_bonus > 500;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, AVG(b.bonus) AS avg_bonus FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN bonuses b ON b.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 6 AND AVG(b.bonus) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE courses > 5 AND avg_grade > 70;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 5 AND AVG(g.grade) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.hotel_id = h.hotel_id) AS revenue FROM hotels h) t WHERE bookings > 180 AND revenue > 15000;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, SUM(p.payment_amount) AS revenue FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN payments p ON p.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 180 AND SUM(p.payment_amount) > 15000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS earnings FROM drivers d) t WHERE rides > 50 AND earnings > 4000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, SUM(p.amount) AS earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 50 AND SUM(p.amount) > 4000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS total_score FROM games g) t WHERE plays > 15 AND total_score > 200;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS total_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 15 AND SUM(sc.score) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE restaurants > 60 AND avg_rating > 3.5;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 60 AND AVG(rv.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 400 AND payroll > 7000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 400 AND SUM(s.salary) > 7000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 90 AND revenue > 3000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 90 AND SUM(s.amount) > 3000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 30 AND avg_score > 25;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 30 AND AVG(sc.score) > 25;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT SUM(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS rating_sum FROM books b) t WHERE borrows > 18 AND rating_sum > 50;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, SUM(r.rating) AS rating_sum FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 18 AND SUM(r.rating) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT SUM(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS total_grades FROM classes cl) t WHERE total_students > 40 AND total_grades > 1800;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, SUM(g.grade) AS total_grades FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 40 AND SUM(g.grade) > 1800;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT AVG(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS avg_payment FROM events ev) t WHERE total_tickets > 100 AND avg_payment > 120;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, AVG(p.payment_amount) AS avg_payment FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 100 AND AVG(p.payment_amount) > 120;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT MIN(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS min_val FROM sensors sn) t WHERE max_val > 90 AND min_val < 10;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, MIN(r.value) AS min_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 90 AND MIN(r.value) < 10;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT AVG(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS avg_rating FROM authors a) t WHERE books > 12 AND avg_rating > 3;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, AVG(r.rating) AS avg_rating FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 12 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT SUM(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS total_grades FROM courses c) t WHERE enrolled > 25 AND total_grades > 1000;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, SUM(g.grade) AS total_grades FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 25 AND SUM(g.grade) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 20 AND total_weight > 200;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 20 AND SUM(p.weight) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.login_id) FROM logins l WHERE l.user_id = u.user_id) AS logins, (SELECT COUNT(p.purchase_id) FROM purchases p WHERE p.user_id = u.user_id) AS purchases FROM users u) t WHERE logins > 30 AND purchases > 5;", "output": "SELECT u.user_id, COUNT(l.login_id) AS logins, COUNT(p.purchase_id) AS purchases FROM users u LEFT JOIN logins l ON l.user_id = u.user_id LEFT JOIN purchases p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(l.login_id) > 30 AND COUNT(p.purchase_id) > 5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS returns FROM orders o) t WHERE total_value > 2000 AND returns < 1;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS returns FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 2000 AND COUNT(r.return_id) < 1;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.employee_id = e.employee_id) AS tasks, (SELECT SUM(w.hours) FROM worklogs w WHERE w.employee_id = e.employee_id) AS hours FROM employees e) t WHERE tasks > 10 AND hours > 300;", "output": "SELECT e.employee_id, COUNT(t.task_id) AS tasks, SUM(w.hours) AS hours FROM employees e LEFT JOIN tasks t ON t.employee_id = e.employee_id LEFT JOIN worklogs w ON w.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(t.task_id) > 10 AND SUM(w.hours) > 300;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE exams > 4 AND avg_grade > 65;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 4 AND AVG(g.grade) > 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.hotel_id = h.hotel_id) AS revenue FROM hotels h) t WHERE bookings > 220 AND revenue > 20000;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, SUM(p.payment_amount) AS revenue FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN payments p ON p.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 220 AND SUM(p.payment_amount) > 20000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r.rating) FROM rides r WHERE r.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE rides > 70 AND avg_rating > 4.2;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 70 AND AVG(r.rating) > 4.2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS total_score FROM games g) t WHERE plays > 40 AND total_score > 500;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS total_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 40 AND SUM(sc.score) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT SUM(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS total_rating FROM cities c) t WHERE restaurants > 90 AND total_rating > 500;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, SUM(rv.rating) AS total_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 90 AND SUM(rv.rating) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT AVG(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS avg_salary FROM companies co) t WHERE employees > 350 AND avg_salary > 41000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, AVG(s.salary) AS avg_salary FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 350 AND AVG(s.salary) > 41000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 110 AND revenue > 6000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 110 AND SUM(s.amount) > 6000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 22 AND avg_score > 28;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 22 AND AVG(sc.score) > 28;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 30 AND avg_rating > 3.6;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 30 AND AVG(r.rating) > 3.6;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 70 AND avg_grade > 60;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 70 AND AVG(g.grade) > 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 200 AND total_revenue > 40000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 200 AND SUM(p.payment_amount) > 40000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 110 AND avg_val > 65;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 110 AND AVG(r.value) > 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE books > 20 AND rating_sum > 80;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 20 AND SUM(r.rating) > 80;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 20 AND avg_grade > 68;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 20 AND AVG(g.grade) > 68;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 25 AND total_weight > 180;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 25 AND SUM(p.weight) > 180;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.user_id = u.user_id) AS comments, (SELECT SUM(l.value) FROM likes l WHERE l.user_id = u.user_id) AS likes FROM users u) t WHERE comments > 40 AND likes > 100;", "output": "SELECT u.user_id, COUNT(c.comment_id) AS comments, SUM(l.value) AS likes FROM users u LEFT JOIN comments c ON c.user_id = u.user_id LEFT JOIN likes l ON l.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(c.comment_id) > 40 AND SUM(l.value) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(sh.shipment_id) FROM shipments sh WHERE sh.order_id = o.order_id) AS shipments FROM orders o) t WHERE total_value > 2500 AND shipments > 2;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(sh.shipment_id) AS shipments FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN shipments sh ON sh.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 2500 AND COUNT(sh.shipment_id) > 2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT SUM(b.bonus) FROM bonuses b WHERE b.employee_id = e.employee_id) AS total_bonus FROM employees e) t WHERE projects > 8 AND total_bonus > 1000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, SUM(b.bonus) AS total_bonus FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN bonuses b ON b.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 8 AND SUM(b.bonus) > 1000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT SUM(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS total_grades FROM students s) t WHERE courses > 6 AND total_grades > 450;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, SUM(g.grade) AS total_grades FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 6 AND SUM(g.grade) > 450;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE bookings > 100 AND avg_rating > 4;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 100 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS earnings FROM drivers d) t WHERE rides > 60 AND earnings > 5000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, SUM(p.amount) AS earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 60 AND SUM(p.amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT AVG(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS avg_score FROM games g) t WHERE plays > 35 AND avg_score > 45;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, AVG(sc.score) AS avg_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 35 AND AVG(sc.score) > 45;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE restaurants > 70 AND avg_rating > 3.8;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 70 AND AVG(rv.rating) > 3.8;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 500 AND payroll > 10000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 500 AND SUM(s.salary) > 10000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 50 AND revenue > 2000;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 50 AND SUM(s.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT SUM(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS total_score FROM players pl) t WHERE matches > 20 AND total_score > 300;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, SUM(sc.score) AS total_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 20 AND SUM(sc.score) > 300;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 15 AND avg_rating > 3.3;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 15 AND AVG(r.rating) > 3.3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT SUM(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS total_grades FROM classes cl) t WHERE total_students > 30 AND total_grades > 1200;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, SUM(g.grade) AS total_grades FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 30 AND SUM(g.grade) > 1200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT AVG(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS avg_payment FROM events ev) t WHERE total_tickets > 80 AND avg_payment > 100;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, AVG(p.payment_amount) AS avg_payment FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 80 AND AVG(p.payment_amount) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT MIN(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS min_val FROM sensors sn) t WHERE max_val > 95 AND min_val < 15;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, MIN(r.value) AS min_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 95 AND MIN(r.value) < 15;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS total_ratings FROM authors a) t WHERE books > 10 AND total_ratings > 40;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS total_ratings FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 10 AND SUM(r.rating) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 15 AND avg_grade > 70;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 15 AND AVG(g.grade) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 15 AND total_weight > 90;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 15 AND SUM(p.weight) > 90;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id) AS posts, (SELECT SUM(c.likes) FROM comments c WHERE c.user_id = u.user_id) AS likes FROM users u) t WHERE posts > 10 AND likes > 50;", "output": "SELECT u.user_id, COUNT(p.post_id) AS posts, SUM(c.likes) AS likes FROM users u LEFT JOIN posts p ON p.user_id = u.user_id LEFT JOIN comments c ON c.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(p.post_id) > 10 AND SUM(c.likes) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT COUNT(oi.item_id) FROM order_items oi WHERE oi.order_id = o.order_id) AS items, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.order_id = o.order_id) AS payments FROM orders o) t WHERE items > 3 AND payments > 200;", "output": "SELECT o.order_id, COUNT(oi.item_id) AS items, SUM(p.payment_amount) AS payments FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN payments p ON p.order_id = o.order_id GROUP BY o.order_id HAVING COUNT(oi.item_id) > 3 AND SUM(p.payment_amount) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.employee_id = e.employee_id) AS tasks, (SELECT SUM(w.hours) FROM worklogs w WHERE w.employee_id = e.employee_id) AS hours FROM employees e) t WHERE tasks > 5 AND hours > 160;", "output": "SELECT e.employee_id, COUNT(t.task_id) AS tasks, SUM(w.hours) AS hours FROM employees e LEFT JOIN tasks t ON t.employee_id = e.employee_id LEFT JOIN worklogs w ON w.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(t.task_id) > 5 AND SUM(w.hours) > 160;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(ex.exam_id) FROM exams ex WHERE ex.student_id = s.student_id) AS exams, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE exams > 3 AND avg_grade > 60;", "output": "SELECT s.student_id, COUNT(ex.exam_id) AS exams, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN exams ex ON ex.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(ex.exam_id) > 3 AND AVG(g.grade) > 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.hotel_id = h.hotel_id) AS revenue FROM hotels h) t WHERE bookings > 80 AND revenue > 7000;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, SUM(p.payment_amount) AS revenue FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN payments p ON p.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 80 AND SUM(p.payment_amount) > 7000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS earnings FROM drivers d) t WHERE rides > 40 AND earnings > 2500;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, SUM(p.amount) AS earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 40 AND SUM(p.amount) > 2500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT AVG(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS avg_score FROM games g) t WHERE plays > 10 AND avg_score > 30;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, AVG(sc.score) AS avg_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 10 AND AVG(sc.score) > 30;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT SUM(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS total_rating FROM cities c) t WHERE restaurants > 30 AND total_rating > 200;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, SUM(rv.rating) AS total_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 30 AND SUM(rv.rating) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT AVG(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS avg_salary FROM companies co) t WHERE employees > 100 AND avg_salary > 40000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, AVG(s.salary) AS avg_salary FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 100 AND AVG(s.salary) > 40000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 40 AND revenue > 1500;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 40 AND SUM(s.amount) > 1500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 15 AND avg_score > 20;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 15 AND AVG(sc.score) > 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 20 AND avg_rating > 3.5;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 20 AND AVG(r.rating) > 3.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 25 AND avg_grade > 55;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 25 AND AVG(g.grade) > 55;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 50 AND total_revenue > 10000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 50 AND SUM(p.payment_amount) > 10000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT MIN(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS min_val FROM sensors sn) t WHERE max_val > 80 AND min_val < 20;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, MIN(r.value) AS min_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 80 AND MIN(r.value) < 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT AVG(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS avg_rating FROM authors a) t WHERE books > 5 AND avg_rating > 2.5;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, AVG(r.rating) AS avg_rating FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 5 AND AVG(r.rating) > 2.5;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT SUM(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS total_grades FROM courses c) t WHERE enrolled > 12 AND total_grades > 400;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, SUM(g.grade) AS total_grades FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 12 AND SUM(g.grade) > 400;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 10 AND total_weight > 50;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 10 AND SUM(p.weight) > 50;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(l.login_id) FROM logins l WHERE l.user_id = u.user_id) AS logins, (SELECT SUM(p.purchase_amount) FROM purchases p WHERE p.user_id = u.user_id) AS spent FROM users u) t WHERE logins > 20 AND spent > 500;", "output": "SELECT u.user_id, COUNT(l.login_id) AS logins, SUM(p.purchase_amount) AS spent FROM users u LEFT JOIN logins l ON l.user_id = u.user_id LEFT JOIN purchases p ON p.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(l.login_id) > 20 AND SUM(p.purchase_amount) > 500;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT COUNT(oi.item_id) FROM order_items oi WHERE oi.order_id = o.order_id) AS items, (SELECT SUM(sh.shipping_cost) FROM shippings sh WHERE sh.order_id = o.order_id) AS shipping FROM orders o) t WHERE items > 5 AND shipping < 100;", "output": "SELECT o.order_id, COUNT(oi.item_id) AS items, SUM(sh.shipping_cost) AS shipping FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN shippings sh ON sh.order_id = o.order_id GROUP BY o.order_id HAVING COUNT(oi.item_id) > 5 AND SUM(sh.shipping_cost) < 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(p.project_id) FROM projects p WHERE p.employee_id = e.employee_id) AS projects, (SELECT AVG(s.salary) FROM salaries s WHERE s.employee_id = e.employee_id) AS avg_salary FROM employees e) t WHERE projects > 3 AND avg_salary > 45000;", "output": "SELECT e.employee_id, COUNT(p.project_id) AS projects, AVG(s.salary) AS avg_salary FROM employees e LEFT JOIN projects p ON p.employee_id = e.employee_id LEFT JOIN salaries s ON s.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(p.project_id) > 3 AND AVG(s.salary) > 45000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT AVG(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS avg_grade FROM students s) t WHERE courses > 2 AND avg_grade > 65;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, AVG(g.grade) AS avg_grade FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 2 AND AVG(g.grade) > 65;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT SUM(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS rating_sum FROM hotels h) t WHERE bookings > 60 AND rating_sum > 200;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, SUM(r.rating) AS rating_sum FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 60 AND SUM(r.rating) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT AVG(r.rating) FROM rides r WHERE r.driver_id = d.driver_id) AS avg_rating FROM drivers d) t WHERE rides > 30 AND avg_rating > 4;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, AVG(r.rating) AS avg_rating FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 30 AND AVG(r.rating) > 4;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS score_sum FROM games g) t WHERE plays > 8 AND score_sum > 100;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS score_sum FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 8 AND SUM(sc.score) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT AVG(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS avg_rating FROM cities c) t WHERE restaurants > 25 AND avg_rating > 3.2;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, AVG(rv.rating) AS avg_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 25 AND AVG(rv.rating) > 3.2;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT SUM(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS payroll FROM companies co) t WHERE employees > 200 AND payroll > 5000000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, SUM(s.salary) AS payroll FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 200 AND SUM(s.salary) > 5000000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT AVG(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS avg_sale FROM stores st) t WHERE sales > 30 AND avg_sale > 40;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, AVG(s.amount) AS avg_sale FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 30 AND AVG(s.amount) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT SUM(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS total_score FROM players pl) t WHERE matches > 18 AND total_score > 200;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, SUM(sc.score) AS total_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 18 AND SUM(sc.score) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT SUM(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS total_ratings FROM books b) t WHERE borrows > 12 AND total_ratings > 30;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, SUM(r.rating) AS total_ratings FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 12 AND SUM(r.rating) > 30;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT AVG(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS avg_grade FROM classes cl) t WHERE total_students > 20 AND avg_grade > 55;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, AVG(g.grade) AS avg_grade FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 20 AND AVG(g.grade) > 55;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT AVG(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS avg_payment FROM events ev) t WHERE total_tickets > 60 AND avg_payment > 80;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, AVG(p.payment_amount) AS avg_payment FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 60 AND AVG(p.payment_amount) > 80;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT AVG(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS avg_val FROM sensors sn) t WHERE max_val > 70 AND avg_val > 40;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, AVG(r.value) AS avg_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 70 AND AVG(r.value) > 40;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT AVG(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS avg_rating FROM authors a) t WHERE books > 8 AND avg_rating > 3;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, AVG(r.rating) AS avg_rating FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 8 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT SUM(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS total_grades FROM courses c) t WHERE enrolled > 10 AND total_grades > 300;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, SUM(g.grade) AS total_grades FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 10 AND SUM(g.grade) > 300;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 12 AND total_weight > 70;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 12 AND SUM(p.weight) > 70;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT u.user_id, (SELECT COUNT(f.friend_id) FROM friends f WHERE f.user_id = u.user_id) AS friends, (SELECT COUNT(m.message_id) FROM messages m WHERE m.user_id = u.user_id) AS messages FROM users u) t WHERE friends > 50 AND messages > 200;", "output": "SELECT u.user_id, COUNT(f.friend_id) AS friends, COUNT(m.message_id) AS messages FROM users u LEFT JOIN friends f ON f.user_id = u.user_id LEFT JOIN messages m ON m.user_id = u.user_id GROUP BY u.user_id HAVING COUNT(f.friend_id) > 50 AND COUNT(m.message_id) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT o.order_id, (SELECT SUM(oi.price * oi.qty) FROM order_items oi WHERE oi.order_id = o.order_id) AS total_value, (SELECT COUNT(r.return_id) FROM returns r WHERE r.order_id = o.order_id) AS returns FROM orders o) t WHERE total_value > 500 AND returns = 0;", "output": "SELECT o.order_id, SUM(oi.price * oi.qty) AS total_value, COUNT(r.return_id) AS returns FROM orders o LEFT JOIN order_items oi ON oi.order_id = o.order_id LEFT JOIN returns r ON r.order_id = o.order_id GROUP BY o.order_id HAVING SUM(oi.price * oi.qty) > 500 AND COUNT(r.return_id) = 0;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT e.employee_id, (SELECT COUNT(a.attendance_id) FROM attendance a WHERE a.employee_id = e.employee_id) AS days_present, (SELECT SUM(w.hours) FROM worklogs w WHERE w.employee_id = e.employee_id) AS total_hours FROM employees e) t WHERE days_present > 20 AND total_hours > 160;", "output": "SELECT e.employee_id, COUNT(a.attendance_id) AS days_present, SUM(w.hours) AS total_hours FROM employees e LEFT JOIN attendance a ON a.employee_id = e.employee_id LEFT JOIN worklogs w ON w.employee_id = e.employee_id GROUP BY e.employee_id HAVING COUNT(a.attendance_id) > 20 AND SUM(w.hours) > 160;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT s.student_id, (SELECT COUNT(c.course_id) FROM courses c WHERE c.student_id = s.student_id) AS courses, (SELECT SUM(g.grade) FROM grades g WHERE g.student_id = s.student_id) AS total_grades FROM students s) t WHERE courses > 3 AND total_grades > 200;", "output": "SELECT s.student_id, COUNT(c.course_id) AS courses, SUM(g.grade) AS total_grades FROM students s LEFT JOIN courses c ON c.student_id = s.student_id LEFT JOIN grades g ON g.student_id = s.student_id GROUP BY s.student_id HAVING COUNT(c.course_id) > 3 AND SUM(g.grade) > 200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT h.hotel_id, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id) AS bookings, (SELECT AVG(r.rating) FROM reviews r WHERE r.hotel_id = h.hotel_id) AS avg_rating FROM hotels h) t WHERE bookings > 40 AND avg_rating > 3.7;", "output": "SELECT h.hotel_id, COUNT(b.booking_id) AS bookings, AVG(r.rating) AS avg_rating FROM hotels h LEFT JOIN bookings b ON b.hotel_id = h.hotel_id LEFT JOIN reviews r ON r.hotel_id = h.hotel_id GROUP BY h.hotel_id HAVING COUNT(b.booking_id) > 40 AND AVG(r.rating) > 3.7;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT d.driver_id, (SELECT COUNT(r.ride_id) FROM rides r WHERE r.driver_id = d.driver_id) AS rides, (SELECT SUM(p.amount) FROM payments p WHERE p.driver_id = d.driver_id) AS earnings FROM drivers d) t WHERE rides > 15 AND earnings > 2000;", "output": "SELECT d.driver_id, COUNT(r.ride_id) AS rides, SUM(p.amount) AS earnings FROM drivers d LEFT JOIN rides r ON r.driver_id = d.driver_id LEFT JOIN payments p ON p.driver_id = d.driver_id GROUP BY d.driver_id HAVING COUNT(r.ride_id) > 15 AND SUM(p.amount) > 2000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT g.game_id, (SELECT COUNT(p.play_id) FROM plays p WHERE p.game_id = g.game_id) AS plays, (SELECT SUM(sc.score) FROM scores sc WHERE sc.game_id = g.game_id) AS total_score FROM games g) t WHERE plays > 12 AND total_score > 180;", "output": "SELECT g.game_id, COUNT(p.play_id) AS plays, SUM(sc.score) AS total_score FROM games g LEFT JOIN plays p ON p.game_id = g.game_id LEFT JOIN scores sc ON sc.game_id = g.game_id GROUP BY g.game_id HAVING COUNT(p.play_id) > 12 AND SUM(sc.score) > 180;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.city_id, (SELECT COUNT(r.restaurant_id) FROM restaurants r WHERE r.city_id = c.city_id) AS restaurants, (SELECT SUM(rv.rating) FROM reviews rv WHERE rv.city_id = c.city_id) AS total_rating FROM cities c) t WHERE restaurants > 20 AND total_rating > 100;", "output": "SELECT c.city_id, COUNT(r.restaurant_id) AS restaurants, SUM(rv.rating) AS total_rating FROM cities c LEFT JOIN restaurants r ON r.city_id = c.city_id LEFT JOIN reviews rv ON rv.city_id = c.city_id GROUP BY c.city_id HAVING COUNT(r.restaurant_id) > 20 AND SUM(rv.rating) > 100;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT co.company_id, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.company_id = co.company_id) AS employees, (SELECT AVG(s.salary) FROM salaries s WHERE s.company_id = co.company_id) AS avg_salary FROM companies co) t WHERE employees > 150 AND avg_salary > 38000;", "output": "SELECT co.company_id, COUNT(e.employee_id) AS employees, AVG(s.salary) AS avg_salary FROM companies co LEFT JOIN employees e ON e.company_id = co.company_id LEFT JOIN salaries s ON s.company_id = co.company_id GROUP BY co.company_id HAVING COUNT(e.employee_id) > 150 AND AVG(s.salary) > 38000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT st.store_id, (SELECT COUNT(s.sale_id) FROM sales s WHERE s.store_id = st.store_id) AS sales, (SELECT SUM(s2.amount) FROM sales s2 WHERE s2.store_id = st.store_id) AS revenue FROM stores st) t WHERE sales > 20 AND revenue > 1200;", "output": "SELECT st.store_id, COUNT(s.sale_id) AS sales, SUM(s.amount) AS revenue FROM stores st LEFT JOIN sales s ON s.store_id = st.store_id GROUP BY st.store_id HAVING COUNT(s.sale_id) > 20 AND SUM(s.amount) > 1200;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT pl.player_id, (SELECT COUNT(m.match_id) FROM matches m WHERE m.player_id = pl.player_id) AS matches, (SELECT AVG(sc.score) FROM scores sc WHERE sc.player_id = pl.player_id) AS avg_score FROM players pl) t WHERE matches > 25 AND avg_score > 22;", "output": "SELECT pl.player_id, COUNT(m.match_id) AS matches, AVG(sc.score) AS avg_score FROM players pl LEFT JOIN matches m ON m.player_id = pl.player_id LEFT JOIN scores sc ON sc.player_id = pl.player_id GROUP BY pl.player_id HAVING COUNT(m.match_id) > 25 AND AVG(sc.score) > 22;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT b.book_id, (SELECT COUNT(br.borrow_id) FROM borrows br WHERE br.book_id = b.book_id) AS borrows, (SELECT AVG(r.rating) FROM ratings r WHERE r.book_id = b.book_id) AS avg_rating FROM books b) t WHERE borrows > 10 AND avg_rating > 3;", "output": "SELECT b.book_id, COUNT(br.borrow_id) AS borrows, AVG(r.rating) AS avg_rating FROM books b LEFT JOIN borrows br ON br.book_id = b.book_id LEFT JOIN ratings r ON r.book_id = b.book_id GROUP BY b.book_id HAVING COUNT(br.borrow_id) > 10 AND AVG(r.rating) > 3;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT cl.class_id, (SELECT COUNT(st.student_id) FROM students st WHERE st.class_id = cl.class_id) AS total_students, (SELECT SUM(g.grade) FROM grades g WHERE g.class_id = cl.class_id) AS total_grades FROM classes cl) t WHERE total_students > 35 AND total_grades > 800;", "output": "SELECT cl.class_id, COUNT(st.student_id) AS total_students, SUM(g.grade) AS total_grades FROM classes cl LEFT JOIN students st ON st.class_id = cl.class_id LEFT JOIN grades g ON g.class_id = cl.class_id GROUP BY cl.class_id HAVING COUNT(st.student_id) > 35 AND SUM(g.grade) > 800;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT ev.event_id, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.event_id = ev.event_id) AS total_tickets, (SELECT SUM(p.payment_amount) FROM payments p WHERE p.event_id = ev.event_id) AS total_revenue FROM events ev) t WHERE total_tickets > 30 AND total_revenue > 5000;", "output": "SELECT ev.event_id, COUNT(t.ticket_id) AS total_tickets, SUM(p.payment_amount) AS total_revenue FROM events ev LEFT JOIN tickets t ON t.event_id = ev.event_id LEFT JOIN payments p ON p.event_id = ev.event_id GROUP BY ev.event_id HAVING COUNT(t.ticket_id) > 30 AND SUM(p.payment_amount) > 5000;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.account_id, (SELECT SUM(t.amount) FROM transactions t WHERE t.account_id = a.account_id AND t.type = 'credit') AS credits, (SELECT SUM(t2.amount) FROM transactions t2 WHERE t2.account_id = a.account_id AND t2.type = 'debit') AS debits FROM accounts a) t WHERE credits > debits;", "output": "SELECT a.account_id, SUM(CASE WHEN t.type = 'credit' THEN t.amount END) AS credits, SUM(CASE WHEN t.type = 'debit' THEN t.amount END) AS debits FROM accounts a LEFT JOIN transactions t ON t.account_id = a.account_id GROUP BY a.account_id HAVING SUM(CASE WHEN t.type = 'credit' THEN t.amount END) > SUM(CASE WHEN t.type = 'debit' THEN t.amount END);"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sn.sensor_id, (SELECT MAX(r.value) FROM readings r WHERE r.sensor_id = sn.sensor_id) AS max_val, (SELECT MIN(r2.value) FROM readings r2 WHERE r2.sensor_id = sn.sensor_id) AS min_val FROM sensors sn) t WHERE max_val > 60 AND min_val < 20;", "output": "SELECT sn.sensor_id, MAX(r.value) AS max_val, MIN(r.value) AS min_val FROM sensors sn LEFT JOIN readings r ON r.sensor_id = sn.sensor_id GROUP BY sn.sensor_id HAVING MAX(r.value) > 60 AND MIN(r.value) < 20;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT a.author_id, (SELECT COUNT(b.book_id) FROM books b WHERE b.author_id = a.author_id) AS books, (SELECT SUM(r.rating) FROM ratings r WHERE r.author_id = a.author_id) AS rating_sum FROM authors a) t WHERE books > 6 AND rating_sum > 25;", "output": "SELECT a.author_id, COUNT(b.book_id) AS books, SUM(r.rating) AS rating_sum FROM authors a LEFT JOIN books b ON b.author_id = a.author_id LEFT JOIN ratings r ON r.author_id = a.author_id GROUP BY a.author_id HAVING COUNT(b.book_id) > 6 AND SUM(r.rating) > 25;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT c.course_id, (SELECT COUNT(e.student_id) FROM enrollments e WHERE e.course_id = c.course_id) AS enrolled, (SELECT AVG(g.grade) FROM grades g WHERE g.course_id = c.course_id) AS avg_grade FROM courses c) t WHERE enrolled > 15 AND avg_grade > 60;", "output": "SELECT c.course_id, COUNT(e.student_id) AS enrolled, AVG(g.grade) AS avg_grade FROM courses c LEFT JOIN enrollments e ON e.course_id = c.course_id LEFT JOIN grades g ON g.course_id = c.course_id GROUP BY c.course_id HAVING COUNT(e.student_id) > 15 AND AVG(g.grade) > 60;"}
{"instruction": "Optimize the SQL query", "input": "SELECT * FROM (SELECT sh.shipment_id, (SELECT COUNT(p.package_id) FROM packages p WHERE p.shipment_id = sh.shipment_id) AS packages, (SELECT SUM(p2.weight) FROM packages p2 WHERE p2.shipment_id = sh.shipment_id) AS total_weight FROM shipments sh) t WHERE packages > 8 AND total_weight > 40;", "output": "SELECT sh.shipment_id, COUNT(p.package_id) AS packages, SUM(p.weight) AS total_weight FROM shipments sh LEFT JOIN packages p ON p.shipment_id = sh.shipment_id GROUP BY sh.shipment_id HAVING COUNT(p.package_id) > 8 AND SUM(p.weight) > 40;"}