{"instruction":"Optimize the SQL query","input":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1;","output":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE serial_number = 'ABC123' AND pharmacies_id = 456;","output":"SELECT * FROM assets WHERE serial_number = 'ABC123' AND pharmacies_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL '1 week';","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE facility_id = 789;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE facility_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-07-01' AND '2023-07-31';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-07-01' AND '2023-07-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND is_open = 1;","output":"SELECT * FROM events WHERE events_type_id = 123 AND is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE roles_id = 789 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW();","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW();"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123;","output":"SELECT * FROM pharmacies WHERE activated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT id, full_name FROM staff_directory WHERE org_id = 123;","output":"SELECT id, full_name FROM staff_directory WHERE org_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456;","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE name = 'Fire Hazard' AND description = 'High risk of fire outbreak.';","output":"SELECT * FROM hazards WHERE name = 'Fire Hazard' AND description = 'High risk of fire outbreak.';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE forms_id = 789 AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE forms_id = 789 AND is_default = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_at >= NOW() - INTERVAL '1 week';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id = 789 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = 789 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND is_open = 1;","output":"SELECT * FROM events WHERE users_id = 123 AND is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1;","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND city = 'New York';","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND city = 'New York';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM pharmacies WHERE activated_by >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT user_id, full_name FROM staff_directory WHERE is_active = 1 AND org_id = 123;","output":"SELECT user_id, full_name FROM staff_directory WHERE is_active = 1 AND org_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE created_at >= NOW() - INTERVAL '30 days' OR updated_at >= NOW() - INTERVAL '30 days';","output":"SELECT * FROM assets WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' OR updated_at >= CURRENT_DATE - INTERVAL '30 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months';","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days';","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London';","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND updated_at >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND updated_at >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months' ORDER BY name ASC;","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days' ORDER BY events_type_id ASC;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days' ORDER BY events_type_id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London' ORDER BY trial_ends_at DESC;","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London' ORDER BY trial_ends_at DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND reg_number IS NOT NULL;","output":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND reg_number IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND updated_at >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND updated_at >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months' ORDER BY name ASC LIMIT 10;","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months' ORDER BY name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0 ORDER BY order DESC;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0 ORDER BY \"order\" DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 20;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days' ORDER BY events_type_id ASC LIMIT 50;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days' ORDER BY events_type_id ASC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND updated_at >= NOW() - INTERVAL '3 months';","output":"SELECT full_name, id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND updated_at >= CURRENT_DATE - INTERVAL '3 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND serial_number LIKE 'ABC%';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND serial_number LIKE 'ABC%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%fire%' AND created_at >= NOW() - INTERVAL '6 months' ORDER BY created_at DESC;","output":"SELECT * FROM hazards WHERE description LIKE '%fire%' AND created_at >= CURRENT_DATE - INTERVAL '6 months' ORDER BY created_at DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND name NOT LIKE '%Admin%';","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND name NOT LIKE '%Admin%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 50;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC LIMIT 10;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '1 month' ORDER BY events_type_id ASC LIMIT 20;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '1 month' ORDER BY events_type_id ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT id, full_name FROM staff_directory WHERE official_user_id IS NOT NULL AND org_id = 123 AND is_active = 1;","output":"SELECT id, full_name FROM staff_directory WHERE official_user_id IS NOT NULL AND org_id = 123 AND is_active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name FROM staff_directory WHERE official_user_id IS NOT NULL;","output":"SELECT full_name FROM staff_directory WHERE official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) > 100;","output":"SELECT * FROM hazards WHERE LENGTH(description) > 100;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, `order` FROM event_staff_roles ORDER BY name ASC;","output":"SELECT name, \"order\" FROM event_staff_roles ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE updated_by = 123;","output":"SELECT * FROM event_actions WHERE updated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE is_open = 1;","output":"SELECT * FROM events WHERE is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE type = 'admin' AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE type = 'admin' AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE city = 'New York';","output":"SELECT * FROM organizations WHERE city = 'New York';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123;","output":"SELECT * FROM pharmacies WHERE activated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE 'ABC%';","output":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE 'ABC%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL 30 DAYS AND organizations_id = 789;","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND organizations_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory ORDER BY full_name ASC;","output":"SELECT full_name, id FROM staff_directory ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456;","output":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= NOW() - INTERVAL 6 MONTHS;","output":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= CURRENT_DATE - INTERVAL '6 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE `order` = 1;","output":"SELECT * FROM event_staff_roles WHERE \"order\" = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456;","output":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456;","output":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1;","output":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123;","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01';","output":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS AND organizations_id = 123;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days' AND organizations_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456;","output":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, `order` FROM event_staff_roles ORDER BY `order` DESC;","output":"SELECT name, \"order\" FROM event_staff_roles ORDER BY \"order\" DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE updated_by = 123 AND date_created > '2023-01-01';","output":"SELECT * FROM event_actions WHERE updated_by = 123 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id = 123 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = 123 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE is_open = 1 AND users_id = 123;","output":"SELECT * FROM events WHERE is_open = 1 AND users_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE type = 'admin' AND date_created BETWEEN '2023-01-01' AND '2023-01-31';","output":"SELECT * FROM users WHERE type = 'admin' AND date_created BETWEEN '2023-01-01' AND '2023-01-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE city = 'London' AND date_created > '2023-01-01';","output":"SELECT * FROM organizations WHERE city = 'London' AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123 AND date_created < '2023-01-01';","output":"SELECT * FROM pharmacies WHERE activated_by = 123 AND date_created < '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE '%XYZ';","output":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE '%XYZ';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL 30 DAYS AND organizations_id = 123;","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND organizations_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory ORDER BY id ASC;","output":"SELECT full_name, id FROM staff_directory ORDER BY id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456 AND serial_number = 'XYZ';","output":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456 AND serial_number = 'XYZ';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= NOW() - INTERVAL 6 MONTHS ORDER BY name ASC;","output":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= CURRENT_DATE - INTERVAL '6 months' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE `order` = 1 AND forms_id = 123;","output":"SELECT * FROM event_staff_roles WHERE \"order\" = 1 AND forms_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456 AND action_date BETWEEN '2023-01-01' AND '2023-12-31';","output":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456 AND action_date BETWEEN '2023-01-01' AND '2023-12-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456 AND date_closed >= NOW() - INTERVAL 1 MONTH;","output":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;","output":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123 AND trial_ends_at > NOW();","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123 AND trial_ends_at > NOW();"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01' AND activated_by = 456;","output":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01' AND activated_by = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS AND organizations_id = 123 AND asset_type_id = 456;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days' AND organizations_id = 123 AND asset_type_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456 AND organizations_id = 789;","output":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456 AND organizations_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1;","output":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE serial_number = 'ABC123' AND pharmacies_id = 456;","output":"SELECT * FROM assets WHERE serial_number = 'ABC123' AND pharmacies_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL '1 week';","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE facility_id = 789;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE facility_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-07-01' AND '2023-07-31';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-07-01' AND '2023-07-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND is_open = 1;","output":"SELECT * FROM events WHERE events_type_id = 123 AND is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE roles_id = 789 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW();","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW();"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123;","output":"SELECT * FROM pharmacies WHERE activated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT id, full_name FROM staff_directory WHERE org_id = 123;","output":"SELECT id, full_name FROM staff_directory WHERE org_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456;","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE name = 'Fire Hazard' AND description = 'High risk of fire outbreak.';","output":"SELECT * FROM hazards WHERE name = 'Fire Hazard' AND description = 'High risk of fire outbreak.';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE forms_id = 789 AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE forms_id = 789 AND is_default = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_at >= NOW() - INTERVAL '1 week';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id = 789 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = 789 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND is_open = 1;","output":"SELECT * FROM events WHERE users_id = 123 AND is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1;","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND city = 'New York';","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND city = 'New York';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM pharmacies WHERE activated_by >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT user_id, full_name FROM staff_directory WHERE is_active = 1 AND org_id = 123;","output":"SELECT user_id, full_name FROM staff_directory WHERE is_active = 1 AND org_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE created_at >= NOW() - INTERVAL '30 days' OR updated_at >= NOW() - INTERVAL '30 days';","output":"SELECT * FROM assets WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' OR updated_at >= CURRENT_DATE - INTERVAL '30 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months';","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30';","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days';","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London';","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND updated_at >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND updated_at >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months' ORDER BY name ASC;","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days' ORDER BY events_type_id ASC;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days' ORDER BY events_type_id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;","output":"SELECT * FROM users WHERE roles_id = 789 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London' ORDER BY trial_ends_at DESC;","output":"SELECT * FROM organizations WHERE trial_ends_at > NOW() AND city = 'London' ORDER BY trial_ends_at DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND reg_number IS NOT NULL;","output":"SELECT full_name, employee_id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND reg_number IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND updated_at >= NOW() - INTERVAL '1 month';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND updated_at >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= NOW() - INTERVAL '3 months' ORDER BY name ASC LIMIT 10;","output":"SELECT * FROM hazards WHERE description LIKE '%danger%' AND created_at >= CURRENT_DATE - INTERVAL '3 months' ORDER BY name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0 ORDER BY order DESC;","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND is_default = 0 ORDER BY \"order\" DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 20;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND updated_by = 456 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '7 days' ORDER BY events_type_id ASC LIMIT 50;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '7 days' ORDER BY events_type_id ASC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND updated_at >= NOW() - INTERVAL '3 months';","output":"SELECT full_name, id FROM staff_directory WHERE is_active = 1 AND org_id = 123 AND updated_at >= CURRENT_DATE - INTERVAL '3 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND serial_number LIKE 'ABC%';","output":"SELECT * FROM assets WHERE active = 1 AND organizations_id = 456 AND asset_type_id = 789 AND serial_number LIKE 'ABC%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%fire%' AND created_at >= NOW() - INTERVAL '6 months' ORDER BY created_at DESC;","output":"SELECT * FROM hazards WHERE description LIKE '%fire%' AND created_at >= CURRENT_DATE - INTERVAL '6 months' ORDER BY created_at DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, order FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND name NOT LIKE '%Admin%';","output":"SELECT name, \"order\" FROM event_staff_roles WHERE forms_id = 789 AND facility_id = 456 AND name NOT LIKE '%Admin%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 50;","output":"SELECT * FROM event_actions WHERE user_id = 123 AND action_date BETWEEN '2023-06-01' AND '2023-06-30' ORDER BY action_date DESC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC LIMIT 10;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND facility_id = 456 AND organization_id = 123 ORDER BY tools_id ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= NOW() - INTERVAL '1 month' ORDER BY events_type_id ASC LIMIT 20;","output":"SELECT * FROM events WHERE users_id = 123 AND organization_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '1 month' ORDER BY events_type_id ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;","output":"SELECT * FROM pharmacies WHERE name = 'Pharmacy ABC' AND activated_by = 123 AND date_disabled > '2023-01-01' ORDER BY name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT id, full_name FROM staff_directory WHERE official_user_id IS NOT NULL AND org_id = 123 AND is_active = 1;","output":"SELECT id, full_name FROM staff_directory WHERE official_user_id IS NOT NULL AND org_id = 123 AND is_active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name FROM staff_directory WHERE official_user_id IS NOT NULL;","output":"SELECT full_name FROM staff_directory WHERE official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) > 100;","output":"SELECT * FROM hazards WHERE LENGTH(description) > 100;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, `order` FROM event_staff_roles ORDER BY name ASC;","output":"SELECT name, \"order\" FROM event_staff_roles ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE updated_by = 123;","output":"SELECT * FROM event_actions WHERE updated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE is_open = 1;","output":"SELECT * FROM events WHERE is_open = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE type = 'admin' AND date_created > '2023-01-01';","output":"SELECT * FROM users WHERE type = 'admin' AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE city = 'New York';","output":"SELECT * FROM organizations WHERE city = 'New York';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123;","output":"SELECT * FROM pharmacies WHERE activated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE 'ABC%';","output":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE 'ABC%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL 30 DAYS AND organizations_id = 789;","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND organizations_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory ORDER BY full_name ASC;","output":"SELECT full_name, id FROM staff_directory ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456;","output":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= NOW() - INTERVAL 6 MONTHS;","output":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= CURRENT_DATE - INTERVAL '6 months';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE `order` = 1;","output":"SELECT * FROM event_staff_roles WHERE \"order\" = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456;","output":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456;","output":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1;","output":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123;","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01';","output":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS AND organizations_id = 123;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days' AND organizations_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456;","output":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT name, `order` FROM event_staff_roles ORDER BY `order` DESC;","output":"SELECT name, \"order\" FROM event_staff_roles ORDER BY \"order\" DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE updated_by = 123 AND date_created > '2023-01-01';","output":"SELECT * FROM event_actions WHERE updated_by = 123 AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id = 123 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = 123 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE is_open = 1 AND users_id = 123;","output":"SELECT * FROM events WHERE is_open = 1 AND users_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE type = 'admin' AND date_created BETWEEN '2023-01-01' AND '2023-01-31';","output":"SELECT * FROM users WHERE type = 'admin' AND date_created BETWEEN '2023-01-01' AND '2023-01-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE city = 'London' AND date_created > '2023-01-01';","output":"SELECT * FROM organizations WHERE city = 'London' AND date_created > '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activated_by = 123 AND date_created < '2023-01-01';","output":"SELECT * FROM pharmacies WHERE activated_by = 123 AND date_created < '2023-01-01';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE '%XYZ';","output":"SELECT * FROM assets WHERE active = 1 AND serial_number LIKE '%XYZ';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE created_at >= NOW() - INTERVAL 30 DAYS AND organizations_id = 123;","output":"SELECT * FROM hazards WHERE created_at >= CURRENT_DATE - INTERVAL '30 days' AND organizations_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT full_name, id FROM staff_directory ORDER BY id ASC;","output":"SELECT full_name, id FROM staff_directory ORDER BY id ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456 AND serial_number = 'XYZ';","output":"SELECT * FROM assets WHERE asset_items_id = 123 AND organizations_id = 456 AND serial_number = 'XYZ';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= NOW() - INTERVAL 6 MONTHS ORDER BY name ASC;","output":"SELECT * FROM hazards WHERE description LIKE '%safety%' AND created_at >= CURRENT_DATE - INTERVAL '6 months' ORDER BY name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE `order` = 1 AND forms_id = 123;","output":"SELECT * FROM event_staff_roles WHERE \"order\" = 1 AND forms_id = 123;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456 AND action_date BETWEEN '2023-01-01' AND '2023-12-31';","output":"SELECT * FROM event_actions WHERE events_id = 123 AND user_id = 456 AND action_date BETWEEN '2023-01-01' AND '2023-12-31';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123 AND organization_id = 456;","output":"SELECT * FROM formsettings_summarytools WHERE forms_id = 789 AND updated_by = 123 AND organization_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456 AND date_closed >= NOW() - INTERVAL 1 MONTH;","output":"SELECT * FROM events WHERE events_type_id = 123 AND users_id = 456 AND date_closed >= CURRENT_DATE - INTERVAL '1 month';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;","output":"SELECT * FROM users WHERE profiles_id = 123 AND active = 1 AND date_created > '2023-01-01' ORDER BY full_name ASC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123 AND trial_ends_at > NOW();","output":"SELECT * FROM organizations WHERE date_created > '2023-01-01' AND countries_id = 123 AND trial_ends_at > NOW();"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01' AND activated_by = 456;","output":"SELECT * FROM pharmacies WHERE organizations_id = 123 AND date_created < '2023-01-01' AND activated_by = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE updated_at >= NOW() - INTERVAL 7 DAYS AND organizations_id = 123 AND asset_type_id = 456;","output":"SELECT * FROM assets WHERE updated_at >= CURRENT_DATE - INTERVAL '7 days' AND organizations_id = 123 AND asset_type_id = 456;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456 AND organizations_id = 789;","output":"SELECT * FROM hazards WHERE LENGTH(description) < 50 AND pharmacies_id = 456 AND organizations_id = 789;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND date_updated IS NOT NULL AND date_updated <> NULL AND LENGTH(type) > 0 AND CHAR_LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > CAST('2023-02-01' AS TEXT) AND countries_id IS NOT NULL AND countries_id <> NULL AND EXTRACT(YEAR FROM created_at) = 2023 AND EXTRACT(MONTH FROM created_at) >= 2;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND LOWER(city) = 'chicago' AND city LIKE '%Chicago%';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND LENGTH(user_id) = 5 AND user_id LIKE '13579%';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND active IS NOT NULL AND active = 1;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE is_default = CAST(true AS BOOLEAN) AND forms_id IS NOT NULL AND forms_id <> NULL AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE is_default = true AND forms_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(user_id AS TEXT) = '65432' AND updated_at IS NOT NULL AND updated_at <> NULL AND user_id::text LIKE '65432%';","output":"SELECT * FROM event_actions WHERE user_id = '65432' AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(facility_id AS TEXT) = '54321' AND CAST(organization_id AS TEXT) = '87654' AND tools_id IS NOT NULL AND tools_id <> NULL AND facility_id::text = '54321' AND organization_id::text = '87654';","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = '54321' AND organization_id = '87654' AND tools_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE ((harmt IS NOT NULL AND harmt <> NULL) OR (prescribers_id IS NOT NULL AND prescribers_id <> NULL)) AND is_open = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND date_closed IS NOT NULL AND date_closed <> NULL;","output":"SELECT * FROM events WHERE (harmt IS NOT NULL OR prescribers_id IS NOT NULL) AND is_open = true AND date_created IS NOT NULL AND date_closed IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) > '2023-04-01' AND updated_at IS NOT NULL AND updated_at <> NULL AND is_active = 1;","output":"SELECT * FROM users WHERE is_active = true AND updated_at > '2023-04-01' AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE UPPER(city) = UPPER('Denver') AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND LOWER(city) = 'denver';","output":"SELECT * FROM organizations WHERE city = 'Denver' AND trial_ends_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) = UPPER('Pharmacist D') AND activate_at IS NOT NULL AND activate_at <> NULL AND activated_by ILIKE 'Pharmacist D';","output":"SELECT * FROM pharmacies WHERE activated_by = 'Pharmacist D' AND activate_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '97531' AND employee_id IS NOT NULL AND employee_id <> NULL AND user_id::text = '97531';","output":"SELECT * FROM staff_directory WHERE user_id = '97531' AND employee_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND serial_number <> '' AND LENGTH(serial_number) > 0 AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND serial_number <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(name) = UPPER('Chemical Spill') AND description <> '' AND LENGTH(description) > 0 AND name ILIKE 'Chemical Spill';","output":"SELECT * FROM hazards WHERE name = 'Chemical Spill' AND description <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND \"order\" IS NOT NULL AND \"order\" <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND \"order\" IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '321' AND action_date IS NOT NULL AND action_date <> NULL AND date_done IS NOT NULL AND date_done <> NULL AND events_id::text = '321';","output":"SELECT * FROM event_actions WHERE events_id = '321' AND action_date IS NOT NULL AND date_done IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '876' AND CAST(facility_id AS TEXT) = '543' AND updated_by IS NOT NULL AND updated_by <> NULL AND updated_at IS NOT NULL AND updated_at <> NULL;","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '876' AND facility_id = '543' AND updated_by IS NOT NULL AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '987' AND date_created IS NOT NULL AND date_created <> NULL AND updated_by IS NOT NULL AND updated_by <> NULL AND harmt IS NOT NULL AND harmt <> NULL;","output":"SELECT * FROM events WHERE reporters_id = '987' AND date_created IS NOT NULL AND updated_by IS NOT NULL AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND sf_id IS NOT NULL AND sf_id <> NULL AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND is_active = true AND date_created IS NOT NULL AND sf_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-02-01' AND countries_id IS NOT NULL AND countries_id <> NULL AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND name <> '' AND LENGTH(name) > 0;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL AND trial_ends_at IS NOT NULL AND name <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND activated_by IS NOT NULL AND activated_by <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL AND activated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND fixed = CAST(true AS BOOLEAN) AND user_id::text = '13579';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL AND fixed = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND asset_type_id IS NOT NULL AND asset_type_id <> NULL AND active = 1;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL AND asset_type_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id IS NOT NULL AND pharmacies_id <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL AND pharmacies_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE is_default = CAST(true AS BOOLEAN) AND forms_id IS NOT NULL AND forms_id <> NULL AND facility_id IS NOT NULL AND facility_id <> NULL AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE is_default = true AND forms_id IS NOT NULL AND facility_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(user_id AS TEXT) = '65432' AND updated_at IS NOT NULL AND updated_at <> NULL AND user_pharmacy_id IS NOT NULL AND user_pharmacy_id <> NULL AND user_id::text = '65432';","output":"SELECT * FROM event_actions WHERE user_id = '65432' AND updated_at IS NOT NULL AND user_pharmacy_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(facility_id AS TEXT) = '54321' AND CAST(organization_id AS TEXT) = '87654' AND tools_id IS NOT NULL AND tools_id <> NULL AND updated_by IS NOT NULL AND updated_by <> NULL AND facility_id::text = '54321';","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = '54321' AND organization_id = '87654' AND tools_id IS NOT NULL AND updated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE ((harmt IS NOT NULL AND harmt <> NULL) OR (prescribers_id IS NOT NULL AND prescribers_id <> NULL)) AND is_open = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND date_closed IS NOT NULL AND date_closed <> NULL;","output":"SELECT * FROM events WHERE (harmt IS NOT NULL OR prescribers_id IS NOT NULL) AND is_open = true AND date_created IS NOT NULL AND date_closed IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) > '2023-03-01' AND type IS NOT NULL AND type <> NULL AND date_updated IS NOT NULL AND date_updated <> NULL AND is_active = 1;","output":"SELECT * FROM users WHERE is_active = true AND updated_at > '2023-03-01' AND type IS NOT NULL AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE UPPER(city) = UPPER('Seattle') AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND countries_id IS NOT NULL AND countries_id <> NULL AND city ILIKE 'seattle';","output":"SELECT * FROM organizations WHERE city = 'Seattle' AND trial_ends_at IS NOT NULL AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) = UPPER('Pharmacist B') AND activate_at IS NOT NULL AND activate_at <> NULL AND activated_by ILIKE 'Pharmacist B';","output":"SELECT * FROM pharmacies WHERE activated_by = 'Pharmacist B' AND activate_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '98765' AND created_at IS NOT NULL AND created_at <> NULL AND user_id::text = '98765';","output":"SELECT * FROM staff_directory WHERE user_id = '98765' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(asset_type_id AS TEXT) = '789' AND serial_number IS NOT NULL AND serial_number <> NULL AND asset_type_id::text = '789';","output":"SELECT * FROM assets WHERE asset_type_id = '789' AND serial_number IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '65432' AND description <> '' AND LENGTH(description) > 0 AND pharmacies_id::text = '65432';","output":"SELECT * FROM hazards WHERE pharmacies_id = '65432' AND description <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND \"order\" IS NOT NULL AND \"order\" <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND \"order\" IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '987' AND UPPER(updated_by) = UPPER('John Smith') AND events_id::text = '987' AND updated_by ILIKE 'John Smith';","output":"SELECT * FROM event_actions WHERE events_id = '987' AND updated_by = 'John Smith';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '543' AND UPPER(updated_by) = UPPER('Jane Doe') AND organization_id::text = '543' AND updated_by ILIKE 'Jane Doe';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '543' AND updated_by = 'Jane Doe';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '321' AND harmt IS NOT NULL AND harmt <> NULL AND reporters_id::text = '321';","output":"SELECT * FROM events WHERE reporters_id = '321' AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('Admin' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND LENGTH(type) = 5;","output":"SELECT * FROM users WHERE type = 'Admin' AND is_active = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-01-01' AND CAST(updated_at AS TEXT) < '2023-06-30' AND created_at IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-01-01' AND updated_at < '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Los Angeles') AND daye_enabled IS NOT NULL AND daye_enabled <> NULL AND city ILIKE 'los angeles';","output":"SELECT * FROM pharmacies WHERE city = 'Los Angeles' AND daye_enabled IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(full_name) = UPPER('Jane Doe') AND fixed = CAST(true AS BOOLEAN) AND full_name ILIKE 'Jane Doe';","output":"SELECT * FROM staff_directory WHERE full_name = 'Jane Doe' AND fixed = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) >= '2023-01-01' AND CAST(updated_at AS TEXT) <= '2023-06-30' AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND updated_at BETWEEN '2023-01-01' AND '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(name) LIKE UPPER('Chemical%') AND name IS NOT NULL;","output":"SELECT * FROM hazards WHERE name LIKE 'Chemical%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '789' AND CAST(facility_id AS TEXT) = '654' AND forms_id::text = '789' AND facility_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '789' AND facility_id = '654';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '987' AND UPPER(updated_by) = UPPER('John Smith') AND events_id::text = '987';","output":"SELECT * FROM event_actions WHERE events_id = '987' AND updated_by = 'John Smith';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '543' AND UPPER(updated_by) = UPPER('Jane Doe') AND organization_id::text = '543';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '543' AND updated_by = 'Jane Doe';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '321' AND harmt IS NOT NULL AND harmt <> NULL AND reporters_id::text = '321';","output":"SELECT * FROM events WHERE reporters_id = '321' AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND is_active = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-01-01' AND CAST(updated_at AS TEXT) < '2023-06-30' AND created_at IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-01-01' AND updated_at < '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND user_id::text = '13579';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND updates_by IS NOT NULL AND updates_by <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND updates_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '321' AND action_date IS NOT NULL AND action_date <> NULL AND events_id::text = '321';","output":"SELECT * FROM event_actions WHERE events_id = '321' AND action_date IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '876' AND CAST(facility_id AS TEXT) = '543' AND updated_by IS NOT NULL AND updated_by <> NULL AND organization_id::text = '876';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '876' AND facility_id = '543' AND updated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '987' AND date_created IS NOT NULL AND date_created <> NULL AND reporters_id::text = '987';","output":"SELECT * FROM events WHERE reporters_id = '987' AND date_created IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND date_updated IS NOT NULL AND date_updated <> NULL AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-02-01' AND countries_id IS NOT NULL AND countries_id <> NULL AND created_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(employee_id) LIKE UPPER('EMP-%') AND employee_id IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE employee_id LIKE 'EMP-%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(updated_at AS TEXT) > CAST((CURRENT_TIMESTAMP - INTERVAL '1 day') AS TEXT) AND updated_at IS NOT NULL;","output":"SELECT * FROM assets WHERE updated_at > (CURRENT_TIMESTAMP - INTERVAL '1 day');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies WHERE UPPER(name) LIKE UPPER('%Healthcare%') AND name IS NOT NULL);","output":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies WHERE name LIKE '%Healthcare%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE UPPER(name) LIKE UPPER('%Coordinator%') AND name IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE name LIKE '%Coordinator%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id IN (SELECT user_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE UPPER(role) = UPPER('Supervisor') AND role IS NOT NULL) AND user_id IS NOT NULL);","output":"SELECT * FROM event_actions WHERE user_id IN (SELECT user_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE role = 'Supervisor'));"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('S%') AND city IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'S%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE harmt IS NOT NULL AND harmt <> NULL AND reporters_id IN (SELECT users_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE UPPER(role) = UPPER('Admin') AND role IS NOT NULL) AND users_id IS NOT NULL);","output":"SELECT * FROM events WHERE harmt IS NOT NULL AND reporters_id IN (SELECT users_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE role = 'Admin'));"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(1 AS BOOLEAN) AND EXTRACT(DOW FROM updated_at) IN (1, 7) AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE is_active = 1 AND DAYOFWEEK(updated_at) IN (1, 7);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE sf_id IN (SELECT sf_id FROM organizations GROUP BY sf_id HAVING COUNT(DISTINCT countries_id) > 1 AND COUNT(DISTINCT countries_id) <> 0);","output":"SELECT * FROM organizations WHERE sf_id IN (SELECT sf_id FROM organizations GROUP BY sf_id HAVING COUNT(DISTINCT countries_id) > 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) LIKE UPPER('%Pharma%') AND organizations_id IN (SELECT organizations_id FROM organizations WHERE UPPER(address) LIKE UPPER('P%') AND address IS NOT NULL);","output":"SELECT * FROM pharmacies WHERE activated_by LIKE '%Pharma%' AND organizations_id IN (SELECT organizations_id FROM organizations WHERE address LIKE 'P%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(full_name) LIKE UPPER('%John%') AND UPPER(full_name) LIKE UPPER('%Doe%') AND full_name IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE full_name LIKE '%John%' AND full_name LIKE '%Doe%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id IN (SELECT MAX(CAST(asset_items_id AS BIGINT)) FROM assets WHERE asset_items_id IS NOT NULL);","output":"SELECT * FROM assets WHERE asset_items_id IN (SELECT MAX(asset_items_id) FROM assets);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies GROUP BY pharmacies_id ORDER BY COUNT(*) DESC, pharmacies_id ASC LIMIT 1);","output":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies GROUP BY pharmacies_id ORDER BY COUNT(*) DESC LIMIT 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE forms_id IN (SELECT forms_id FROM event_staff_roles GROUP BY forms_id ORDER BY COUNT(*) DESC, forms_id ASC);","output":"SELECT * FROM event_staff_roles WHERE forms_id IN (SELECT forms_id FROM event_staff_roles GROUP BY forms_id ORDER BY COUNT(*) DESC);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE EXTRACT(DOW FROM action_date) IN (5, 6) AND action_date IS NOT NULL;","output":"SELECT * FROM event_actions WHERE WEEKDAY(action_date) IN (5, 6);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE organization_id IN (SELECT organization_id FROM organizations WHERE UPPER(name) LIKE UPPER('%Institute%') AND name IS NOT NULL) AND facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('M%') AND city IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE organization_id IN (SELECT organization_id FROM organizations WHERE name LIKE '%Institute%') AND facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'M%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(harmt AS TEXT) = CAST(prescribers_id AS TEXT) AND harmt IS NOT NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE harmt = prescribers_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(date_created AS DATE) = CAST(updated_at AS DATE) AND date_created IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE DATE(date_created) = DATE(updated_at);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at IN (SELECT trial_ends_at FROM organizations GROUP BY trial_ends_at HAVING COUNT(*) > 1 AND COUNT(*) <> 0);","output":"SELECT * FROM organizations WHERE trial_ends_at IN (SELECT trial_ends_at FROM organizations GROUP BY trial_ends_at HAVING COUNT(*) > 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activate_at = CAST('specific_date' AS TIMESTAMP) AND activated_by = SUBSTRING(name, 1, 2) AND name IS NOT NULL;","output":"SELECT * FROM pharmacies WHERE activate_at = 'specific_date' AND activated_by = SUBSTRING(name, 1, 2);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE employee_id = REVERSE(employee_id) AND employee_id IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE employee_id = REVERSE(employee_id);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE serial_number ~ '[0-9]{3}' AND serial_number IS NOT NULL;","output":"SELECT * FROM assets WHERE serial_number REGEXP '[0-9]{3}';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE (UPPER(description) LIKE UPPER('%color1%') OR UPPER(description) LIKE UPPER('%color2%') OR UPPER(description) LIKE UPPER('%color3%')) AND description IS NOT NULL;","output":"SELECT * FROM hazards WHERE description LIKE '%color1%' OR description LIKE '%color2%' OR description LIKE '%color3%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE \"order\" = forms_id AND \"order\" IS NOT NULL AND forms_id IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE order = forms_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = user_pharmacy_id AND user_id IS NOT NULL AND user_pharmacy_id IS NOT NULL;","output":"SELECT * FROM event_actions WHERE user_id = user_pharmacy_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MAX(updated_at) FROM formsettings_summarytools WHERE updated_at IS NOT NULL) UNION SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MIN(updated_at) FROM formsettings_summarytools WHERE updated_at IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MAX(updated_at) FROM formsettings_summarytools) UNION SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MIN(updated_at) FROM formsettings_summarytools);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE LENGTH(harmt) = LENGTH(prescribers_id) AND harmt IS NOT NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE LENGTH(harmt) = LENGTH(prescribers_id);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE updated_at >= (SELECT DATE_SUB(NOW(), INTERVAL '1 week')) GROUP BY user_id HAVING COUNT(DISTINCT DATE(updated_at)) >= 2 AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE updated_at >= (SELECT DATE_SUB(NOW(), INTERVAL 1 WEEK)) GROUP BY user_id HAVING COUNT(DISTINCT DATE(updated_at)) >= 2;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at = DATE(created_at) AND trial_ends_at IS NOT NULL AND created_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE trial_ends_at = DATE(created_at);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE (SELECT COUNT(*) FROM pharmacies WHERE daye_enabled IS NOT NULL) > (SELECT COUNT(*) FROM pharmacies WHERE date_disabled IS NOT NULL);","output":"SELECT * FROM pharmacies WHERE (SELECT COUNT() FROM pharmacies WHERE daye_enabled IS NOT NULL) > (SELECT COUNT() FROM pharmacies WHERE date_disabled IS NOT NULL);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE LENGTH(full_name) = (SELECT MAX(LENGTH(full_name)) FROM staff_directory WHERE full_name IS NOT NULL) AND full_name IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE LENGTH(full_name) = (SELECT MAX(LENGTH(full_name)) FROM staff_directory);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(updated_at AS TEXT) > CAST((CURRENT_TIMESTAMP - INTERVAL '1 day') AS TEXT) AND serial_number ~ '([A-Za-z0-9]{2})+' AND serial_number IS NOT NULL;","output":"SELECT * FROM assets WHERE updated_at > (CURRENT_TIMESTAMP - INTERVAL 1 DAY) AND serial_number REGEXP '([A-Za-z0-9]{2})+';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(description) LIKE UPPER('%industry_keyword%') AND description IS NOT NULL;","output":"SELECT * FROM hazards WHERE description LIKE '%industry_keyword%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE UPPER(name) LIKE UPPER('%Lead%') ORDER BY \"order\" DESC AND name IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE name LIKE '%Lead%' ORDER BY order DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE EXTRACT(DOW FROM action_date) IN (5, 6) AND date_done IS NOT NULL AND date_done <> NULL AND action_date IS NOT NULL;","output":"SELECT * FROM event_actions WHERE WEEKDAY(action_date) IN (5, 6) AND date_done IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('M%') AND city IS NOT NULL) AND updated_by IN (SELECT name FROM organizations WHERE UPPER(name) LIKE UPPER('%Institute%') AND name IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'M%') AND updated_by IN (SELECT name FROM organizations WHERE name LIKE '%Institute%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(harmt AS TEXT) = CAST(prescribers_id AS TEXT) AND harmt IS NOT NULL AND harmt <> NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE harmt = prescribers_id AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(first_name) = UPPER('john') AND LOWER(last_name) = LOWER('doe') AND LENGTH(email) > 10 AND CHAR_LENGTH(phone) = 12 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND updated_at <> NULL","output":"SELECT * FROM users WHERE first_name = 'john' AND last_name = 'doe' AND LENGTH(email) > 10 AND LENGTH(phone) = 12 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL"}
{"instruction":"Optimize the SQL query","input":"SELECT product_id, product_name, price FROM products WHERE price BETWEEN 100.00 AND 500.00 AND category_id IN (SELECT category_id FROM categories WHERE category_name ILIKE '%electronics%') ORDER BY price DESC, product_name ASC LIMIT 50 OFFSET 0","output":"SELECT product_id, product_name, price FROM products WHERE price BETWEEN 100.00 AND 500.00 AND category_id IN (SELECT category_id FROM categories WHERE category_name ILIKE '%electronics%') ORDER BY price DESC, product_name ASC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, COUNT(*) as order_count, SUM(total_amount) as total_spent FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2023 AND EXTRACT(MONTH FROM order_date) BETWEEN 1 AND 6 GROUP BY customer_id HAVING COUNT(*) > 5 AND SUM(total_amount) > 1000.00 ORDER BY total_spent DESC","output":"SELECT customer_id, COUNT(*) as order_count, SUM(total_amount) as total_spent FROM orders WHERE order_date >= '2023-01-01' AND order_date < '2023-07-01' GROUP BY customer_id HAVING COUNT(*) > 5 AND SUM(total_amount) > 1000.00 ORDER BY total_spent DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM employees WHERE (department = 'IT' OR department = 'Engineering') AND salary > 75000 AND EXTRACT(YEAR FROM hire_date) > 2018 AND active = TRUE AND manager_id IS NOT NULL ORDER BY last_name, first_name","output":"SELECT * FROM employees WHERE department IN ('IT', 'Engineering') AND salary > 75000 AND hire_date > '2018-12-31' AND active = true AND manager_id IS NOT NULL ORDER BY last_name, first_name"}
{"instruction":"Optimize the SQL query","input":"SELECT product_id, product_name, description FROM products WHERE description LIKE '%wireless%' AND description LIKE '%bluetooth%' AND description NOT LIKE '%cord%' AND price < 200.00 AND stock_quantity > 0 AND category_id IN (1,2,3,4,5)","output":"SELECT product_id, product_name, description FROM products WHERE description LIKE '%wireless%' AND description LIKE '%bluetooth%' AND description NOT LIKE '%cord%' AND price < 200.00 AND stock_quantity > 0 AND category_id IN (1,2,3,4,5)"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, c.customer_name, SUM(od.quantity * od.unit_price) as order_total FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, c.customer_name HAVING SUM(od.quantity * od.unit_price) > 500.00 ORDER BY order_total DESC","output":"SELECT o.order_id, o.order_date, c.customer_name, SUM(od.quantity * od.unit_price) as order_total FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, c.customer_name HAVING SUM(od.quantity * od.unit_price) > 500.00 ORDER BY order_total DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT employee_id, first_name, last_name, email, phone, department, salary FROM employees WHERE salary BETWEEN 50000 AND 100000 AND department IN ('Sales', 'Marketing', 'Finance') AND hire_date > '2020-01-01' AND active = 1 ORDER BY salary DESC, last_name ASC, first_name ASC LIMIT 25","output":"SELECT employee_id, first_name, last_name, email, phone, department, salary FROM employees WHERE salary BETWEEN 50000 AND 100000 AND department IN ('Sales', 'Marketing', 'Finance') AND hire_date > '2020-01-01' AND active = 1 ORDER BY salary DESC, last_name ASC, first_name ASC LIMIT 25"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, c.category_name, p.price, p.stock_quantity FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50.00 AND p.stock_quantity > 10 AND c.category_name LIKE '%Home%' AND p.discontinued = FALSE ORDER BY p.price ASC, p.product_name ASC","output":"SELECT p.product_id, p.product_name, c.category_name, p.price, p.stock_quantity FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50.00 AND p.stock_quantity > 10 AND c.category_name LIKE '%Home%' AND p.discontinued = false ORDER BY p.price ASC, p.product_name ASC"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, customer_name, email, phone, address, city, state, zip_code FROM customers WHERE (city = 'New York' OR city = 'Los Angeles' OR city = 'Chicago') AND created_at >= '2022-01-01' AND email IS NOT NULL AND phone IS NOT NULL ORDER BY customer_name ASC","output":"SELECT customer_id, customer_name, email, phone, address, city, state, zip_code FROM customers WHERE city IN ('New York', 'Los Angeles', 'Chicago') AND created_at >= '2022-01-01' AND email IS NOT NULL AND phone IS NOT NULL ORDER BY customer_name ASC"}
{"instruction":"Optimize the SQL query","input":"SELECT order_id, customer_id, order_date, total_amount, status FROM orders WHERE status IN ('Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-03-31' AND total_amount > 100.00 ORDER BY order_date DESC, total_amount DESC","output":"SELECT order_id, customer_id, order_date, total_amount, status FROM orders WHERE status IN ('Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-03-31' AND total_amount > 100.00 ORDER BY order_date DESC, total_amount DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(first_name) = UPPER('john') AND LOWER(last_name) = LOWER('doe') AND LENGTH(email) > 10 AND CHAR_LENGTH(phone) = 12 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND updated_at <> NULL","output":"SELECT * FROM users WHERE first_name = 'john' AND last_name = 'doe' AND LENGTH(email) > 10 AND LENGTH(phone) = 12 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL"}
{"instruction":"Optimize the SQL query","input":"SELECT product_id, product_name, price FROM products WHERE price BETWEEN 100.00 AND 500.00 AND category_id IN (SELECT category_id FROM categories WHERE category_name ILIKE '%electronics%') ORDER BY price DESC, product_name ASC LIMIT 50 OFFSET 0","output":"SELECT product_id, product_name, price FROM products WHERE price BETWEEN 100.00 AND 500.00 AND category_id IN (SELECT category_id FROM categories WHERE category_name ILIKE '%electronics%') ORDER BY price DESC, product_name ASC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, COUNT(*) as order_count, SUM(total_amount) as total_spent FROM orders WHERE EXTRACT(YEAR FROM order_date) = 2023 AND EXTRACT(MONTH FROM order_date) BETWEEN 1 AND 6 GROUP BY customer_id HAVING COUNT(*) > 5 AND SUM(total_amount) > 1000.00 ORDER BY total_spent DESC","output":"SELECT customer_id, COUNT(*) as order_count, SUM(total_amount) as total_spent FROM orders WHERE order_date >= '2023-01-01' AND order_date < '2023-07-01' GROUP BY customer_id HAVING COUNT(*) > 5 AND SUM(total_amount) > 1000.00 ORDER BY total_spent DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM employees WHERE (department = 'IT' OR department = 'Engineering') AND salary > 75000 AND EXTRACT(YEAR FROM hire_date) > 2018 AND active = TRUE AND manager_id IS NOT NULL ORDER BY last_name, first_name","output":"SELECT * FROM employees WHERE department IN ('IT', 'Engineering') AND salary > 75000 AND hire_date > '2018-12-31' AND active = true AND manager_id IS NOT NULL ORDER BY last_name, first_name"}
{"instruction":"Optimize the SQL query","input":"SELECT product_id, product_name, description FROM products WHERE description LIKE '%wireless%' AND description LIKE '%bluetooth%' AND description NOT LIKE '%cord%' AND price < 200.00 AND stock_quantity > 0 AND category_id IN (1,2,3,4,5)","output":"SELECT product_id, product_name, description FROM products WHERE description LIKE '%wireless%' AND description LIKE '%bluetooth%' AND description NOT LIKE '%cord%' AND price < 200.00 AND stock_quantity > 0 AND category_id IN (1,2,3,4,5)"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, c.customer_name, SUM(od.quantity * od.unit_price) as order_total FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, c.customer_name HAVING SUM(od.quantity * od.unit_price) > 500.00 ORDER BY order_total DESC","output":"SELECT o.order_id, o.order_date, c.customer_name, SUM(od.quantity * od.unit_price) as order_total FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_details od ON o.order_id = od.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY o.order_id, o.order_date, c.customer_name HAVING SUM(od.quantity * od.unit_price) > 500.00 ORDER BY order_total DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT employee_id, first_name, last_name, email, phone, department, salary FROM employees WHERE salary BETWEEN 50000 AND 100000 AND department IN ('Sales', 'Marketing', 'Finance') AND hire_date > '2020-01-01' AND active = 1 ORDER BY salary DESC, last_name ASC, first_name ASC LIMIT 25","output":"SELECT employee_id, first_name, last_name, email, phone, department, salary FROM employees WHERE salary BETWEEN 50000 AND 100000 AND department IN ('Sales', 'Marketing', 'Finance') AND hire_date > '2020-01-01' AND active = 1 ORDER BY salary DESC, last_name ASC, first_name ASC LIMIT 25"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, c.category_name, p.price, p.stock_quantity FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50.00 AND p.stock_quantity > 10 AND c.category_name LIKE '%Home%' AND p.discontinued = FALSE ORDER BY p.price ASC, p.product_name ASC","output":"SELECT p.product_id, p.product_name, c.category_name, p.price, p.stock_quantity FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50.00 AND p.stock_quantity > 10 AND c.category_name LIKE '%Home%' AND p.discontinued = false ORDER BY p.price ASC, p.product_name ASC"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, customer_name, email, phone, address, city, state, zip_code FROM customers WHERE (city = 'New York' OR city = 'Los Angeles' OR city = 'Chicago') AND created_at >= '2022-01-01' AND email IS NOT NULL AND phone IS NOT NULL ORDER BY customer_name ASC","output":"SELECT customer_id, customer_name, email, phone, address, city, state, zip_code FROM customers WHERE city IN ('New York', 'Los Angeles', 'Chicago') AND created_at >= '2022-01-01' AND email IS NOT NULL AND phone IS NOT NULL ORDER BY customer_name ASC"}
{"instruction":"Optimize the SQL query","input":"SELECT order_id, customer_id, order_date, total_amount, status FROM orders WHERE status IN ('Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-03-31' AND total_amount > 100.00 ORDER BY order_date DESC, total_amount DESC","output":"SELECT order_id, customer_id, order_date, total_amount, status FROM orders WHERE status IN ('Shipped', 'Delivered') AND order_date BETWEEN '2023-01-01' AND '2023-03-31' AND total_amount > 100.00 ORDER BY order_date DESC, total_amount DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND date_updated IS NOT NULL AND date_updated <> NULL AND LENGTH(type) > 0 AND CHAR_LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > CAST('2023-02-01' AS TEXT) AND countries_id IS NOT NULL AND countries_id <> NULL AND EXTRACT(YEAR FROM created_at) = 2023 AND EXTRACT(MONTH FROM created_at) >= 2;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND LOWER(city) = 'chicago' AND city LIKE '%Chicago%';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND LENGTH(user_id) = 5 AND user_id LIKE '13579%';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND active IS NOT NULL AND active = 1;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE is_default = CAST(true AS BOOLEAN) AND forms_id IS NOT NULL AND forms_id <> NULL AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE is_default = true AND forms_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(user_id AS TEXT) = '65432' AND updated_at IS NOT NULL AND updated_at <> NULL AND user_id::text LIKE '65432%';","output":"SELECT * FROM event_actions WHERE user_id = '65432' AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(facility_id AS TEXT) = '54321' AND CAST(organization_id AS TEXT) = '87654' AND tools_id IS NOT NULL AND tools_id <> NULL AND facility_id::text = '54321' AND organization_id::text = '87654';","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = '54321' AND organization_id = '87654' AND tools_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE ((harmt IS NOT NULL AND harmt <> NULL) OR (prescribers_id IS NOT NULL AND prescribers_id <> NULL)) AND is_open = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND date_closed IS NOT NULL AND date_closed <> NULL;","output":"SELECT * FROM events WHERE (harmt IS NOT NULL OR prescribers_id IS NOT NULL) AND is_open = true AND date_created IS NOT NULL AND date_closed IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) > '2023-04-01' AND updated_at IS NOT NULL AND updated_at <> NULL AND is_active = 1;","output":"SELECT * FROM users WHERE is_active = true AND updated_at > '2023-04-01' AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE UPPER(city) = UPPER('Denver') AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND LOWER(city) = 'denver';","output":"SELECT * FROM organizations WHERE city = 'Denver' AND trial_ends_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) = UPPER('Pharmacist D') AND activate_at IS NOT NULL AND activate_at <> NULL AND activated_by ILIKE 'Pharmacist D';","output":"SELECT * FROM pharmacies WHERE activated_by = 'Pharmacist D' AND activate_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '97531' AND employee_id IS NOT NULL AND employee_id <> NULL AND user_id::text = '97531';","output":"SELECT * FROM staff_directory WHERE user_id = '97531' AND employee_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND serial_number <> '' AND LENGTH(serial_number) > 0 AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND serial_number <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(name) = UPPER('Chemical Spill') AND description <> '' AND LENGTH(description) > 0 AND name ILIKE 'Chemical Spill';","output":"SELECT * FROM hazards WHERE name = 'Chemical Spill' AND description <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND \"order\" IS NOT NULL AND \"order\" <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND \"order\" IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '321' AND action_date IS NOT NULL AND action_date <> NULL AND date_done IS NOT NULL AND date_done <> NULL AND events_id::text = '321';","output":"SELECT * FROM event_actions WHERE events_id = '321' AND action_date IS NOT NULL AND date_done IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '876' AND CAST(facility_id AS TEXT) = '543' AND updated_by IS NOT NULL AND updated_by <> NULL AND updated_at IS NOT NULL AND updated_at <> NULL;","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '876' AND facility_id = '543' AND updated_by IS NOT NULL AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '987' AND date_created IS NOT NULL AND date_created <> NULL AND updated_by IS NOT NULL AND updated_by <> NULL AND harmt IS NOT NULL AND harmt <> NULL;","output":"SELECT * FROM events WHERE reporters_id = '987' AND date_created IS NOT NULL AND updated_by IS NOT NULL AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND sf_id IS NOT NULL AND sf_id <> NULL AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND is_active = true AND date_created IS NOT NULL AND sf_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-02-01' AND countries_id IS NOT NULL AND countries_id <> NULL AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND name <> '' AND LENGTH(name) > 0;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL AND trial_ends_at IS NOT NULL AND name <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND activated_by IS NOT NULL AND activated_by <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL AND activated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND fixed = CAST(true AS BOOLEAN) AND user_id::text = '13579';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL AND fixed = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND asset_type_id IS NOT NULL AND asset_type_id <> NULL AND active = 1;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL AND asset_type_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id IS NOT NULL AND pharmacies_id <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL AND pharmacies_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE is_default = CAST(true AS BOOLEAN) AND forms_id IS NOT NULL AND forms_id <> NULL AND facility_id IS NOT NULL AND facility_id <> NULL AND is_default = 1;","output":"SELECT * FROM event_staff_roles WHERE is_default = true AND forms_id IS NOT NULL AND facility_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(user_id AS TEXT) = '65432' AND updated_at IS NOT NULL AND updated_at <> NULL AND user_pharmacy_id IS NOT NULL AND user_pharmacy_id <> NULL AND user_id::text = '65432';","output":"SELECT * FROM event_actions WHERE user_id = '65432' AND updated_at IS NOT NULL AND user_pharmacy_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(facility_id AS TEXT) = '54321' AND CAST(organization_id AS TEXT) = '87654' AND tools_id IS NOT NULL AND tools_id <> NULL AND updated_by IS NOT NULL AND updated_by <> NULL AND facility_id::text = '54321';","output":"SELECT * FROM formsettings_summarytools WHERE facility_id = '54321' AND organization_id = '87654' AND tools_id IS NOT NULL AND updated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE ((harmt IS NOT NULL AND harmt <> NULL) OR (prescribers_id IS NOT NULL AND prescribers_id <> NULL)) AND is_open = CAST(true AS BOOLEAN) AND date_created IS NOT NULL AND date_created <> NULL AND date_closed IS NOT NULL AND date_closed <> NULL;","output":"SELECT * FROM events WHERE (harmt IS NOT NULL OR prescribers_id IS NOT NULL) AND is_open = true AND date_created IS NOT NULL AND date_closed IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) > '2023-03-01' AND type IS NOT NULL AND type <> NULL AND date_updated IS NOT NULL AND date_updated <> NULL AND is_active = 1;","output":"SELECT * FROM users WHERE is_active = true AND updated_at > '2023-03-01' AND type IS NOT NULL AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE UPPER(city) = UPPER('Seattle') AND trial_ends_at IS NOT NULL AND trial_ends_at <> NULL AND countries_id IS NOT NULL AND countries_id <> NULL AND city ILIKE 'seattle';","output":"SELECT * FROM organizations WHERE city = 'Seattle' AND trial_ends_at IS NOT NULL AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) = UPPER('Pharmacist B') AND activate_at IS NOT NULL AND activate_at <> NULL AND activated_by ILIKE 'Pharmacist B';","output":"SELECT * FROM pharmacies WHERE activated_by = 'Pharmacist B' AND activate_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '98765' AND created_at IS NOT NULL AND created_at <> NULL AND user_id::text = '98765';","output":"SELECT * FROM staff_directory WHERE user_id = '98765' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(asset_type_id AS TEXT) = '789' AND serial_number IS NOT NULL AND serial_number <> NULL AND asset_type_id::text = '789';","output":"SELECT * FROM assets WHERE asset_type_id = '789' AND serial_number IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '65432' AND description <> '' AND LENGTH(description) > 0 AND pharmacies_id::text = '65432';","output":"SELECT * FROM hazards WHERE pharmacies_id = '65432' AND description <> '';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND \"order\" IS NOT NULL AND \"order\" <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND \"order\" IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '987' AND UPPER(updated_by) = UPPER('John Smith') AND events_id::text = '987' AND updated_by ILIKE 'John Smith';","output":"SELECT * FROM event_actions WHERE events_id = '987' AND updated_by = 'John Smith';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '543' AND UPPER(updated_by) = UPPER('Jane Doe') AND organization_id::text = '543' AND updated_by ILIKE 'Jane Doe';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '543' AND updated_by = 'Jane Doe';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '321' AND harmt IS NOT NULL AND harmt <> NULL AND reporters_id::text = '321';","output":"SELECT * FROM events WHERE reporters_id = '321' AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('Admin' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND LENGTH(type) = 5;","output":"SELECT * FROM users WHERE type = 'Admin' AND is_active = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-01-01' AND CAST(updated_at AS TEXT) < '2023-06-30' AND created_at IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-01-01' AND updated_at < '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Los Angeles') AND daye_enabled IS NOT NULL AND daye_enabled <> NULL AND city ILIKE 'los angeles';","output":"SELECT * FROM pharmacies WHERE city = 'Los Angeles' AND daye_enabled IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(full_name) = UPPER('Jane Doe') AND fixed = CAST(true AS BOOLEAN) AND full_name ILIKE 'Jane Doe';","output":"SELECT * FROM staff_directory WHERE full_name = 'Jane Doe' AND fixed = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND CAST(updated_at AS TEXT) >= '2023-01-01' AND CAST(updated_at AS TEXT) <= '2023-06-30' AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND updated_at BETWEEN '2023-01-01' AND '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(name) LIKE UPPER('Chemical%') AND name IS NOT NULL;","output":"SELECT * FROM hazards WHERE name LIKE 'Chemical%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '789' AND CAST(facility_id AS TEXT) = '654' AND forms_id::text = '789' AND facility_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '789' AND facility_id = '654';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '987' AND UPPER(updated_by) = UPPER('John Smith') AND events_id::text = '987';","output":"SELECT * FROM event_actions WHERE events_id = '987' AND updated_by = 'John Smith';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '543' AND UPPER(updated_by) = UPPER('Jane Doe') AND organization_id::text = '543';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '543' AND updated_by = 'Jane Doe';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '321' AND harmt IS NOT NULL AND harmt <> NULL AND reporters_id::text = '321';","output":"SELECT * FROM events WHERE reporters_id = '321' AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND is_active = CAST(true AS BOOLEAN) AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND is_active = true;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-01-01' AND CAST(updated_at AS TEXT) < '2023-06-30' AND created_at IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-01-01' AND updated_at < '2023-06-30';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE CAST(user_id AS TEXT) = '13579' AND official_user_id IS NOT NULL AND official_user_id <> NULL AND user_id::text = '13579';","output":"SELECT * FROM staff_directory WHERE user_id = '13579' AND official_user_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE active = CAST(true AS BOOLEAN) AND updated_at IS NOT NULL AND updated_at <> NULL AND active IS NOT NULL;","output":"SELECT * FROM assets WHERE active = true AND updated_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE CAST(pharmacies_id AS TEXT) = '43210' AND created_at IS NOT NULL AND created_at <> NULL AND pharmacies_id::text = '43210';","output":"SELECT * FROM hazards WHERE pharmacies_id = '43210' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE CAST(forms_id AS TEXT) = '654' AND updates_by IS NOT NULL AND updates_by <> NULL AND forms_id::text = '654';","output":"SELECT * FROM event_staff_roles WHERE forms_id = '654' AND updates_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE CAST(events_id AS TEXT) = '321' AND action_date IS NOT NULL AND action_date <> NULL AND events_id::text = '321';","output":"SELECT * FROM event_actions WHERE events_id = '321' AND action_date IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE CAST(organization_id AS TEXT) = '876' AND CAST(facility_id AS TEXT) = '543' AND updated_by IS NOT NULL AND updated_by <> NULL AND organization_id::text = '876';","output":"SELECT * FROM formsettings_summarytools WHERE organization_id = '876' AND facility_id = '543' AND updated_by IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(reporters_id AS TEXT) = '987' AND date_created IS NOT NULL AND date_created <> NULL AND reporters_id::text = '987';","output":"SELECT * FROM events WHERE reporters_id = '987' AND date_created IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(type AS VARCHAR(255)) = CAST('User' AS VARCHAR(255)) AND date_updated IS NOT NULL AND date_updated <> NULL AND LENGTH(type) = 4;","output":"SELECT * FROM users WHERE type = 'User' AND date_updated IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE CAST(created_at AS TEXT) > '2023-02-01' AND countries_id IS NOT NULL AND countries_id <> NULL AND created_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE created_at > '2023-02-01' AND countries_id IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(city) = UPPER('Chicago') AND created_at IS NOT NULL AND created_at <> NULL AND city ILIKE 'chicago';","output":"SELECT * FROM pharmacies WHERE city = 'Chicago' AND created_at IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(employee_id) LIKE UPPER('EMP-%') AND employee_id IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE employee_id LIKE 'EMP-%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(updated_at AS TEXT) > CAST((CURRENT_TIMESTAMP - INTERVAL '1 day') AS TEXT) AND updated_at IS NOT NULL;","output":"SELECT * FROM assets WHERE updated_at > (CURRENT_TIMESTAMP - INTERVAL '1 day');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies WHERE UPPER(name) LIKE UPPER('%Healthcare%') AND name IS NOT NULL);","output":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies WHERE name LIKE '%Healthcare%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE UPPER(name) LIKE UPPER('%Coordinator%') AND name IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE name LIKE '%Coordinator%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id IN (SELECT user_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE UPPER(role) = UPPER('Supervisor') AND role IS NOT NULL) AND user_id IS NOT NULL);","output":"SELECT * FROM event_actions WHERE user_id IN (SELECT user_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE role = 'Supervisor'));"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('S%') AND city IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'S%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE harmt IS NOT NULL AND harmt <> NULL AND reporters_id IN (SELECT users_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE UPPER(role) = UPPER('Admin') AND role IS NOT NULL) AND users_id IS NOT NULL);","output":"SELECT * FROM events WHERE harmt IS NOT NULL AND reporters_id IN (SELECT users_id FROM users WHERE profiles_id IN (SELECT profiles_id FROM profiles WHERE role = 'Admin'));"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE is_active = CAST(1 AS BOOLEAN) AND EXTRACT(DOW FROM updated_at) IN (1, 7) AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE is_active = 1 AND DAYOFWEEK(updated_at) IN (1, 7);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE sf_id IN (SELECT sf_id FROM organizations GROUP BY sf_id HAVING COUNT(DISTINCT countries_id) > 1 AND COUNT(DISTINCT countries_id) <> 0);","output":"SELECT * FROM organizations WHERE sf_id IN (SELECT sf_id FROM organizations GROUP BY sf_id HAVING COUNT(DISTINCT countries_id) > 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE UPPER(activated_by) LIKE UPPER('%Pharma%') AND organizations_id IN (SELECT organizations_id FROM organizations WHERE UPPER(address) LIKE UPPER('P%') AND address IS NOT NULL);","output":"SELECT * FROM pharmacies WHERE activated_by LIKE '%Pharma%' AND organizations_id IN (SELECT organizations_id FROM organizations WHERE address LIKE 'P%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE UPPER(full_name) LIKE UPPER('%John%') AND UPPER(full_name) LIKE UPPER('%Doe%') AND full_name IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE full_name LIKE '%John%' AND full_name LIKE '%Doe%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE asset_items_id IN (SELECT MAX(CAST(asset_items_id AS BIGINT)) FROM assets WHERE asset_items_id IS NOT NULL);","output":"SELECT * FROM assets WHERE asset_items_id IN (SELECT MAX(asset_items_id) FROM assets);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies GROUP BY pharmacies_id ORDER BY COUNT(*) DESC, pharmacies_id ASC LIMIT 1);","output":"SELECT * FROM hazards WHERE pharmacies_id IN (SELECT pharmacies_id FROM pharmacies GROUP BY pharmacies_id ORDER BY COUNT(*) DESC LIMIT 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE forms_id IN (SELECT forms_id FROM event_staff_roles GROUP BY forms_id ORDER BY COUNT(*) DESC, forms_id ASC);","output":"SELECT * FROM event_staff_roles WHERE forms_id IN (SELECT forms_id FROM event_staff_roles GROUP BY forms_id ORDER BY COUNT(*) DESC);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE EXTRACT(DOW FROM action_date) IN (5, 6) AND action_date IS NOT NULL;","output":"SELECT * FROM event_actions WHERE WEEKDAY(action_date) IN (5, 6);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE organization_id IN (SELECT organization_id FROM organizations WHERE UPPER(name) LIKE UPPER('%Institute%') AND name IS NOT NULL) AND facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('M%') AND city IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE organization_id IN (SELECT organization_id FROM organizations WHERE name LIKE '%Institute%') AND facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'M%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(harmt AS TEXT) = CAST(prescribers_id AS TEXT) AND harmt IS NOT NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE harmt = prescribers_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE CAST(date_created AS DATE) = CAST(updated_at AS DATE) AND date_created IS NOT NULL AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE DATE(date_created) = DATE(updated_at);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at IN (SELECT trial_ends_at FROM organizations GROUP BY trial_ends_at HAVING COUNT(*) > 1 AND COUNT(*) <> 0);","output":"SELECT * FROM organizations WHERE trial_ends_at IN (SELECT trial_ends_at FROM organizations GROUP BY trial_ends_at HAVING COUNT(*) > 1);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE activate_at = CAST('specific_date' AS TIMESTAMP) AND activated_by = SUBSTRING(name, 1, 2) AND name IS NOT NULL;","output":"SELECT * FROM pharmacies WHERE activate_at = 'specific_date' AND activated_by = SUBSTRING(name, 1, 2);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE employee_id = REVERSE(employee_id) AND employee_id IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE employee_id = REVERSE(employee_id);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE serial_number ~ '[0-9]{3}' AND serial_number IS NOT NULL;","output":"SELECT * FROM assets WHERE serial_number REGEXP '[0-9]{3}';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE (UPPER(description) LIKE UPPER('%color1%') OR UPPER(description) LIKE UPPER('%color2%') OR UPPER(description) LIKE UPPER('%color3%')) AND description IS NOT NULL;","output":"SELECT * FROM hazards WHERE description LIKE '%color1%' OR description LIKE '%color2%' OR description LIKE '%color3%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE \"order\" = forms_id AND \"order\" IS NOT NULL AND forms_id IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE order = forms_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE user_id = user_pharmacy_id AND user_id IS NOT NULL AND user_pharmacy_id IS NOT NULL;","output":"SELECT * FROM event_actions WHERE user_id = user_pharmacy_id;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MAX(updated_at) FROM formsettings_summarytools WHERE updated_at IS NOT NULL) UNION SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MIN(updated_at) FROM formsettings_summarytools WHERE updated_at IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MAX(updated_at) FROM formsettings_summarytools) UNION SELECT * FROM formsettings_summarytools WHERE updated_at IN (SELECT MIN(updated_at) FROM formsettings_summarytools);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE LENGTH(harmt) = LENGTH(prescribers_id) AND harmt IS NOT NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE LENGTH(harmt) = LENGTH(prescribers_id);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE updated_at >= (SELECT DATE_SUB(NOW(), INTERVAL '1 week')) GROUP BY user_id HAVING COUNT(DISTINCT DATE(updated_at)) >= 2 AND updated_at IS NOT NULL;","output":"SELECT * FROM users WHERE updated_at >= (SELECT DATE_SUB(NOW(), INTERVAL 1 WEEK)) GROUP BY user_id HAVING COUNT(DISTINCT DATE(updated_at)) >= 2;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM organizations WHERE trial_ends_at = DATE(created_at) AND trial_ends_at IS NOT NULL AND created_at IS NOT NULL;","output":"SELECT * FROM organizations WHERE trial_ends_at = DATE(created_at);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM pharmacies WHERE (SELECT COUNT(*) FROM pharmacies WHERE daye_enabled IS NOT NULL) > (SELECT COUNT(*) FROM pharmacies WHERE date_disabled IS NOT NULL);","output":"SELECT * FROM pharmacies WHERE (SELECT COUNT() FROM pharmacies WHERE daye_enabled IS NOT NULL) > (SELECT COUNT() FROM pharmacies WHERE date_disabled IS NOT NULL);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM staff_directory WHERE LENGTH(full_name) = (SELECT MAX(LENGTH(full_name)) FROM staff_directory WHERE full_name IS NOT NULL) AND full_name IS NOT NULL;","output":"SELECT * FROM staff_directory WHERE LENGTH(full_name) = (SELECT MAX(LENGTH(full_name)) FROM staff_directory);"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM assets WHERE CAST(updated_at AS TEXT) > CAST((CURRENT_TIMESTAMP - INTERVAL '1 day') AS TEXT) AND serial_number ~ '([A-Za-z0-9]{2})+' AND serial_number IS NOT NULL;","output":"SELECT * FROM assets WHERE updated_at > (CURRENT_TIMESTAMP - INTERVAL 1 DAY) AND serial_number REGEXP '([A-Za-z0-9]{2})+';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM hazards WHERE UPPER(description) LIKE UPPER('%industry_keyword%') AND description IS NOT NULL;","output":"SELECT * FROM hazards WHERE description LIKE '%industry_keyword%';"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_staff_roles WHERE UPPER(name) LIKE UPPER('%Lead%') ORDER BY \"order\" DESC AND name IS NOT NULL;","output":"SELECT * FROM event_staff_roles WHERE name LIKE '%Lead%' ORDER BY order DESC;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM event_actions WHERE EXTRACT(DOW FROM action_date) IN (5, 6) AND date_done IS NOT NULL AND date_done <> NULL AND action_date IS NOT NULL;","output":"SELECT * FROM event_actions WHERE WEEKDAY(action_date) IN (5, 6) AND date_done IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE UPPER(city) LIKE UPPER('M%') AND city IS NOT NULL) AND updated_by IN (SELECT name FROM organizations WHERE UPPER(name) LIKE UPPER('%Institute%') AND name IS NOT NULL);","output":"SELECT * FROM formsettings_summarytools WHERE facility_id IN (SELECT facility_id FROM facilities WHERE city LIKE 'M%') AND updated_by IN (SELECT name FROM organizations WHERE name LIKE '%Institute%');"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM events WHERE CAST(harmt AS TEXT) = CAST(prescribers_id AS TEXT) AND harmt IS NOT NULL AND harmt <> NULL AND prescribers_id IS NOT NULL;","output":"SELECT * FROM events WHERE harmt = prescribers_id AND harmt IS NOT NULL;"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(username) = UPPER('john_doe') AND LENGTH(password) >= 8 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND is_active = TRUE AND email_verified = TRUE AND last_login > '2023-01-01' AND profile_complete = TRUE AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = TRUE AND two_factor_enabled = TRUE AND last_password_change > '2023-06-01'","output":"SELECT * FROM users WHERE username = 'john_doe' AND LENGTH(password) >= 8 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL AND is_active = true AND email_verified = true AND last_login > '2023-01-01' AND profile_complete = true AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = true AND two_factor_enabled = true AND last_password_change > '2023-06-01'"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75 OFFSET 0","output":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = TRUE AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100 OFFSET 0","output":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = true AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(username) = UPPER('john_doe') AND LENGTH(password) >= 8 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND is_active = TRUE AND email_verified = TRUE AND last_login > '2023-01-01' AND profile_complete = TRUE AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = TRUE AND two_factor_enabled = TRUE AND last_password_change > '2023-06-01'","output":"SELECT * FROM users WHERE username = 'john_doe' AND LENGTH(password) >= 8 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL AND is_active = true AND email_verified = true AND last_login > '2023-01-01' AND profile_complete = true AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = true AND two_factor_enabled = true AND last_password_change > '2023-06-01'"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75 OFFSET 0","output":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = TRUE AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100 OFFSET 0","output":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = true AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60 OFFSET 0","output":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40"}
{"instruction":"Optimize the SQL query","input":"SELECT s.sale_id, s.sale_date, s.total_amount, s.payment_method, c.customer_name, c.membership_level, e.employee_name, st.store_name, st.location, p.product_name, p.category, sd.quantity, sd.unit_price, sd.discount_amount, prom.promotion_name, prom.discount_percentage, tax.tax_amount, tax.tax_rate, del.delivery_status, del.delivery_date FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id WHERE s.sale_date BETWEEN '2023-06-01' AND '2023-12-31' AND s.total_amount > 200.00 AND s.payment_method IN ('credit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum') AND e.position = 'sales_associate' AND st.location LIKE '%mall%' AND p.category = 'electronics' AND sd.quantity > 2 AND prom.discount_percentage > 10.00 AND tax.tax_rate BETWEEN 0.08 AND 0.15 AND del.delivery_status = 'delivered' AND del.delivery_date IS NOT NULL ORDER BY s.total_amount DESC, s.sale_date DESC LIMIT 80 OFFSET 0","output":"SELECT s.sale_id, s.sale_date, s.total_amount, s.payment_method, c.customer_name, c.membership_level, e.employee_name, st.store_name, st.location, p.product_name, p.category, sd.quantity, sd.unit_price, sd.discount_amount, prom.promotion_name, prom.discount_percentage, tax.tax_amount, tax.tax_rate, del.delivery_status, del.delivery_date FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id WHERE s.sale_date BETWEEN '2023-06-01' AND '2023-12-31' AND s.total_amount > 200.00 AND s.payment_method IN ('credit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum') AND e.position = 'sales_associate' AND st.location LIKE '%mall%' AND p.category = 'electronics' AND sd.quantity > 2 AND prom.discount_percentage > 10.00 AND tax.tax_rate BETWEEN 0.08 AND 0.15 AND del.delivery_status = 'delivered' AND del.delivery_date IS NOT NULL ORDER BY s.total_amount DESC, s.sale_date DESC LIMIT 80"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, wh.warehouse_name, wh.location, wh.capacity, s.supplier_name, s.contact_email, cat.category_name, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id WHERE inv.current_stock < inv.min_stock_level AND inv.unit_cost > 25.00 AND wh.capacity > 1000 AND s.rating >= 4.0 AND cat.category_name = 'raw_materials' AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-01-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND inv.total_value > 5000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC LIMIT 55 OFFSET 0","output":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, wh.warehouse_name, wh.location, wh.capacity, s.supplier_name, s.contact_email, cat.category_name, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id WHERE inv.current_stock < inv.min_stock_level AND inv.unit_cost > 25.00 AND wh.capacity > 1000 AND s.rating >= 4.0 AND cat.category_name = 'raw_materials' AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-01-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND inv.total_value > 5000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC LIMIT 55"}
{"instruction":"Optimize the SQL query","input":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.status, c.customer_name, c.credit_score, e.employee_name, br.branch_name, pt.payment_term, sch.due_date, sch.amount_due, sch.paid_amount, coll.collection_status, coll.collection_date, coll.collection_amount, risk.risk_level, risk.risk_description, doc.document_name, doc.document_status, ins.insurance_amount, ins.insurance_provider FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id WHERE loan.amount > 50000.00 AND loan.interest_rate < 8.00 AND loan.start_date > '2022-01-01' AND loan.status = 'active' AND c.credit_score > 700 AND br.branch_region = 'northeast' AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-09-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > 0 AND ins.insurance_provider IS NOT NULL ORDER BY loan.amount DESC, loan.start_date ASC LIMIT 70 OFFSET 0","output":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.status, c.customer_name, c.credit_score, e.employee_name, br.branch_name, pt.payment_term, sch.due_date, sch.amount_due, sch.paid_amount, coll.collection_status, coll.collection_date, coll.collection_amount, risk.risk_level, risk.risk_description, doc.document_name, doc.document_status, ins.insurance_amount, ins.insurance_provider FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id WHERE loan.amount > 50000.00 AND loan.interest_rate < 8.00 AND loan.start_date > '2022-01-01' AND loan.status = 'active' AND c.credit_score > 700 AND br.branch_region = 'northeast' AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-09-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > 0 AND ins.insurance_provider IS NOT NULL ORDER BY loan.amount DESC, loan.start_date ASC LIMIT 70"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(username) = UPPER('john_doe') AND LENGTH(password) >= 8 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND is_active = TRUE AND email_verified = TRUE AND last_login > '2023-01-01' AND profile_complete = TRUE AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = TRUE AND two_factor_enabled = TRUE AND last_password_change > '2023-06-01'","output":"SELECT * FROM users WHERE username = 'john_doe' AND LENGTH(password) >= 8 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL AND is_active = true AND email_verified = true AND last_login > '2023-01-01' AND profile_complete = true AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = true AND two_factor_enabled = true AND last_password_change > '2023-06-01'"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75 OFFSET 0","output":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = TRUE AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100 OFFSET 0","output":"SELECT c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id WHERE c.created_date > '2020-01-01' AND c.active = true AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum') AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2022-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, l.loyalty_tier, l.points_balance HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60 OFFSET 0","output":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40"}
{"instruction":"Optimize the SQL query","input":"SELECT * FROM users WHERE UPPER(username) = UPPER('john_doe') AND LENGTH(password) >= 8 AND created_at::text LIKE '2023-%' AND updated_at IS NOT NULL AND is_active = TRUE AND email_verified = TRUE AND last_login > '2023-01-01' AND profile_complete = TRUE AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = TRUE AND two_factor_enabled = TRUE AND last_password_change > '2023-06-01'","output":"SELECT * FROM users WHERE username = 'john_doe' AND LENGTH(password) >= 8 AND created_at >= '2023-01-01' AND created_at < '2024-01-01' AND updated_at IS NOT NULL AND is_active = true AND email_verified = true AND last_login > '2023-01-01' AND profile_complete = true AND account_type IN ('premium', 'enterprise') AND login_count > 10 AND failed_login_attempts = 0 AND date_of_birth BETWEEN '1980-01-01' AND '2000-12-31' AND country_code = 'US' AND timezone = 'America/New_York' AND subscription_status = 'active' AND marketing_emails = true AND two_factor_enabled = true AND last_password_change > '2023-06-01'"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, c.category_name, s.supplier_name, b.brand_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id WHERE p.price BETWEEN 50.00 AND 500.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.rating >= 4.5 AND p.weight < 5.0 AND p.dimensions LIKE '%cm%' AND p.warranty_period > 12 AND p.release_date > '2022-01-01' AND p.sku LIKE 'ELEC%' AND p.manufacturer_part_number IS NOT NULL ORDER BY p.price DESC, p.product_name ASC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, p.payment_method, p.payment_status, s.shipping_method, s.tracking_number, s.estimated_delivery FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 100.00 AND o.status IN ('completed', 'shipped') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority') AND s.estimated_delivery > CURRENT_DATE AND o.items_count > 1 AND o.discount_amount > 0 AND o.tax_amount > 0 ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75 OFFSET 0","output":"SELECT e.employee_id, e.first_name, e.last_name, e.email, e.phone, e.department, e.position, e.salary, e.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name FROM employees e LEFT JOIN employees m ON e.manager_id = m.employee_id JOIN departments d ON e.department_id = d.department_id JOIN locations l ON e.location_id = l.location_id JOIN employee_skills es ON e.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON e.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id WHERE e.salary BETWEEN 60000 AND 120000 AND e.hire_date > '2018-01-01' AND e.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND pa.start_date <= CURRENT_DATE AND (pa.end_date IS NULL OR pa.end_date > CURRENT_DATE) AND r.role_name IN ('Developer', 'Architect', 'Lead') AND e.performance_rating >= 3.5 AND e.vacation_days_used < 15 ORDER BY e.salary DESC, e.last_name ASC, e.first_name ASC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60 OFFSET 0","output":"SELECT i.invoice_id, i.invoice_date, i.due_date, i.total_amount, i.status, c.customer_name, c.tax_id, a.address_line1, a.address_line2, a.city, a.postal_code, co.country_name, p.payment_terms, p.discount_percentage, b.bank_name, b.account_number, t.tax_rate, t.tax_amount, d.discount_amount, i.notes, i.po_number FROM invoices i JOIN customers c ON i.customer_id = c.customer_id JOIN addresses a ON i.billing_address_id = a.address_id JOIN countries co ON a.country_id = co.country_id JOIN payment_terms p ON i.payment_terms_id = p.terms_id LEFT JOIN bank_accounts b ON i.bank_account_id = b.account_id JOIN tax_calculations t ON i.invoice_id = t.invoice_id LEFT JOIN discount_applications d ON i.invoice_id = d.invoice_id WHERE i.invoice_date BETWEEN '2023-01-01' AND '2023-12-31' AND i.total_amount > 500.00 AND i.status IN ('paid', 'partially_paid') AND c.customer_type = 'business' AND co.country_name = 'United States' AND p.net_days > 30 AND t.tax_rate > 0.05 AND (d.discount_amount > 0 OR i.discount_percentage > 0) AND i.due_date > CURRENT_DATE AND i.po_number IS NOT NULL AND i.notes LIKE '%urgent%' ORDER BY i.total_amount DESC, i.invoice_date DESC LIMIT 60"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.status, c.client_name, c.industry, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, t.team_name, r.risk_level, r.risk_description, de.deliverable_name, de.status AS deliverable_status, res.resource_name, res.resource_type, res.cost_rate, times.hours_worked, times.overtime_hours FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id WHERE p.start_date > '2022-01-01' AND p.budget > 100000.00 AND p.status IN ('in_progress', 'on_hold') AND c.industry IN ('Technology', 'Finance', 'Healthcare') AND d.department_name = 'R&D' AND t.team_size > 5 AND r.risk_level IN ('high', 'medium') AND de.status = 'completed' AND res.resource_type = 'human' AND res.cost_rate > 50.00 AND times.hours_worked > 40 AND times.entry_date > '2023-01-01' ORDER BY p.budget DESC, p.start_date ASC LIMIT 40"}
{"instruction":"Optimize the SQL query","input":"SELECT s.sale_id, s.sale_date, s.total_amount, s.payment_method, c.customer_name, c.membership_level, e.employee_name, st.store_name, st.location, p.product_name, p.category, sd.quantity, sd.unit_price, sd.discount_amount, prom.promotion_name, prom.discount_percentage, tax.tax_amount, tax.tax_rate, del.delivery_status, del.delivery_date FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id WHERE s.sale_date BETWEEN '2023-06-01' AND '2023-12-31' AND s.total_amount > 200.00 AND s.payment_method IN ('credit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum') AND e.position = 'sales_associate' AND st.location LIKE '%mall%' AND p.category = 'electronics' AND sd.quantity > 2 AND prom.discount_percentage > 10.00 AND tax.tax_rate BETWEEN 0.08 AND 0.15 AND del.delivery_status = 'delivered' AND del.delivery_date IS NOT NULL ORDER BY s.total_amount DESC, s.sale_date DESC LIMIT 80 OFFSET 0","output":"SELECT s.sale_id, s.sale_date, s.total_amount, s.payment_method, c.customer_name, c.membership_level, e.employee_name, st.store_name, st.location, p.product_name, p.category, sd.quantity, sd.unit_price, sd.discount_amount, prom.promotion_name, prom.discount_percentage, tax.tax_amount, tax.tax_rate, del.delivery_status, del.delery_date FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id WHERE s.sale_date BETWEEN '2023-06-01' AND '2023-12-31' AND s.total_amount > 200.00 AND s.payment_method IN ('credit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum') AND e.position = 'sales_associate' AND st.location LIKE '%mall%' AND p.category = 'electronics' AND sd.quantity > 2 AND prom.discount_percentage > 10.00 AND tax.tax_rate BETWEEN 0.08 AND 0.15 AND del.delivery_status = 'delivered' AND del.delivery_date IS NOT NULL ORDER BY s.total_amount DESC, s.sale_date DESC LIMIT 80"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, wh.warehouse_name, wh.location, wh.capacity, s.supplier_name, s.contact_email, cat.category_name, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id WHERE inv.current_stock < inv.min_stock_level AND inv.unit_cost > 25.00 AND wh.capacity > 1000 AND s.rating >= 4.0 AND cat.category_name = 'raw_materials' AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-01-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND inv.total_value > 5000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC LIMIT 55 OFFSET 0","output":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, wh.warehouse_name, wh.location, wh.capacity, s.supplier_name, s.contact_email, cat.category_name, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id WHERE inv.current_stock < inv.min_stock_level AND inv.unit_cost > 25.00 AND wh.capacity > 1000 AND s.rating >= 4.0 AND cat.category_name = 'raw_materials' AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-01-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND inv.total_value > 5000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC LIMIT 55"}
{"instruction":"Optimize the SQL query","input":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.status, c.customer_name, c.credit_score, e.employee_name, br.branch_name, pt.payment_term, sch.due_date, sch.amount_due, sch.paid_amount, coll.collection_status, coll.collection_date, coll.collection_amount, risk.risk_level, risk.risk_description, doc.document_name, doc.document_status, ins.insurance_amount, ins.insurance_provider FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id WHERE loan.amount > 50000.00 AND loan.interest_rate < 8.00 AND loan.start_date > '2022-01-01' AND loan.status = 'active' AND c.credit_score > 700 AND br.branch_region = 'northeast' AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-09-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > 0 AND ins.insurance_provider IS NOT NULL ORDER BY loan.amount DESC, loan.start_date ASC LIMIT 70 OFFSET 0","output":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.status, c.customer_name, c.credit_score, e.employee_name, br.branch_name, pt.payment_term, sch.due_date, sch.amount_due, sch.paid_amount, coll.collection_status, coll.collection_date, coll.collection_amount, risk.risk_level, risk.risk_description, doc.document_name, doc.document_status, ins.insurance_amount, ins.insurance_provider FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id WHERE loan.amount > 50000.00 AND loan.interest_rate < 8.00 AND loan.start_date > '2022-01-01' AND loan.status = 'active' AND c.credit_score > 700 AND br.branch_region = 'northeast' AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-09-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > 0 AND ins.insurance_provider IS NOT NULL ORDER BY loan.amount DESC, loan.start_date ASC LIMIT 70"}
{"instruction":"Optimize the SQL query","input":"SELECT emp.employee_id, emp.first_name, emp.last_name, emp.email, emp.department, emp.salary, emp.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name, t.team_name, per.performance_rating, per.review_date, sal.salary_amount, sal.effective_date, ben.benefit_type, ben.coverage_amount, att.attendance_date, att.hours_worked, att.overtime_hours, vac.vacation_days_used, vac.vacation_days_remaining FROM employees emp LEFT JOIN employees m ON emp.manager_id = m.employee_id JOIN departments d ON emp.department_id = d.department_id JOIN locations l ON emp.location_id = l.location_id JOIN employee_skills es ON emp.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON emp.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id JOIN teams t ON emp.team_id = t.team_id JOIN performance_reviews per ON emp.employee_id = per.employee_id JOIN salary_history sal ON emp.employee_id = sal.employee_id JOIN benefits ben ON emp.employee_id = ben.employee_id JOIN attendance_records att ON emp.employee_id = att.employee_id JOIN vacation_balances vac ON emp.employee_id = vac.employee_id WHERE emp.salary BETWEEN 70000 AND 150000 AND emp.hire_date > '2017-01-01' AND emp.active = TRUE AND d.department_name IN ('Engineering', 'Data Science', 'Product Management') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND r.role_name IN ('Senior Developer', 'Architect', 'Team Lead') AND t.team_size > 8 AND per.performance_rating >= 4.0 AND sal.salary_amount > 75000 AND ben.coverage_amount > 100000 AND att.hours_worked > 160 AND vac.vacation_days_remaining > 5 ORDER BY emp.salary DESC, per.performance_rating DESC LIMIT 50 OFFSET 0","output":"SELECT emp.employee_id, emp.first_name, emp.last_name, emp.email, emp.department, emp.salary, emp.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name, d.department_name, l.city, l.country, s.skill_name, p.project_name, r.role_name, t.team_name, per.performance_rating, per.review_date, sal.salary_amount, sal.effective_date, ben.benefit_type, ben.coverage_amount, att.attendance_date, att.hours_worked, att.overtime_hours, vac.vacation_days_used, vac.vacation_days_remaining FROM employees emp LEFT JOIN employees m ON emp.manager_id = m.employee_id JOIN departments d ON emp.department_id = d.department_id JOIN locations l ON emp.location_id = l.location_id JOIN employee_skills es ON emp.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON emp.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id JOIN teams t ON emp.team_id = t.team_id JOIN performance_reviews per ON emp.employee_id = per.employee_id JOIN salary_history sal ON emp.employee_id = sal.employee_id JOIN benefits ben ON emp.employee_id = ben.employee_id JOIN attendance_records att ON emp.employee_id = att.employee_id JOIN vacation_balances vac ON emp.employee_id = vac.employee_id WHERE emp.salary BETWEEN 70000 AND 150000 AND emp.hire_date > '2017-01-01' AND emp.active = true AND d.department_name IN ('Engineering', 'Data Science', 'Product Management') AND l.country = 'USA' AND s.skill_level >= 4 AND p.status = 'active' AND r.role_name IN ('Senior Developer', 'Architect', 'Team Lead') AND t.team_size > 8 AND per.performance_rating >= 4.0 AND sal.salary_amount > 75000 AND ben.coverage_amount > 100000 AND att.hours_worked > 160 AND vac.vacation_days_remaining > 5 ORDER BY emp.salary DESC, per.performance_rating DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, c.email, c.phone, c.membership_level, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, s.renewal_date, l.loyalty_tier, l.points_balance, l.reward_status, com.communication_type, com.communication_date, com.communication_status, fed.feedback_rating, fed.feedback_date, fed.feedback_comment, sup.support_ticket_id, sup.issue_type, sup.status AS support_status, pay.payment_method, pay.default_payment FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id LEFT JOIN customer_communications com ON c.customer_id = com.customer_id LEFT JOIN customer_feedback fed ON c.customer_id = fed.customer_id LEFT JOIN support_tickets sup ON c.customer_id = sup.customer_id LEFT JOIN payment_methods pay ON c.customer_id = pay.customer_id WHERE c.created_date > '2019-01-01' AND c.active = TRUE AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum', 'diamond') AND com.communication_status = 'delivered' AND fed.feedback_rating >= 4 AND sup.status = 'resolved' AND pay.default_payment = TRUE AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2021-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, c.membership_level, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, s.renewal_date, l.loyalty_tier, l.points_balance, l.reward_status, com.communication_type, com.communication_date, com.communication_status, fed.feedback_rating, fed.feedback_date, fed.feedback_comment, sup.support_ticket_id, sup.issue_type, sup.status, pay.payment_method, pay.default_payment HAVING COUNT(o.order_id) > 10 AND SUM(o.total_amount) > 5000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 75 OFFSET 0","output":"SELECT c.customer_id, c.customer_name, c.email, c.phone, c.membership_level, a.street, a.city, a.state, a.zip_code, a.country, COUNT(o.order_id) AS total_orders, SUM(o.total_amount) AS lifetime_value, AVG(o.total_amount) AS avg_order_value, MAX(o.order_date) AS last_order_date, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, s.renewal_date, l.loyalty_tier, l.points_balance, l.reward_status, com.communication_type, com.communication_date, com.communication_status, fed.feedback_rating, fed.feedback_date, fed.feedback_comment, sup.support_ticket_id, sup.issue_type, sup.status AS support_status, pay.payment_method, pay.default_payment FROM customers c JOIN addresses a ON c.primary_address_id = a.address_id LEFT JOIN orders o ON c.customer_id = o.customer_id LEFT JOIN customer_preferences p ON c.customer_id = p.customer_id LEFT JOIN subscriptions s ON c.customer_id = s.customer_id LEFT JOIN loyalty_programs l ON c.customer_id = l.customer_id LEFT JOIN customer_communications com ON c.customer_id = com.customer_id LEFT JOIN customer_feedback fed ON c.customer_id = fed.customer_id LEFT JOIN support_tickets sup ON c.customer_id = sup.customer_id LEFT JOIN payment_methods pay ON c.customer_id = pay.customer_id WHERE c.created_date > '2019-01-01' AND c.active = true AND a.country = 'USA' AND o.status = 'completed' AND p.preference_category = 'product_category' AND s.subscription_status = 'active' AND l.loyalty_tier IN ('gold', 'platinum', 'diamond') AND com.communication_status = 'delivered' AND fed.feedback_rating >= 4 AND sup.status = 'resolved' AND pay.default_payment = true AND c.email IS NOT NULL AND c.phone IS NOT NULL AND o.total_amount > 0 AND o.order_date > '2021-01-01' GROUP BY c.customer_id, c.customer_name, c.email, c.phone, c.membership_level, a.street, a.city, a.state, a.zip_code, a.country, p.preference_category, p.preference_value, s.subscription_type, s.subscription_status, s.renewal_date, l.loyalty_tier, l.points_balance, l.reward_status, com.communication_type, com.communication_date, com.communication_status, fed.feedback_rating, fed.feedback_date, fed.feedback_comment, sup.support_ticket_id, sup.issue_type, sup.status, pay.payment_method, pay.default_payment HAVING COUNT(o.order_id) > 10 AND SUM(o.total_amount) > 5000.00 ORDER BY lifetime_value DESC, total_orders DESC LIMIT 75"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.sku, p.upc, p.weight, p.dimensions, p.warranty_period, p.release_date, p.discontinued, c.category_name, c.category_description, s.supplier_name, s.contact_name, s.contact_email, s.phone, s.country, b.brand_name, b.brand_website, inv.warehouse_name, inv.location, inv.current_stock, inv.min_stock_level, inv.max_stock_level, rev.review_rating, rev.review_count, rev.average_rating, sale.sale_price, sale.sale_start_date, sale.sale_end_date, img.image_url, img.image_type, doc.document_name, doc.document_type, rel.related_product_id, rel.relation_type FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id JOIN inventory_levels inv ON p.product_id = inv.product_id LEFT JOIN product_reviews rev ON p.product_id = rev.product_id LEFT JOIN product_sales sale ON p.product_id = sale.product_id LEFT JOIN product_images img ON p.product_id = img.product_id LEFT JOIN product_documents doc ON p.product_id = doc.product_id LEFT JOIN product_relationships rel ON p.product_id = rel.product_id WHERE p.price BETWEEN 25.00 AND 1000.00 AND p.stock_quantity > 0 AND p.discontinued = FALSE AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.brand_rating >= 4.0 AND inv.current_stock > inv.min_stock_level AND rev.review_rating >= 4.5 AND sale.sale_price IS NOT NULL AND img.image_type = 'main' AND doc.document_type = 'manual' AND rel.relation_type = 'accessory' AND p.weight < 10.0 AND p.warranty_period > 12 AND p.release_date > '2021-01-01' ORDER BY p.price DESC, rev.average_rating DESC LIMIT 60 OFFSET 0","output":"SELECT p.product_id, p.product_name, p.description, p.price, p.stock_quantity, p.sku, p.upc, p.weight, p.dimensions, p.warranty_period, p.release_date, p.discontinued, c.category_name, c.category_description, s.supplier_name, s.contact_name, s.contact_email, s.phone, s.country, b.brand_name, b.brand_website, inv.warehouse_name, inv.location, inv.current_stock, inv.min_stock_level, inv.max_stock_level, rev.review_rating, rev.review_count, rev.average_rating, sale.sale_price, sale.sale_start_date, sale.sale_end_date, img.image_url, img.image_type, doc.document_name, doc.document_type, rel.related_product_id, rel.relation_type FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id JOIN brands b ON p.brand_id = b.brand_id JOIN inventory_levels inv ON p.product_id = inv.product_id LEFT JOIN product_reviews rev ON p.product_id = rev.product_id LEFT JOIN product_sales sale ON p.product_id = sale.product_id LEFT JOIN product_images img ON p.product_id = img.product_id LEFT JOIN product_documents doc ON p.product_id = doc.product_id LEFT JOIN product_relationships rel ON p.product_id = rel.product_id WHERE p.price BETWEEN 25.00 AND 1000.00 AND p.stock_quantity > 0 AND p.discontinued = false AND c.category_name ILIKE '%electronics%' AND s.country = 'USA' AND b.brand_rating >= 4.0 AND inv.current_stock > inv.min_stock_level AND rev.review_rating >= 4.5 AND sale.sale_price IS NOT NULL AND img.image_type = 'main' AND doc.document_type = 'manual' AND rel.relation_type = 'accessory' AND p.weight < 10.0 AND p.warranty_period > 12 AND p.release_date > '2021-01-01' ORDER BY p.price DESC, rev.average_rating DESC LIMIT 60"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT u.user_id, u.username, u.email FROM users u WHERE u.user_id NOT IN (SELECT ul.user_id FROM user_logins ul WHERE ul.login_date > CURDATE() - INTERVAL 3 MONTH AND ul.login_type = 'mobile') AND u.created_at BETWEEN '2022-01-01' AND '2022-12-31' AND EXISTS (SELECT 1 FROM user_profiles up WHERE up.user_id = u.user_id AND up.preference = 'newsletter') AND u.status = 'active' ORDER BY u.username LIMIT 50 OFFSET 10;","output":"SELECT u.user_id, u.username, u.email FROM users AS u LEFT JOIN user_logins AS ul ON u.user_id = ul.user_id AND ul.login_date > CURDATE() - INTERVAL 3 MONTH AND ul.login_type = 'mobile' JOIN user_profiles AS up ON u.user_id = up.user_id WHERE u.created_at BETWEEN '2022-01-01' AND '2022-12-31' AND up.preference = 'newsletter' AND u.status = 'active' AND ul.user_id IS NULL ORDER BY u.username LIMIT 50 OFFSET 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_name, SUM(o.total_amount) AS total_spent, COUNT(o.order_id) AS total_orders FROM customers c LEFT JOIN orders o ON c.customer_id = o.customer_id WHERE c.registration_date > '2021-01-01' AND o.order_date > '2022-01-01' AND o.total_amount IS NOT NULL AND c.customer_id IN (SELECT DISTINCT customer_id FROM loyalty_programs WHERE level = 'Gold') GROUP BY c.customer_name HAVING SUM(o.total_amount) > 1000 AND COUNT(o.order_id) >= 5 ORDER BY total_spent DESC LIMIT 20;","output":"SELECT c.customer_name, SUM(o.total_amount) AS total_spent, COUNT(o.order_id) AS total_orders FROM customers AS c LEFT JOIN orders AS o ON c.customer_id = o.customer_id JOIN loyalty_programs AS lp ON c.customer_id = lp.customer_id WHERE c.registration_date > '2021-01-01' AND o.order_date > '2022-01-01' AND o.total_amount IS NOT NULL AND lp.level = 'Gold' GROUP BY c.customer_name HAVING SUM(o.total_amount) > 1000 AND COUNT(o.order_id) >= 5 ORDER BY total_spent DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_name, p.price, (SELECT AVG(price) FROM products WHERE category_id = p.category_id) AS avg_category_price, (SELECT COUNT(DISTINCT customer_id) FROM order_items oi JOIN orders o ON oi.order_id = o.order_id WHERE oi.product_id = p.product_id AND o.order_date BETWEEN '2023-01-01' AND '2023-06-30') AS unique_buyers FROM products p WHERE p.category_id IN (SELECT category_id FROM categories WHERE category_name LIKE '%Electronic%') AND p.stock_quantity < 100 AND p.price > 500 ORDER BY unique_buyers DESC, p.price DESC LIMIT 15;","output":"WITH CategoryAvgPrice AS (SELECT category_id, AVG(price) AS avg_category_price FROM products GROUP BY category_id), UniqueBuyers AS (SELECT oi.product_id, COUNT(DISTINCT o.customer_id) AS unique_buyers FROM order_items AS oi JOIN orders AS o ON oi.order_id = o.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY oi.product_id) SELECT p.product_name, p.price, cap.avg_category_price, ub.unique_buyers FROM products AS p JOIN categories AS c ON p.category_id = c.category_id LEFT JOIN CategoryAvgPrice AS cap ON p.category_id = cap.category_id LEFT JOIN UniqueBuyers AS ub ON p.product_id = ub.product_id WHERE c.category_name LIKE '%Electronic%' AND p.stock_quantity < 100 AND p.price > 500 ORDER BY ub.unique_buyers DESC, p.price DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, d.department_name, (SELECT COUNT(*) FROM employee_projects ep WHERE ep.employee_id = e.employee_id) AS projects_count, (SELECT AVG(feedback_score) FROM project_feedback pf WHERE pf.project_id IN (SELECT project_id FROM employee_projects WHERE employee_id = e.employee_id)) AS avg_feedback FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE e.hire_date < '2020-01-01' AND e.salary > 70000 AND d.location = 'Headquarters' AND EXISTS (SELECT 1 FROM performance_reviews pr WHERE pr.employee_id = e.employee_id AND pr.review_date > '2023-01-01' AND pr.rating >= 4) ORDER BY projects_count DESC, avg_feedback DESC LIMIT 10;","output":"WITH EmployeeProjectsCount AS (SELECT employee_id, COUNT(*) AS projects_count FROM employee_projects GROUP BY employee_id), ProjectFeedbackAvg AS (SELECT ep.employee_id, AVG(pf.feedback_score) AS avg_feedback FROM employee_projects AS ep JOIN project_feedback AS pf ON ep.project_id = pf.project_id GROUP BY ep.employee_id) SELECT e.employee_id, e.first_name, e.last_name, d.department_name, epc.projects_count, pfa.avg_feedback FROM employees AS e JOIN departments AS d ON e.department_id = d.department_id LEFT JOIN EmployeeProjectsCount AS epc ON e.employee_id = epc.employee_id LEFT JOIN ProjectFeedbackAvg AS pfa ON e.employee_id = pfa.employee_id JOIN performance_reviews AS pr ON e.employee_id = pr.employee_id WHERE e.hire_date < '2020-01-01' AND e.salary > 70000 AND d.location = 'Headquarters' AND pr.review_date > '2023-01-01' AND pr.rating >= 4 ORDER BY epc.projects_count DESC, pfa.avg_feedback DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.student_name, s.student_email, c.course_name FROM students s JOIN enrollments en ON s.student_id = en.student_id JOIN courses c ON en.course_id = c.course_id WHERE s.graduation_year = 2025 AND s.major = 'Computer Science' AND c.course_credits > 3 AND c.course_id NOT IN (SELECT assignment_id FROM assignments WHERE grade < 60) AND EXISTS (SELECT 1 FROM student_awards sa WHERE sa.student_id = s.student_id AND sa.award_year = 2023) ORDER BY s.student_name ASC LIMIT 25;","output":"SELECT s.student_name, s.student_email, c.course_name FROM students AS s JOIN enrollments AS en ON s.student_id = en.student_id JOIN courses AS c ON en.course_id = c.course_id LEFT JOIN assignments AS a ON c.course_id = a.assignment_id AND a.grade < 60 JOIN student_awards AS sa ON s.student_id = sa.student_id WHERE s.graduation_year = 2025 AND s.major = 'Computer Science' AND c.course_credits > 3 AND a.assignment_id IS NULL AND sa.award_year = 2023 ORDER BY s.student_name ASC LIMIT 25;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.artist_name, COUNT(t.track_id) AS total_tracks, SUM(t.duration) AS total_duration FROM artists a LEFT JOIN albums al ON a.artist_id = al.artist_id LEFT JOIN tracks t ON al.album_id = t.album_id WHERE a.country = 'USA' AND al.release_year BETWEEN 2010 AND 2020 AND t.genre = 'Rock' AND a.artist_id NOT IN (SELECT artist_id FROM artist_awards WHERE award_year = 2023) GROUP BY a.artist_name HAVING COUNT(t.track_id) > 100 AND SUM(t.duration) > 3600 ORDER BY total_tracks DESC LIMIT 10;","output":"SELECT a.artist_name, COUNT(t.track_id) AS total_tracks, SUM(t.duration) AS total_duration FROM artists AS a LEFT JOIN albums AS al ON a.artist_id = al.artist_id LEFT JOIN tracks AS t ON al.album_id = t.album_id LEFT JOIN artist_awards AS aa ON a.artist_id = aa.artist_id AND aa.award_year = 2023 WHERE a.country = 'USA' AND al.release_year BETWEEN 2010 AND 2020 AND t.genre = 'Rock' AND aa.artist_id IS NULL GROUP BY a.artist_name HAVING COUNT(t.track_id) > 100 AND SUM(t.duration) > 3600 ORDER BY total_tracks DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, c.customer_name, p.product_name, oi.quantity FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE c.country = 'France' AND p.category_id IN (SELECT category_id FROM categories WHERE category_description LIKE '%Electronics%') AND o.order_date BETWEEN '2023-01-01' AND '2023-03-31' AND oi.price * oi.quantity > 500 ORDER BY o.order_date ASC, c.customer_name ASC LIMIT 50;","output":"SELECT o.order_id, c.customer_name, p.product_name, oi.quantity FROM orders AS o JOIN customers AS c ON o.customer_id = c.customer_id JOIN order_items AS oi ON o.order_id = oi.order_id JOIN products AS p ON oi.product_id = p.product_id JOIN categories AS cat ON p.category_id = cat.category_id WHERE c.country = 'France' AND cat.category_description LIKE '%Electronics%' AND o.order_date BETWEEN '2023-01-01' AND '2023-03-31' AND oi.price * oi.quantity > 500 ORDER BY o.order_date ASC, c.customer_name ASC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT t.ticket_id, t.subject, u.username AS reporter_name, a.username AS assignee_name FROM tickets t JOIN users u ON t.reporter_id = u.user_id LEFT JOIN users a ON t.assignee_id = a.user_id WHERE t.status = 'Open' AND t.priority IN ('High', 'Critical') AND t.created_at > CURDATE() - INTERVAL 7 DAY AND t.ticket_id NOT IN (SELECT comment_ticket_id FROM ticket_comments WHERE comment_date > CURDATE() - INTERVAL 1 DAY) ORDER BY t.priority DESC, t.created_at ASC LIMIT 20;","output":"SELECT t.ticket_id, t.subject, u.username AS reporter_name, a.username AS assignee_name FROM tickets AS t JOIN users AS u ON t.reporter_id = u.user_id LEFT JOIN users AS a ON t.assignee_id = a.user_id LEFT JOIN ticket_comments AS tc ON t.ticket_id = tc.comment_ticket_id AND tc.comment_date > CURDATE() - INTERVAL 1 DAY WHERE t.status = 'Open' AND t.priority IN ('High', 'Critical') AND t.created_at > CURDATE() - INTERVAL 7 DAY AND tc.comment_ticket_id IS NULL ORDER BY t.priority DESC, t.created_at ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT b.book_title, b.isbn, au.author_name FROM books b JOIN authors au ON b.author_id = au.author_id WHERE b.publication_year BETWEEN 2010 AND 2015 AND au.country = 'USA' AND EXISTS (SELECT 1 FROM book_reviews br WHERE br.book_id = b.book_id AND br.rating >= 4 AND br.review_date > '2023-01-01') AND b.genre IN ('Fiction', 'Science Fiction') ORDER BY b.publication_year DESC, b.book_title ASC LIMIT 30;","output":"SELECT b.book_title, b.isbn, au.author_name FROM books AS b JOIN authors AS au ON b.author_id = au.author_id JOIN book_reviews AS br ON b.book_id = br.book_id WHERE b.publication_year BETWEEN 2010 AND 2015 AND au.country = 'USA' AND br.rating >= 4 AND br.review_date > '2023-01-01' AND b.genre IN ('Fiction', 'Science Fiction') ORDER BY b.publication_year DESC, b.book_title ASC LIMIT 30;"}
{"instruction":"Optimize the SQL query","input":"SELECT s.store_name, s.city, SUM(t.sale_amount) AS total_sales, COUNT(t.transaction_id) AS total_transactions FROM stores s LEFT JOIN transactions t ON s.store_id = t.store_id WHERE s.region = 'East' AND t.transaction_date BETWEEN '2023-01-01' AND '2023-06-30' AND t.payment_method = 'Credit Card' AND s.store_id IN (SELECT store_id FROM store_employees WHERE employee_count > 50) GROUP BY s.store_name, s.city HAVING SUM(t.sale_amount) > 100000 AND COUNT(t.transaction_id) > 1000 ORDER BY total_sales DESC LIMIT 10;","output":"SELECT s.store_name, s.city, SUM(t.sale_amount) AS total_sales, COUNT(t.transaction_id) AS total_transactions FROM stores AS s LEFT JOIN transactions AS t ON s.store_id = t.store_id JOIN store_employees AS se ON s.store_id = se.store_id WHERE s.region = 'East' AND t.transaction_date BETWEEN '2023-01-01' AND '2023-06-30' AND t.payment_method = 'Credit Card' AND se.employee_count > 50 GROUP BY s.store_name, s.city HAVING SUM(t.sale_amount) > 100000 AND COUNT(t.transaction_id) > 1000 ORDER BY total_sales DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.company_name, c.industry, (SELECT COUNT(DISTINCT p.project_id) FROM projects p WHERE p.client_id = c.company_id AND p.status = 'Completed' AND p.end_date > '2022-01-01') AS completed_projects, (SELECT AVG(pr.rating) FROM project_reviews pr JOIN projects p ON pr.project_id = p.project_id WHERE p.client_id = c.company_id) AS avg_client_rating FROM companies c WHERE c.company_size > 100 AND c.industry IN ('Technology', 'Finance') AND EXISTS (SELECT 1 FROM company_partners cp WHERE cp.company_id = c.company_id AND cp.partnership_type = 'Strategic') ORDER BY completed_projects DESC, avg_client_rating DESC LIMIT 10;","output":"WITH CompletedProjects AS (SELECT p.client_id, COUNT(DISTINCT p.project_id) AS completed_projects FROM projects AS p WHERE p.status = 'Completed' AND p.end_date > '2022-01-01' GROUP BY p.client_id), AvgClientRating AS (SELECT p.client_id, AVG(pr.rating) AS avg_client_rating FROM project_reviews AS pr JOIN projects AS p ON pr.project_id = p.project_id GROUP BY p.client_id) SELECT c.company_name, c.industry, cp.completed_projects, acr.avg_client_rating FROM companies AS c LEFT JOIN CompletedProjects AS cp ON c.company_id = cp.client_id LEFT JOIN AvgClientRating AS acr ON c.company_id = acr.client_id JOIN company_partners AS cmp ON c.company_id = cmp.company_id WHERE c.company_size > 100 AND c.industry IN ('Technology', 'Finance') AND cmp.partnership_type = 'Strategic' ORDER BY completed_projects DESC, avg_client_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.username, u.registration_date FROM users u WHERE u.registration_date BETWEEN '2022-01-01' AND '2022-12-31' AND u.user_id NOT IN (SELECT DISTINCT a.user_id FROM user_activity a WHERE a.activity_type = 'post_created' AND a.activity_date > '2023-01-01') AND EXISTS (SELECT 1 FROM user_roles ur JOIN roles r ON ur.role_id = r.role_id WHERE ur.user_id = u.user_id AND r.role_name = 'Admin') ORDER BY u.registration_date DESC LIMIT 50;","output":"SELECT u.username, u.registration_date FROM users AS u LEFT JOIN user_activity AS a ON u.user_id = a.user_id AND a.activity_type = 'post_created' AND a.activity_date > '2023-01-01' JOIN user_roles AS ur ON u.user_id = ur.user_id JOIN roles AS r ON ur.role_id = r.role_id WHERE u.registration_date BETWEEN '2022-01-01' AND '2022-12-31' AND a.user_id IS NULL AND r.role_name = 'Admin' ORDER BY u.registration_date DESC LIMIT 50;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_name, c.category_name, s.supplier_name FROM products p JOIN categories c ON p.category_id = c.category_id JOIN suppliers s ON p.supplier_id = s.supplier_id WHERE p.price > 100 AND c.category_name NOT LIKE '%Food%' AND s.supplier_id IN (SELECT supplier_id FROM supplier_contracts WHERE contract_end_date > CURDATE()) AND p.stock_quantity < 500 ORDER BY p.price DESC, p.product_name ASC LIMIT 100;","output":"SELECT p.product_name, c.category_name, s.supplier_name FROM products AS p JOIN categories AS c ON p.category_id = c.category_id JOIN suppliers AS s ON p.supplier_id = s.supplier_id JOIN supplier_contracts AS sc ON s.supplier_id = sc.supplier_id WHERE p.price > 100 AND c.category_name NOT LIKE '%Food%' AND sc.contract_end_date > CURDATE() AND p.stock_quantity < 500 ORDER BY p.price DESC, p.product_name ASC LIMIT 100;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, c.customer_name FROM orders o JOIN customers c ON o.customer_id = c.customer_id WHERE o.order_date >= '2023-01-01' AND c.customer_id NOT IN (SELECT customer_id FROM customer_payments WHERE payment_status = 'Failed' AND payment_date > '2023-01-01') AND EXISTS (SELECT 1 FROM order_items oi WHERE oi.order_id = o.order_id AND oi.product_id IN (SELECT product_id FROM products WHERE product_type = 'Digital')) ORDER BY o.order_date DESC LIMIT 20;","output":"SELECT o.order_id, o.order_date, c.customer_name FROM orders AS o JOIN customers AS c ON o.customer_id = c.customer_id LEFT JOIN customer_payments AS cp ON c.customer_id = cp.customer_id AND cp.payment_status = 'Failed' AND cp.payment_date > '2023-01-01' JOIN order_items AS oi ON o.order_id = oi.order_id JOIN products AS p ON oi.product_id = p.product_id WHERE o.order_date >= '2023-01-01' AND cp.customer_id IS NULL AND p.product_type = 'Digital' ORDER BY o.order_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT e.employee_id, e.first_name, e.last_name FROM employees e WHERE e.department_id IN (SELECT department_id FROM departments WHERE location = 'London' OR location = 'Paris') AND e.hire_date BETWEEN '2018-01-01' AND '2022-12-31' AND e.salary > (SELECT AVG(salary) FROM employees WHERE department_id = e.department_id) AND EXISTS (SELECT 1 FROM employee_certifications ec WHERE ec.employee_id = e.employee_id AND ec.certification_date > '2023-01-01') ORDER BY e.last_name ASC, e.first_name ASC LIMIT 30;","output":"WITH DepartmentLocations AS (SELECT department_id FROM departments WHERE location = 'London' OR location = 'Paris'), AvgDeptSalary AS (SELECT department_id, AVG(salary) AS avg_salary FROM employees GROUP BY department_id) SELECT e.employee_id, e.first_name, e.last_name FROM employees AS e JOIN DepartmentLocations AS dl ON e.department_id = dl.department_id JOIN AvgDeptSalary AS ads ON e.department_id = ads.department_id JOIN employee_certifications AS ec ON e.employee_id = ec.employee_id WHERE e.hire_date BETWEEN '2018-01-01' AND '2022-12-31' AND e.salary > ads.avg_salary AND ec.certification_date > '2023-01-01' ORDER BY e.last_name ASC, e.first_name ASC LIMIT 30;"}
{"instruction":"Optimize the SQL query","input":"SELECT t1.col1, t1.col2, t2.col3 FROM table1 t1 JOIN table2 t2 ON t1.id = t2.t1_id WHERE t1.col4 = 'Active' AND t2.col5 IN (SELECT col_x FROM another_table WHERE col_y > 100) AND t1.col6 LIKE '%pattern%' AND t2.col7 BETWEEN '2023-01-01' AND '2023-03-31' ORDER BY t1.col1 DESC, t2.col3 ASC LIMIT 100;","output":"SELECT t1.col1, t1.col2, t2.col3 FROM table1 AS t1 JOIN table2 AS t2 ON t1.id = t2.t1_id JOIN another_table AS at ON t2.col5 = at.col_x WHERE t1.col4 = 'Active' AND at.col_y > 100 AND t1.col6 LIKE '%pattern%' AND t2.col7 BETWEEN '2023-01-01' AND '2023-03-31' ORDER BY t1.col1 DESC, t2.col3 ASC LIMIT 100;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.username, COUNT(p.post_id) AS total_posts, AVG(c.comment_rating) AS avg_comment_rating FROM users u LEFT JOIN posts p ON u.user_id = p.user_id LEFT JOIN comments c ON p.post_id = c.post_id WHERE u.status = 'active' AND p.created_at > '2023-01-01' AND c.comment_text LIKE '%important%' GROUP BY u.username HAVING COUNT(p.post_id) > 5 AND AVG(c.comment_rating) > 3 ORDER BY total_posts DESC, avg_comment_rating DESC LIMIT 20;","output":"SELECT u.username, COUNT(p.post_id) AS total_posts, AVG(c.comment_rating) AS avg_comment_rating FROM users AS u LEFT JOIN posts AS p ON u.user_id = p.user_id LEFT JOIN comments AS c ON p.post_id = c.post_id WHERE u.status = 'active' AND p.created_at > '2023-01-01' AND c.comment_text LIKE '%important%' GROUP BY u.username HAVING COUNT(p.post_id) > 5 AND AVG(c.comment_rating) > 3 ORDER BY total_posts DESC, avg_comment_rating DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT product_name, manufacturer, price FROM products WHERE category_id = (SELECT category_id FROM categories WHERE category_name = 'Electronics') AND price > (SELECT AVG(price) FROM products WHERE manufacturer = 'Sony') AND stock_quantity > 0 AND EXISTS (SELECT 1 FROM product_reviews pr WHERE pr.product_id = products.product_id AND pr.rating = 5) ORDER BY price DESC LIMIT 20;","output":"WITH AvgSonyPrice AS (SELECT AVG(price) AS avg_price FROM products WHERE manufacturer = 'Sony') SELECT p.product_name, p.manufacturer, p.price FROM products AS p JOIN categories AS cat ON p.category_id = cat.category_id JOIN product_reviews AS pr ON p.product_id = pr.product_id, AvgSonyPrice AS asp WHERE cat.category_name = 'Electronics' AND p.price > asp.avg_price AND p.stock_quantity > 0 AND pr.rating = 5 ORDER BY p.price DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT l.location_name, l.city, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.location_id = l.location_id) AS employee_count FROM locations l WHERE l.region = 'West' AND l.location_id NOT IN (SELECT office_id FROM office_rentals WHERE rental_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM location_services ls WHERE ls.location_id = l.location_id AND ls.service_type = 'Premium') ORDER BY employee_count DESC LIMIT 15;","output":"SELECT l.location_name, l.city, COUNT(e.employee_id) AS employee_count FROM locations AS l LEFT JOIN employees AS e ON l.location_id = e.location_id LEFT JOIN office_rentals AS or ON l.location_id = or.office_id AND or.rental_end_date > CURDATE() JOIN location_services AS ls ON l.location_id = ls.location_id WHERE l.region = 'West' AND or.office_id IS NULL AND ls.service_type = 'Premium' GROUP BY l.location_name, l.city ORDER BY employee_count DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.agent_id, a.agent_name, COUNT(c.client_id) AS total_clients, SUM(t.transaction_amount) AS total_commissions FROM agents a LEFT JOIN clients c ON a.agent_id = c.agent_id LEFT JOIN transactions t ON c.client_id = t.client_id WHERE a.hire_date < '2015-01-01' AND c.client_status = 'Active' AND t.transaction_date BETWEEN '2023-01-01' AND '2023-12-31' AND a.agent_id NOT IN (SELECT agent_id FROM agent_warnings WHERE warning_date > '2023-01-01') GROUP BY a.agent_id, a.agent_name HAVING COUNT(c.client_id) > 10 AND SUM(t.transaction_amount) > 50000 ORDER BY total_commissions DESC LIMIT 10;","output":"SELECT a.agent_id, a.agent_name, COUNT(c.client_id) AS total_clients, SUM(t.transaction_amount) AS total_commissions FROM agents AS a LEFT JOIN clients AS c ON a.agent_id = c.agent_id LEFT JOIN transactions AS t ON c.client_id = t.client_id LEFT JOIN agent_warnings AS aw ON a.agent_id = aw.agent_id AND aw.warning_date > '2023-01-01' WHERE a.hire_date < '2015-01-01' AND c.client_status = 'Active' AND t.transaction_date BETWEEN '2023-01-01' AND '2023-12-31' AND aw.agent_id IS NULL GROUP BY a.agent_id, a.agent_name HAVING COUNT(c.client_id) > 10 AND SUM(t.transaction_amount) > 50000 ORDER BY total_commissions DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.store_id, s.store_name, s.address FROM stores s WHERE s.city = 'Houston' AND s.store_id IN (SELECT store_id FROM daily_sales ds WHERE ds.sale_date = CURDATE() AND ds.total_sales > 10000) AND EXISTS (SELECT 1 FROM store_feedback sf WHERE sf.store_id = s.store_id AND sf.feedback_score >= 4.5) AND s.store_type = 'Supermarket' ORDER BY s.store_name ASC LIMIT 10;","output":"SELECT s.store_id, s.store_name, s.address FROM stores AS s JOIN daily_sales AS ds ON s.store_id = ds.store_id JOIN store_feedback AS sf ON s.store_id = sf.store_id WHERE s.city = 'Houston' AND ds.sale_date = CURDATE() AND ds.total_sales > 10000 AND sf.feedback_score >= 4.5 AND s.store_type = 'Supermarket' ORDER BY s.store_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT d.department_name, AVG(e.salary) AS avg_dept_salary, COUNT(e.employee_id) AS num_employees FROM departments d JOIN employees e ON d.department_id = e.department_id WHERE e.hire_date BETWEEN '2020-01-01' AND '2022-12-31' AND e.position NOT LIKE '%Trainee%' AND d.department_id NOT IN (SELECT department_id FROM department_budgets WHERE budget_year = 2023 AND actual_spend > allocated_budget) GROUP BY d.department_name HAVING AVG(e.salary) > 60000 AND COUNT(e.employee_id) > 5 ORDER BY avg_dept_salary DESC LIMIT 10;","output":"SELECT d.department_name, AVG(e.salary) AS avg_dept_salary, COUNT(e.employee_id) AS num_employees FROM departments AS d JOIN employees AS e ON d.department_id = e.department_id LEFT JOIN department_budgets AS db ON d.department_id = db.department_id AND db.budget_year = 2023 AND db.actual_spend > db.allocated_budget WHERE e.hire_date BETWEEN '2020-01-01' AND '2022-12-31' AND e.position NOT LIKE '%Trainee%' AND db.department_id IS NULL GROUP BY d.department_name HAVING AVG(e.salary) > 60000 AND COUNT(e.employee_id) > 5 ORDER BY avg_dept_salary DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_name, c.start_date, c.end_date FROM campaigns c WHERE c.campaign_type = 'Email' AND c.status = 'Active' AND c.start_date > '2023-01-01' AND EXISTS (SELECT 1 FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.conversion_rate > 0.05 AND cm.cost_per_conversion < 10) AND c.campaign_id NOT IN (SELECT campaign_id FROM campaign_issues ci WHERE ci.issue_severity = 'Critical') ORDER BY c.start_date DESC LIMIT 20;","output":"SELECT c.campaign_name, c.start_date, c.end_date FROM campaigns AS c JOIN campaign_metrics AS cm ON c.campaign_id = cm.campaign_id LEFT JOIN campaign_issues AS ci ON c.campaign_id = ci.campaign_id AND ci.issue_severity = 'Critical' WHERE c.campaign_type = 'Email' AND c.status = 'Active' AND c.start_date > '2023-01-01' AND cm.conversion_rate > 0.05 AND cm.cost_per_conversion < 10 AND ci.campaign_id IS NULL ORDER BY c.start_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, COUNT(p.photo_id) AS total_photos, SUM(p.views) AS total_views FROM users u LEFT JOIN photos p ON u.user_id = p.user_id WHERE u.country = 'Canada' AND u.registration_date BETWEEN '2021-01-01' AND '2022-12-31' AND p.upload_date > '2023-01-01' AND p.photo_id NOT IN (SELECT flag_photo_id FROM flagged_photos WHERE flag_reason = 'Inappropriate') GROUP BY u.user_id, u.username HAVING COUNT(p.photo_id) > 10 AND SUM(p.views) > 10000 ORDER BY total_views DESC LIMIT 15;","output":"SELECT u.user_id, u.username, COUNT(p.photo_id) AS total_photos, SUM(p.views) AS total_views FROM users AS u LEFT JOIN photos AS p ON u.user_id = p.user_id LEFT JOIN flagged_photos AS fp ON p.photo_id = fp.flag_photo_id AND fp.flag_reason = 'Inappropriate' WHERE u.country = 'Canada' AND u.registration_date BETWEEN '2021-01-01' AND '2022-12-31' AND p.upload_date > '2023-01-01' AND fp.flag_photo_id IS NULL GROUP BY u.user_id, u.username HAVING COUNT(p.photo_id) > 10 AND SUM(p.views) > 10000 ORDER BY total_views DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, o.order_date, o.total_amount, o.status, o.shipping_cost, o.tax_amount, o.discount_amount, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.payment_method, p.payment_status, p.transaction_id, s.shipping_method, s.tracking_number, s.carrier, s.estimated_delivery, s.actual_delivery_date, i.item_name, i.quantity, i.unit_price, i.discount_percentage, prom.promotion_name, prom.discount_type, tax.tax_rate, tax.tax_amount, ref.referral_source, ref.campaign_name FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id JOIN order_items i ON o.order_id = i.order_id LEFT JOIN promotions prom ON o.promotion_id = prom.promotion_id JOIN tax_calculations tax ON o.order_id = tax.order_id LEFT JOIN referral_sources ref ON o.referral_id = ref.referral_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 150.00 AND o.status IN ('completed', 'shipped', 'delivered') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX', 'FL', 'IL') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority', 'overnight') AND s.estimated_delivery > CURRENT_DATE - INTERVAL '30 days' AND i.quantity > 1 AND prom.discount_type = 'percentage' AND tax.tax_rate BETWEEN 0.05 AND 0.15 AND ref.campaign_name IS NOT NULL ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 100 OFFSET 0","output":"SELECT o.order_id, o.order_date, o.total_amount, o.status, o.shipping_cost, o.tax_amount, o.discount_amount, c.customer_name, c.email, c.phone, a.street, a.city, a.state, a.zip_code, a.country, p.payment_method, p.payment_status, p.transaction_id, s.shipping_method, s.tracking_number, s.carrier, s.estimated_delivery, s.actual_delivery_date, i.item_name, i.quantity, i.unit_price, i.discount_percentage, prom.promotion_name, prom.discount_type, tax.tax_rate, tax.tax_amount, ref.referral_source, ref.campaign_name FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN addresses a ON o.shipping_address_id = a.address_id JOIN payments p ON o.order_id = p.order_id JOIN shipments s ON o.order_id = s.order_id JOIN order_items i ON o.order_id = i.order_id LEFT JOIN promotions prom ON o.promotion_id = prom.promotion_id JOIN tax_calculations tax ON o.order_id = tax.order_id LEFT JOIN referral_sources ref ON o.referral_id = ref.referral_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-12-31' AND o.total_amount > 150.00 AND o.status IN ('completed', 'shipped', 'delivered') AND c.country = 'USA' AND a.state IN ('CA', 'NY', 'TX', 'FL', 'IL') AND p.payment_status = 'completed' AND s.shipping_method IN ('express', 'priority', 'overnight') AND s.estimated_delivery > CURRENT_DATE - INTERVAL '30 days' AND i.quantity > 1 AND prom.discount_type = 'percentage' AND tax.tax_rate BETWEEN 0.05 AND 0.15 AND ref.campaign_name IS NOT NULL ORDER BY o.total_amount DESC, o.order_date DESC LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.sku, inv.upc, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, inv.reorder_point, wh.warehouse_name, wh.location, wh.capacity, wh.manager_name, s.supplier_name, s.contact_email, s.phone, s.rating, cat.category_name, cat.category_description, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, aud.auditor_name, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery, sup.supply_cost, sup.lead_time, qua.quality_score, qua.inspection_date FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id LEFT JOIN supply_costs sup ON inv.supplier_id = sup.supplier_id LEFT JOIN quality_controls qua ON inv.inventory_id = qua.inventory_id WHERE inv.current_stock < inv.reorder_point AND inv.unit_cost > 20.00 AND wh.capacity > 5000 AND s.rating >= 4.2 AND cat.category_name IN ('raw_materials', 'components', 'finished_goods') AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-03-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND sup.lead_time < 14 AND qua.quality_score >= 90 AND inv.total_value > 3000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC, sup.lead_time ASC LIMIT 80 OFFSET 0","output":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.sku, inv.upc, inv.current_stock, inv.min_stock_level, inv.max_stock_level, inv.unit_cost, inv.total_value, inv.reorder_point, wh.warehouse_name, wh.location, wh.capacity, wh.manager_name, s.supplier_name, s.contact_email, s.phone, s.rating, cat.category_name, cat.category_description, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reason, emp.employee_name, aud.audit_date, aud.audit_result, aud.auditor_name, ord.reorder_quantity, ord.reorder_date, ord.expected_delivery, sup.supply_cost, sup.lead_time, qua.quality_score, qua.inspection_date FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN reorder_orders ord ON inv.inventory_id = ord.inventory_id LEFT JOIN supply_costs sup ON inv.supplier_id = sup.supplier_id LEFT JOIN quality_controls qua ON inv.inventory_id = qua.inventory_id WHERE inv.current_stock < inv.reorder_point AND inv.unit_cost > 20.00 AND wh.capacity > 5000 AND s.rating >= 4.2 AND cat.category_name IN ('raw_materials', 'components', 'finished_goods') AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-03-01' AND aud.audit_result = 'passed' AND ord.reorder_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND sup.lead_time < 14 AND qua.quality_score >= 90 AND inv.total_value > 3000.00 ORDER BY inv.current_stock ASC, inv.unit_cost DESC, sup.lead_time ASC LIMIT 80"}
{"instruction":"Optimize the SQL query","input":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.term_months, loan.status, loan.purpose, c.customer_name, c.credit_score, c.annual_income, c.employment_status, e.employee_name, e.department, br.branch_name, br.branch_region, pt.payment_term, pt.number_of_payments, sch.due_date, sch.amount_due, sch.paid_amount, sch.payment_status, coll.collection_status, coll.collection_date, coll.collection_amount, coll.collector_name, risk.risk_level, risk.risk_score, risk.risk_description, doc.document_name, doc.document_status, doc.verification_date, ins.insurance_amount, ins.insurance_provider, ins.policy_number, g.guarantor_name, g.guarantor_relationship, g.guarantor_income FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id LEFT JOIN guarantors g ON loan.loan_id = g.loan_id WHERE loan.amount > 30000.00 AND loan.interest_rate < 7.50 AND loan.start_date > '2021-01-01' AND loan.status = 'active' AND c.credit_score > 720 AND c.annual_income > 75000 AND e.department = 'lending' AND br.branch_region IN ('northeast', 'midwest') AND pt.number_of_payments > 24 AND sch.due_date BETWEEN '2023-10-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > loan.amount * 0.8 AND g.guarantor_income > 50000 ORDER BY loan.amount DESC, loan.interest_rate ASC, c.credit_score DESC LIMIT 65 OFFSET 0","output":"SELECT loan.loan_id, loan.amount, loan.interest_rate, loan.start_date, loan.end_date, loan.term_months, loan.status, loan.purpose, c.customer_name, c.credit_score, c.annual_income, c.employment_status, e.employee_name, e.department, br.branch_name, br.branch_region, pt.payment_term, pt.number_of_payments, sch.due_date, sch.amount_due, sch.paid_amount, sch.payment_status, coll.collection_status, coll.collection_date, coll.collection_amount, coll.collector_name, risk.risk_level, risk.risk_score, risk.risk_description, doc.document_name, doc.document_status, doc.verification_date, ins.insurance_amount, ins.insurance_provider, ins.policy_number, g.guarantor_name, g.guarantor_relationship, g.guarantor_income FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_term_id = pt.term_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id LEFT JOIN guarantors g ON loan.loan_id = g.loan_id WHERE loan.amount > 30000.00 AND loan.interest_rate < 7.50 AND loan.start_date > '2021-01-01' AND loan.status = 'active' AND c.credit_score > 720 AND c.annual_income > 75000 AND e.department = 'lending' AND br.branch_region IN ('northeast', 'midwest') AND pt.number_of_payments > 24 AND sch.due_date BETWEEN '2023-10-01' AND '2023-12-31' AND coll.collection_status = 'pending' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_amount > loan.amount * 0.8 AND g.guarantor_income > 50000 ORDER BY loan.amount DESC, loan.interest_rate ASC, c.credit_score DESC LIMIT 65"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.estimated_profit, p.status, p.priority, c.client_name, c.industry, c.client_rating, m.first_name AS manager_first, m.last_name AS manager_last, m.email AS manager_email, d.department_name, d.department_budget, t.team_name, t.team_size, t.team_location, r.risk_level, r.risk_description, r.impact_level, r.mitigation_plan, de.deliverable_name, de.description AS deliverable_desc, de.status AS deliverable_status, de.due_date, res.resource_name, res.resource_type, res.cost_rate, res.availability, times.hours_worked, times.overtime_hours, times.entry_date, exp.expense_type, exp.amount, exp.expense_date, mil.milestone_name, mil.completion_date, mil.status AS milestone_status FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id LEFT JOIN project_expenses exp ON p.project_id = exp.project_id LEFT JOIN project_milestones mil ON p.project_id = mil.project_id WHERE p.start_date > '2021-06-01' AND p.budget > 75000.00 AND p.status IN ('in_progress', 'planning') AND c.industry IN ('Technology', 'Finance', 'Healthcare', 'Manufacturing') AND c.client_rating >= 4.0 AND d.department_name = 'R&D' AND t.team_size > 6 AND r.risk_level IN ('medium', 'high') AND de.status = 'in_progress' AND res.resource_type = 'human' AND res.cost_rate > 45.00 AND times.hours_worked > 30 AND times.entry_date > '2023-02-01' AND exp.amount > 1000.00 AND mil.status = 'completed' ORDER BY p.budget DESC, p.priority ASC, p.start_date ASC LIMIT 45 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.description, p.start_date, p.end_date, p.budget, p.actual_cost, p.estimated_profit, p.status, p.priority, c.client_name, c.industry, c.client_rating, m.first_name AS manager_first, m.last_name AS manager_last, m.email AS manager_email, d.department_name, d.department_budget, t.team_name, t.team_size, t.team_location, r.risk_level, r.risk_description, r.impact_level, r.mitigation_plan, de.deliverable_name, de.description AS deliverable_desc, de.status AS deliverable_status, de.due_date, res.resource_name, res.resource_type, res.cost_rate, res.availability, times.hours_worked, times.overtime_hours, times.entry_date, exp.expense_type, exp.amount, exp.expense_date, mil.milestone_name, mil.completion_date, mil.status AS milestone_status FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables de ON p.project_id = de.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id LEFT JOIN project_expenses exp ON p.project_id = exp.project_id LEFT JOIN project_milestones mil ON p.project_id = mil.project_id WHERE p.start_date > '2021-06-01' AND p.budget > 75000.00 AND p.status IN ('in_progress', 'planning') AND c.industry IN ('Technology', 'Finance', 'Healthcare', 'Manufacturing') AND c.client_rating >= 4.0 AND d.department_name = 'R&D' AND t.team_size > 6 AND r.risk_level IN ('medium', 'high') AND de.status = 'in_progress' AND res.resource_type = 'human' AND res.cost_rate > 45.00 AND times.hours_worked > 30 AND times.entry_date > '2023-02-01' AND exp.amount > 1000.00 AND mil.status = 'completed' ORDER BY p.budget DESC, p.priority ASC, p.start_date ASC LIMIT 45"}
{"instruction":"Optimize the SQL query","input":"SELECT s.sale_id, s.sale_date, s.total_amount, s.tax_amount, s.discount_amount, s.shipping_cost, s.payment_method, s.transaction_id, c.customer_name, c.membership_level, c.loyalty_points, e.employee_name, e.department, st.store_name, st.location, st.store_size, p.product_name, p.category, p.brand, sd.quantity, sd.unit_price, sd.discount_percentage, prom.promotion_name, prom.discount_type, prom.start_date AS promo_start, prom.end_date AS promo_end, tax.tax_rate, tax.tax_amount, del.delivery_status, del.carrier, del.tracking_number, del.estimated_delivery, del.actual_delivery_date, ret.return_reason, ret.return_status, ret.refund_amount, pay.payment_status, pay.authorization_code, inv.inventory_level, sup.supplier_name FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id LEFT JOIN returns ret ON s.sale_id = ret.sale_id JOIN payments pay ON s.sale_id = pay.sale_id JOIN inventory_levels inv ON p.product_id = inv.product_id JOIN suppliers sup ON p.supplier_id = sup.supplier_id WHERE s.sale_date BETWEEN '2023-07-01' AND '2023-12-31' AND s.total_amount > 250.00 AND s.payment_method IN ('credit_card', 'debit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum', 'diamond') AND e.department = 'sales' AND st.location LIKE '%shopping%' AND p.category = 'electronics' AND sd.quantity > 1 AND prom.discount_type = 'percentage' AND tax.tax_rate BETWEEN 0.06 AND 0.12 AND del.delivery_status = 'delivered' AND pay.payment_status = 'completed' AND inv.inventory_level > 10 AND sup.supplier_rating >= 4.3 ORDER BY s.total_amount DESC, s.sale_date DESC, c.loyalty_points DESC LIMIT 90 OFFSET 0","output":"SELECT s.sale_id, s.sale_date, s.total_amount, s.tax_amount, s.discount_amount, s.shipping_cost, s.payment_method, s.transaction_id, c.customer_name, c.membership_level, c.loyalty_points, e.employee_name, e.department, st.store_name, st.location, st.store_size, p.product_name, p.category, p.brand, sd.quantity, sd.unit_price, sd.discount_percentage, prom.promotion_name, prom.discount_type, prom.start_date AS promo_start, prom.end_date AS promo_end, tax.tax_rate, tax.tax_amount, del.delivery_status, del.carrier, del.tracking_number, del.estimated_delivery, del.actual_delivery_date, ret.return_reason, ret.return_status, ret.refund_amount, pay.payment_status, pay.authorization_code, inv.inventory_level, sup.supplier_name FROM sales s JOIN customers c ON s.customer_id = c.customer_id JOIN employees e ON s.employee_id = e.employee_id JOIN stores st ON s.store_id = st.store_id JOIN sale_details sd ON s.sale_id = sd.sale_id JOIN products p ON sd.product_id = p.product_id LEFT JOIN promotions prom ON s.promotion_id = prom.promotion_id JOIN tax_calculations tax ON s.sale_id = tax.sale_id LEFT JOIN deliveries del ON s.sale_id = del.sale_id LEFT JOIN returns ret ON s.sale_id = ret.sale_id JOIN payments pay ON s.sale_id = pay.sale_id JOIN inventory_levels inv ON p.product_id = inv.product_id JOIN suppliers sup ON p.supplier_id = sup.supplier_id WHERE s.sale_date BETWEEN '2023-07-01' AND '2023-12-31' AND s.total_amount > 250.00 AND s.payment_method IN ('credit_card', 'debit_card', 'digital_wallet') AND c.membership_level IN ('gold', 'platinum', 'diamond') AND e.department = 'sales' AND st.location LIKE '%shopping%' AND p.category = 'electronics' AND sd.quantity > 1 AND prom.discount_type = 'percentage' AND tax.tax_rate BETWEEN 0.06 AND 0.12 AND del.delivery_status = 'delivered' AND pay.payment_status = 'completed' AND inv.inventory_level > 10 AND sup.supplier_rating >= 4.3 ORDER BY s.total_amount DESC, s.sale_date DESC, c.loyalty_points DESC LIMIT 90"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.store_id, s.store_name FROM stores s WHERE s.region = 'North' AND s.store_id IN (SELECT DISTINCT sales.store_id FROM sales WHERE sales.sale_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY sales.store_id HAVING SUM(sales.amount) > 100000) AND EXISTS (SELECT 1 FROM store_feedback sf WHERE sf.store_id = s.store_id AND sf.rating = 5 AND sf.feedback_date > '2023-01-01') AND s.establishment_date < '2010-01-01' ORDER BY s.store_name ASC LIMIT 10;","output":"SELECT s.store_id, s.store_name FROM stores AS s JOIN (SELECT store_id FROM sales WHERE sale_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY store_id HAVING SUM(amount) > 100000) AS recent_high_sales ON s.store_id = recent_high_sales.store_id JOIN store_feedback AS sf ON s.store_id = sf.store_id WHERE s.region = 'North' AND sf.rating = 5 AND sf.feedback_date > '2023-01-01' AND s.establishment_date < '2010-01-01' ORDER BY s.store_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_name, p.price, (SELECT COUNT(oi.order_item_id) FROM order_items oi WHERE oi.product_id = p.product_id) AS total_sold_items FROM products p WHERE p.category_id = (SELECT c.category_id FROM categories c WHERE c.category_name = 'Books') AND p.price > 20 AND p.stock_quantity > 0 ORDER BY total_sold_items DESC, p.price DESC LIMIT 20;","output":"SELECT p.product_name, p.price, COALESCE(SUM(oi.order_item_id) OVER (PARTITION BY p.product_id), 0) AS total_sold_items FROM products AS p JOIN categories AS c ON p.category_id = c.category_id LEFT JOIN order_items AS oi ON p.product_id = oi.product_id WHERE c.category_name = 'Books' AND p.price > 20 AND p.stock_quantity > 0 ORDER BY total_sold_items DESC, p.price DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT e.employee_id, e.first_name, e.last_name, d.department_name, (SELECT MAX(pa.performance_score) FROM performance_appraisals pa WHERE pa.employee_id = e.employee_id AND pa.appraisal_date > '2023-01-01') AS latest_score FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE e.hire_date BETWEEN '2018-01-01' AND '2022-12-31' AND e.status = 'active' AND d.department_name NOT IN ('HR', 'Legal') ORDER BY latest_score DESC, e.last_name ASC LIMIT 15;","output":"SELECT e.employee_id, e.first_name, e.last_name, d.department_name, MAX(pa.performance_score) AS latest_score FROM employees AS e JOIN departments AS d ON e.department_id = d.department_id LEFT JOIN performance_appraisals AS pa ON e.employee_id = pa.employee_id WHERE e.hire_date BETWEEN '2018-01-01' AND '2022-12-31' AND e.status = 'active' AND d.department_name NOT IN ('HR', 'Legal') AND pa.appraisal_date > '2023-01-01' GROUP BY e.employee_id, e.first_name, e.last_name, d.department_name ORDER BY latest_score DESC, e.last_name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.customer_id, c.customer_name, SUM(o.total_amount) AS total_spent FROM customers c JOIN orders o ON c.customer_id = o.customer_id WHERE c.registration_date > '2020-01-01' AND o.order_date > '2022-01-01' AND c.customer_id IN (SELECT customer_id FROM customer_preferences cp WHERE cp.marketing_opt_in = TRUE) GROUP BY c.customer_id, c.customer_name HAVING SUM(o.total_amount) > 5000 AND COUNT(o.order_id) >= 3 ORDER BY total_spent DESC LIMIT 25 OFFSET 5;","output":"SELECT c.customer_id, c.customer_name, SUM(o.total_amount) AS total_spent FROM customers AS c JOIN orders AS o ON c.customer_id = o.customer_id JOIN customer_preferences AS cp ON c.customer_id = cp.customer_id WHERE c.registration_date > '2020-01-01' AND o.order_date > '2022-01-01' AND cp.marketing_opt_in = TRUE GROUP BY c.customer_id, c.customer_name HAVING SUM(o.total_amount) > 5000 AND COUNT(o.order_id) >= 3 ORDER BY total_spent DESC LIMIT 25 OFFSET 5;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.airport_name, a.city, (SELECT COUNT(f.flight_id) FROM flights f WHERE f.departure_airport_id = a.airport_id AND f.flight_date = CURDATE()) AS daily_departures, (SELECT COUNT(f2.flight_id) FROM flights f2 WHERE f2.arrival_airport_id = a.airport_id AND f2.flight_date = CURDATE()) AS daily_arrivals FROM airports a WHERE a.country = 'USA' AND a.airport_id NOT IN (SELECT r.airport_id FROM runway_issues r WHERE r.issue_date = CURDATE()) ORDER BY daily_departures DESC, daily_arrivals DESC LIMIT 10;","output":"WITH DailyDepartures AS (SELECT departure_airport_id AS airport_id, COUNT(flight_id) AS daily_departures FROM flights WHERE flight_date = CURDATE() GROUP BY departure_airport_id), DailyArrivals AS (SELECT arrival_airport_id AS airport_id, COUNT(flight_id) AS daily_arrivals FROM flights WHERE flight_date = CURDATE() GROUP BY arrival_airport_id) SELECT a.airport_name, a.city, COALESCE(dd.daily_departures, 0) AS daily_departures, COALESCE(da.daily_arrivals, 0) AS daily_arrivals FROM airports AS a LEFT JOIN DailyDepartures AS dd ON a.airport_id = dd.airport_id LEFT JOIN DailyArrivals AS da ON a.airport_id = da.airport_id LEFT JOIN runway_issues AS ri ON a.airport_id = ri.airport_id AND ri.issue_date = CURDATE() WHERE a.country = 'USA' AND ri.airport_id IS NULL ORDER BY daily_departures DESC, daily_arrivals DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.station_name, s.location, (SELECT AVG(CAST(pm.temperature AS DECIMAL(5,2))) FROM weather_readings pm WHERE pm.station_id = s.station_id AND pm.reading_date BETWEEN '2023-07-01' AND '2023-07-31') AS avg_july_temp, (SELECT MAX(pm2.humidity) FROM weather_readings pm2 WHERE pm2.station_id = s.station_id AND pm2.reading_date BETWEEN '2023-07-01' AND '2023-07-31') AS max_july_humidity FROM weather_stations s WHERE s.elevation > 1000 AND s.station_type = 'Automated' ORDER BY avg_july_temp DESC, max_july_humidity DESC LIMIT 10;","output":"WITH JulyReadings AS (SELECT station_id, AVG(CAST(temperature AS DECIMAL(5,2))) AS avg_july_temp, MAX(humidity) AS max_july_humidity FROM weather_readings WHERE reading_date BETWEEN '2023-07-01' AND '2023-07-31' GROUP BY station_id) SELECT s.station_name, s.location, jr.avg_july_temp, jr.max_july_humidity FROM weather_stations AS s JOIN JulyReadings AS jr ON s.station_id = jr.station_id WHERE s.elevation > 1000 AND s.station_type = 'Automated' ORDER BY jr.avg_july_temp DESC, jr.max_july_humidity DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, COUNT(DISTINCT l.log_id) AS total_logins, SUM(l.duration_seconds) AS total_time_spent FROM users u LEFT JOIN user_logs l ON u.user_id = l.user_id WHERE u.status = 'active' AND l.log_date > '2023-01-01' AND l.log_type = 'session' AND u.user_id NOT IN (SELECT user_id FROM user_bans WHERE ban_end_date > CURDATE()) GROUP BY u.user_id, u.username HAVING COUNT(DISTINCT l.log_id) > 50 AND SUM(l.duration_seconds) > 36000 ORDER BY total_time_spent DESC LIMIT 20;","output":"SELECT u.user_id, u.username, COUNT(DISTINCT l.log_id) AS total_logins, SUM(l.duration_seconds) AS total_time_spent FROM users AS u LEFT JOIN user_logs AS l ON u.user_id = l.user_id LEFT JOIN user_bans AS ub ON u.user_id = ub.user_id AND ub.ban_end_date > CURDATE() WHERE u.status = 'active' AND l.log_date > '2023-01-01' AND l.log_type = 'session' AND ub.user_id IS NULL GROUP BY u.user_id, u.username HAVING COUNT(DISTINCT l.log_id) > 50 AND SUM(l.duration_seconds) > 36000 ORDER BY total_time_spent DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.policy_id, p.policy_holder_name, p.premium_amount FROM policies p WHERE p.policy_status = 'Active' AND p.issue_date BETWEEN '2020-01-01' AND '2023-12-31' AND p.policy_type = 'Life Insurance' AND p.policy_id IN (SELECT cl.policy_id FROM claims cl WHERE cl.claim_status = 'Approved' AND cl.claim_date > '2023-01-01') AND EXISTS (SELECT 1 FROM policy_renewals pr WHERE pr.policy_id = p.policy_id AND pr.renewal_date = '2024-01-01') ORDER BY p.premium_amount DESC LIMIT 10;","output":"SELECT p.policy_id, p.policy_holder_name, p.premium_amount FROM policies AS p JOIN claims AS cl ON p.policy_id = cl.policy_id JOIN policy_renewals AS pr ON p.policy_id = pr.policy_id WHERE p.policy_status = 'Active' AND p.issue_date BETWEEN '2020-01-01' AND '2023-12-31' AND p.policy_type = 'Life Insurance' AND cl.claim_status = 'Approved' AND cl.claim_date > '2023-01-01' AND pr.renewal_date = '2024-01-01' ORDER BY p.premium_amount DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT d.drug_name, d.manufacturer, SUM(s.quantity_sold) AS total_quantity_sold FROM drugs d JOIN sales s ON d.drug_id = s.drug_id WHERE d.is_prescription_required = TRUE AND s.sale_date BETWEEN '2023-01-01' AND '2023-06-30' AND d.drug_id NOT IN (SELECT rd.drug_id FROM drug_recalls rd WHERE rd.recall_date > '2023-01-01') GROUP BY d.drug_name, d.manufacturer HAVING SUM(s.quantity_sold) > 10000 ORDER BY total_quantity_sold DESC LIMIT 10;","output":"SELECT d.drug_name, d.manufacturer, SUM(s.quantity_sold) AS total_quantity_sold FROM drugs AS d JOIN sales AS s ON d.drug_id = s.drug_id LEFT JOIN drug_recalls AS dr ON d.drug_id = dr.drug_id AND dr.recall_date > '2023-01-01' WHERE d.is_prescription_required = TRUE AND s.sale_date BETWEEN '2023-01-01' AND '2023-06-30' AND dr.drug_id IS NULL GROUP BY d.drug_name, d.manufacturer HAVING SUM(s.quantity_sold) > 10000 ORDER BY total_quantity_sold DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT f.fund_name, f.fund_manager FROM funds f WHERE f.fund_type = 'Equity' AND f.inception_date < '2015-01-01' AND EXISTS (SELECT 1 FROM fund_performance fp WHERE fp.fund_id = f.fund_id AND fp.performance_year = 2023 AND fp.return_percentage > 10) AND f.fund_id NOT IN (SELECT ia.fund_id FROM investment_alerts ia WHERE ia.alert_type = 'High Risk' AND ia.alert_date > '2023-01-01') ORDER BY f.fund_name ASC LIMIT 15;","output":"SELECT f.fund_name, f.fund_manager FROM funds AS f JOIN fund_performance AS fp ON f.fund_id = fp.fund_id LEFT JOIN investment_alerts AS ia ON f.fund_id = ia.fund_id AND ia.alert_type = 'High Risk' AND ia.alert_date > '2023-01-01' WHERE f.fund_type = 'Equity' AND f.inception_date < '2015-01-01' AND fp.performance_year = 2023 AND fp.return_percentage > 10 AND ia.fund_id IS NULL ORDER BY f.fund_name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.author_name, COUNT(b.book_id) AS total_books, AVG(b.rating) AS avg_book_rating FROM authors a LEFT JOIN books b ON a.author_id = b.author_id WHERE a.country = 'UK' AND b.publication_year BETWEEN 2000 AND 2020 AND b.genre IN ('Fantasy', 'Mystery') AND a.author_id NOT IN (SELECT pa.author_id FROM author_penalties pa WHERE pa.penalty_date > '2023-01-01') GROUP BY a.author_name HAVING COUNT(b.book_id) > 5 AND AVG(b.rating) > 4.0 ORDER BY total_books DESC, avg_book_rating DESC LIMIT 10;","output":"SELECT a.author_name, COUNT(b.book_id) AS total_books, AVG(b.rating) AS avg_book_rating FROM authors AS a LEFT JOIN books AS b ON a.author_id = b.author_id LEFT JOIN author_penalties AS ap ON a.author_id = ap.author_id AND ap.penalty_date > '2023-01-01' WHERE a.country = 'UK' AND b.publication_year BETWEEN 2000 AND 2020 AND b.genre IN ('Fantasy', 'Mystery') AND ap.author_id IS NULL GROUP BY a.author_name HAVING COUNT(b.book_id) > 5 AND AVG(b.rating) > 4.0 ORDER BY total_books DESC, avg_book_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.course_name, c.course_code, (SELECT COUNT(e.enrollment_id) FROM enrollments e WHERE e.course_id = c.course_id AND e.enrollment_date > '2023-01-01') AS recent_enrollments, (SELECT AVG(s.score) FROM student_scores s WHERE s.course_id = c.course_id) AS avg_score FROM courses c WHERE c.department = 'Computer Science' AND c.credits >= 3 AND c.course_id NOT IN (SELECT r.course_id FROM course_reviews r WHERE r.review_rating < 3 AND r.review_date > '2023-01-01') ORDER BY recent_enrollments DESC, avg_score DESC LIMIT 10;","output":"WITH RecentEnrollments AS (SELECT course_id, COUNT(enrollment_id) AS recent_enrollments FROM enrollments WHERE enrollment_date > '2023-01-01' GROUP BY course_id), AvgScores AS (SELECT course_id, AVG(score) AS avg_score FROM student_scores GROUP BY course_id) SELECT c.course_name, c.course_code, COALESCE(re.recent_enrollments, 0) AS recent_enrollments, COALESCE(asc.avg_score, 0) AS avg_score FROM courses AS c LEFT JOIN RecentEnrollments AS re ON c.course_id = re.course_id LEFT JOIN AvgScores AS asc ON c.course_id = asc.course_id LEFT JOIN course_reviews AS cr ON c.course_id = cr.course_id AND cr.review_rating < 3 AND cr.review_date > '2023-01-01' WHERE c.department = 'Computer Science' AND c.credits >= 3 AND cr.course_id IS NULL ORDER BY recent_enrollments DESC, avg_score DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT l.library_name, l.city, (SELECT COUNT(b.book_id) FROM books b WHERE b.library_id = l.library_id AND b.publication_year = 2023) AS new_books_2023 FROM libraries l WHERE l.region = 'South' AND l.library_id NOT IN (SELECT bl.library_id FROM blocked_libraries bl WHERE bl.block_reason = 'Overdue Fines' AND bl.block_date > '2023-01-01') AND EXISTS (SELECT 1 FROM library_events le WHERE le.library_id = l.library_id AND le.event_type = 'Reading Club' AND le.event_date > '2023-06-01') ORDER BY new_books_2023 DESC, l.library_name ASC LIMIT 10;","output":"SELECT l.library_name, l.city, COALESCE(COUNT(b.book_id) OVER (PARTITION BY l.library_id), 0) AS new_books_2023 FROM libraries AS l LEFT JOIN books AS b ON l.library_id = b.library_id AND b.publication_year = 2023 LEFT JOIN blocked_libraries AS bl ON l.library_id = bl.library_id AND bl.block_reason = 'Overdue Fines' AND bl.block_date > '2023-01-01' JOIN library_events AS le ON l.library_id = le.library_id WHERE l.region = 'South' AND bl.library_id IS NULL AND le.event_type = 'Reading Club' AND le.event_date > '2023-06-01' GROUP BY l.library_name, l.city ORDER BY new_books_2023 DESC, l.library_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.item_name, inv.quantity_on_hand, inv.last_restock_date FROM inventory inv WHERE inv.warehouse_id = (SELECT w.warehouse_id FROM warehouses w WHERE w.location = 'Central') AND inv.quantity_on_hand < 50 AND inv.item_id NOT IN (SELECT oi.item_id FROM outdated_items oi WHERE oi.obsolete_date < CURDATE()) AND EXISTS (SELECT 1 FROM item_suppliers isu WHERE isu.item_id = inv.item_id AND isu.supplier_name = 'MegaCorp') ORDER BY inv.quantity_on_hand ASC, inv.last_restock_date DESC LIMIT 20;","output":"SELECT inv.item_name, inv.quantity_on_hand, inv.last_restock_date FROM inventory AS inv JOIN warehouses AS w ON inv.warehouse_id = w.warehouse_id LEFT JOIN outdated_items AS oi ON inv.item_id = oi.item_id AND oi.obsolete_date < CURDATE() JOIN item_suppliers AS isu ON inv.item_id = isu.item_id WHERE w.location = 'Central' AND inv.quantity_on_hand < 50 AND oi.item_id IS NULL AND isu.supplier_name = 'MegaCorp' ORDER BY inv.quantity_on_hand ASC, inv.last_restock_date DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.trainer_name, tr.specialty, COUNT(cl.client_id) AS total_clients, AVG(cl.sessions_completed) AS avg_sessions FROM trainers tr LEFT JOIN clients cl ON tr.trainer_id = cl.trainer_id WHERE tr.experience_years > 5 AND tr.specialty IN ('Weightlifting', 'Cardio') AND cl.start_date > '2023-01-01' AND tr.trainer_id NOT IN (SELECT ta.trainer_id FROM trainer_absences ta WHERE ta.absence_date BETWEEN '2023-01-01' AND '2023-12-31') GROUP BY tr.trainer_name, tr.specialty HAVING COUNT(cl.client_id) > 10 AND AVG(cl.sessions_completed) > 20 ORDER BY total_clients DESC, avg_sessions DESC LIMIT 10;","output":"SELECT tr.trainer_name, tr.specialty, COUNT(cl.client_id) AS total_clients, AVG(cl.sessions_completed) AS avg_sessions FROM trainers AS tr LEFT JOIN clients AS cl ON tr.trainer_id = cl.trainer_id LEFT JOIN trainer_absences AS ta ON tr.trainer_id = ta.trainer_id AND ta.absence_date BETWEEN '2023-01-01' AND '2023-12-31' WHERE tr.experience_years > 5 AND tr.specialty IN ('Weightlifting', 'Cardio') AND cl.start_date > '2023-01-01' AND ta.trainer_id IS NULL GROUP BY tr.trainer_name, tr.specialty HAVING COUNT(cl.client_id) > 10 AND AVG(cl.sessions_completed) > 20 ORDER BY total_clients DESC, avg_sessions DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT m.movie_title, m.release_year, d.director_name FROM movies m JOIN directors d ON m.director_id = d.director_id WHERE m.genre = 'Drama' AND m.release_year BETWEEN 2010 AND 2020 AND m.movie_id NOT IN (SELECT ur.movie_id FROM user_ratings ur WHERE ur.rating < 3 AND ur.rating_date > '2023-01-01') AND EXISTS (SELECT 1 FROM movie_awards ma WHERE ma.movie_id = m.movie_id AND ma.award_type = 'Oscar') ORDER BY m.release_year DESC, m.movie_title ASC LIMIT 15;","output":"SELECT m.movie_title, m.release_year, d.director_name FROM movies AS m JOIN directors AS d ON m.director_id = d.director_id LEFT JOIN user_ratings AS ur ON m.movie_id = ur.movie_id AND ur.rating < 3 AND ur.rating_date > '2023-01-01' JOIN movie_awards AS ma ON m.movie_id = ma.movie_id WHERE m.genre = 'Drama' AND m.release_year BETWEEN 2010 AND 2020 AND ur.movie_id IS NULL AND ma.award_type = 'Oscar' ORDER BY m.release_year DESC, m.movie_title ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT v.vendor_name, v.contact_person FROM vendors v WHERE v.vendor_status = 'Approved' AND v.country = 'Germany' AND v.vendor_id IN (SELECT po.vendor_id FROM purchase_orders po WHERE po.order_date > '2023-01-01' AND po.total_amount > 5000) AND EXISTS (SELECT 1 FROM vendor_ratings vr WHERE vr.vendor_id = v.vendor_id AND vr.average_rating > 4.0) ORDER BY v.vendor_name ASC LIMIT 10;","output":"SELECT v.vendor_name, v.contact_person FROM vendors AS v JOIN purchase_orders AS po ON v.vendor_id = po.vendor_id JOIN vendor_ratings AS vr ON v.vendor_id = vr.vendor_id WHERE v.vendor_status = 'Approved' AND v.country = 'Germany' AND po.order_date > '2023-01-01' AND po.total_amount > 5000 AND vr.average_rating > 4.0 ORDER BY v.vendor_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT ev.event_name, ev.event_date, ev.location FROM events ev WHERE ev.event_type = 'Conference' AND ev.event_date BETWEEN '2023-09-01' AND '2023-12-31' AND ev.event_id NOT IN (SELECT ec.event_id FROM event_cancellations ec WHERE ec.cancellation_date > '2023-09-01') AND EXISTS (SELECT 1 FROM event_sponsors es WHERE es.event_id = ev.event_id AND es.sponsor_level = 'Platinum') ORDER BY ev.event_date ASC LIMIT 10;","output":"SELECT ev.event_name, ev.event_date, ev.location FROM events AS ev LEFT JOIN event_cancellations AS ec ON ev.event_id = ec.event_id AND ec.cancellation_date > '2023-09-01' JOIN event_sponsors AS es ON ev.event_id = es.event_id WHERE ev.event_type = 'Conference' AND ev.event_date BETWEEN '2023-09-01' AND '2023-12-31' AND ec.event_id IS NULL AND es.sponsor_level = 'Platinum' ORDER BY ev.event_date ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT cl.class_name, cl.class_code, t.teacher_name FROM classes cl JOIN teachers t ON cl.teacher_id = t.teacher_id WHERE cl.semester = 'Fall 2023' AND t.department = 'Mathematics' AND cl.class_id IN (SELECT en.class_id FROM enrollments en WHERE en.enrollment_date > '2023-08-01' AND en.status = 'Enrolled') AND EXISTS (SELECT 1 FROM class_rooms cr WHERE cr.class_id = cl.class_id AND cr.capacity > 30) ORDER BY cl.class_name ASC LIMIT 15;","output":"SELECT cl.class_name, cl.class_code, t.teacher_name FROM classes AS cl JOIN teachers AS t ON cl.teacher_id = t.teacher_id JOIN enrollments AS en ON cl.class_id = en.class_id JOIN class_rooms AS cr ON cl.class_id = cr.class_id WHERE cl.semester = 'Fall 2023' AND t.department = 'Mathematics' AND en.enrollment_date > '2023-08-01' AND en.status = 'Enrolled' AND cr.capacity > 30 ORDER BY cl.class_name ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT u.user_id, u.username, u.email, (SELECT COUNT(l.log_id) FROM user_logs l WHERE l.user_id = u.user_id AND l.log_type = 'login' AND l.log_date > '2023-01-01') AS logins_2023, (SELECT MAX(l.log_date) FROM user_logs l WHERE l.user_id = u.user_id AND l.log_type = 'login') AS last_login FROM users u WHERE u.status = 'active' AND u.registration_date BETWEEN '2020-01-01' AND '2021-12-31' AND u.user_id NOT IN (SELECT DISTINCT ub.user_id FROM user_bans ub WHERE ub.ban_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM user_subscriptions us WHERE us.user_id = u.user_id AND us.subscription_status = 'active' AND us.plan_type = 'Premium') ORDER BY logins_2023 DESC, last_login DESC LIMIT 20;","output":"WITH UserLoginCounts AS (SELECT user_id, COUNT(log_id) AS logins_2023, MAX(log_date) AS last_login FROM user_logs WHERE log_type = 'login' AND log_date > '2023-01-01' GROUP BY user_id) SELECT u.user_id, u.username, u.email, COALESCE(ulc.logins_2023, 0) AS logins_2023, ulc.last_login FROM users AS u LEFT JOIN UserLoginCounts AS ulc ON u.user_id = ulc.user_id LEFT JOIN user_bans AS ub ON u.user_id = ub.user_id AND ub.ban_end_date > CURDATE() JOIN user_subscriptions AS us ON u.user_id = us.user_id WHERE u.status = 'active' AND u.registration_date BETWEEN '2020-01-01' AND '2021-12-31' AND ub.user_id IS NULL AND us.subscription_status = 'active' AND us.plan_type = 'Premium' ORDER BY logins_2023 DESC, last_login DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.order_id, c.customer_name, o.order_date, SUM(oi.quantity * p.price) AS total_order_value FROM orders o JOIN customers c ON o.customer_id = c.customer_id JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-03-31' AND c.country = 'Germany' AND p.category_id IN (SELECT category_id FROM categories WHERE category_name LIKE '%Electronic%') AND o.customer_id IN (SELECT customer_id FROM customer_segments WHERE segment_type = 'High-Value') GROUP BY o.order_id, c.customer_name, o.order_date HAVING SUM(oi.quantity * p.price) > 500 AND COUNT(oi.order_item_id) > 1 ORDER BY total_order_value DESC, o.order_date ASC LIMIT 30;","output":"SELECT o.order_id, c.customer_name, o.order_date, SUM(oi.quantity * p.price) AS total_order_value FROM orders AS o JOIN customers AS c ON o.customer_id = c.customer_id JOIN order_items AS oi ON o.order_id = oi.order_id JOIN products AS p ON oi.product_id = p.product_id JOIN categories AS cat ON p.category_id = cat.category_id JOIN customer_segments AS cs ON c.customer_id = cs.customer_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-03-31' AND c.country = 'Germany' AND cat.category_name LIKE '%Electronic%' AND cs.segment_type = 'High-Value' GROUP BY o.order_id, c.customer_name, o.order_date HAVING SUM(oi.quantity * p.price) > 500 AND COUNT(oi.order_item_id) > 1 ORDER BY total_order_value DESC, o.order_date ASC LIMIT 30;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT e.employee_id, e.first_name, e.last_name, d.department_name, (SELECT COUNT(pr.project_id) FROM employee_projects pr WHERE pr.employee_id = e.employee_id AND pr.project_status = 'Completed' AND pr.end_date > '2023-01-01') AS completed_projects_2023, (SELECT AVG(pr.duration_days) FROM employee_projects pr WHERE pr.employee_id = e.employee_id) AS avg_project_duration FROM employees e JOIN departments d ON e.department_id = d.department_id WHERE e.hire_date BETWEEN '2015-01-01' AND '2020-12-31' AND e.salary > 80000 AND d.location = 'New York' AND e.employee_id NOT IN (SELECT ex.employee_id FROM employee_exits ex WHERE ex.exit_date > '2023-01-01') AND EXISTS (SELECT 1 FROM employee_roles er JOIN roles r ON er.role_id = r.role_id WHERE er.employee_id = e.employee_id AND r.role_name = 'Senior Engineer') ORDER BY completed_projects_2023 DESC, avg_project_duration DESC LIMIT 25;","output":"WITH CompletedProjects AS (SELECT employee_id, COUNT(project_id) AS completed_projects_2023, AVG(duration_days) AS avg_project_duration FROM employee_projects WHERE project_status = 'Completed' AND end_date > '2023-01-01' GROUP BY employee_id) SELECT e.employee_id, e.first_name, e.last_name, d.department_name, COALESCE(cp.completed_projects_2023, 0) AS completed_projects_2023, COALESCE(cp.avg_project_duration, 0) AS avg_project_duration FROM employees AS e JOIN departments AS d ON e.department_id = d.department_id LEFT JOIN CompletedProjects AS cp ON e.employee_id = cp.employee_id LEFT JOIN employee_exits AS ex ON e.employee_id = ex.employee_id AND ex.exit_date > '2023-01-01' JOIN employee_roles AS er ON e.employee_id = er.employee_id JOIN roles AS r ON er.role_id = r.role_id WHERE e.hire_date BETWEEN '2015-01-01' AND '2020-12-31' AND e.salary > 80000 AND d.location = 'New York' AND ex.employee_id IS NULL AND r.role_name = 'Senior Engineer' ORDER BY completed_projects_2023 DESC, avg_project_duration DESC LIMIT 25;"}
{"instruction":"Optimize the SQL query","input":"SELECT product_name, manufacturer, price, (SELECT AVG(price) FROM products WHERE category_id = p.category_id) AS avg_category_price, (SELECT COUNT(DISTINCT customer_id) FROM order_items oi JOIN orders o ON oi.order_id = o.order_id WHERE oi.product_id = p.product_id AND o.order_date BETWEEN '2023-07-01' AND '2023-09-30') AS Q3_unique_buyers, (SELECT SUM(oi.quantity) FROM order_items oi WHERE oi.product_id = p.product_id AND oi.order_id IN (SELECT order_id FROM orders WHERE order_date BETWEEN '2023-07-01' AND '2023-09-30')) AS Q3_total_sold FROM products p WHERE p.stock_quantity < 50 AND p.price > 100 AND p.category_id IN (SELECT category_id FROM categories WHERE category_name NOT LIKE '%Food%') AND EXISTS (SELECT 1 FROM product_reviews pr WHERE pr.product_id = p.product_id AND pr.rating >= 4 AND pr.review_date > '2023-01-01') ORDER BY Q3_unique_buyers DESC, Q3_total_sold DESC LIMIT 20;","output":"WITH CategoryAvgPrice AS (SELECT category_id, AVG(price) AS avg_category_price FROM products GROUP BY category_id), Q3Sales AS (SELECT oi.product_id, COUNT(DISTINCT o.customer_id) AS Q3_unique_buyers, SUM(oi.quantity) AS Q3_total_sold FROM order_items AS oi JOIN orders AS o ON oi.order_id = o.order_id WHERE o.order_date BETWEEN '2023-07-01' AND '2023-09-30' GROUP BY oi.product_id) SELECT p.product_name, p.manufacturer, p.price, cap.avg_category_price, COALESCE(qs.Q3_unique_buyers, 0) AS Q3_unique_buyers, COALESCE(qs.Q3_total_sold, 0) AS Q3_total_sold FROM products AS p JOIN categories AS cat ON p.category_id = cat.category_id LEFT JOIN CategoryAvgPrice AS cap ON p.category_id = cap.category_id LEFT JOIN Q3Sales AS qs ON p.product_id = qs.product_id JOIN product_reviews AS pr ON p.product_id = pr.product_id WHERE p.stock_quantity < 50 AND p.price > 100 AND cat.category_name NOT LIKE '%Food%' AND pr.rating >= 4 AND pr.review_date > '2023-01-01' ORDER BY Q3_unique_buyers DESC, Q3_total_sold DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT a.artist_name, a.country, (SELECT COUNT(al.album_id) FROM albums al WHERE al.artist_id = a.artist_id AND al.release_year > 2020) AS recent_albums_count, (SELECT AVG(t.duration) FROM tracks t JOIN albums al ON t.album_id = al.album_id WHERE al.artist_id = a.artist_id AND t.genre = 'Pop') AS avg_pop_track_duration FROM artists a WHERE a.genre_preference = 'Rock' AND a.artist_id NOT IN (SELECT DISTINCT aa.artist_id FROM artist_awards aa WHERE aa.award_year = 2023 AND aa.award_type = 'Grammy') AND EXISTS (SELECT 1 FROM artist_social_media asm WHERE asm.artist_id = a.artist_id AND asm.platform = 'Instagram' AND asm.followers > 100000) ORDER BY recent_albums_count DESC, avg_pop_track_duration DESC LIMIT 15;","output":"WITH RecentAlbums AS (SELECT artist_id, COUNT(album_id) AS recent_albums_count FROM albums WHERE release_year > 2020 GROUP BY artist_id), AvgPopTrackDuration AS (SELECT al.artist_id, AVG(t.duration) AS avg_pop_track_duration FROM tracks AS t JOIN albums AS al ON t.album_id = al.album_id WHERE t.genre = 'Pop' GROUP BY al.artist_id) SELECT a.artist_name, a.country, COALESCE(ra.recent_albums_count, 0) AS recent_albums_count, COALESCE(apt.avg_pop_track_duration, 0) AS avg_pop_track_duration FROM artists AS a LEFT JOIN RecentAlbums AS ra ON a.artist_id = ra.artist_id LEFT JOIN AvgPopTrackDuration AS apt ON a.artist_id = apt.artist_id LEFT JOIN artist_awards AS aa ON a.artist_id = aa.artist_id AND aa.award_year = 2023 AND aa.award_type = 'Grammy' JOIN artist_social_media AS asm ON a.artist_id = asm.artist_id WHERE a.genre_preference = 'Rock' AND aa.artist_id IS NULL AND asm.platform = 'Instagram' AND asm.followers > 100000 ORDER BY recent_albums_count DESC, avg_pop_track_duration DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT o.office_name, o.city, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.office_id = o.office_id AND e.status = 'active') AS active_employees, (SELECT AVG(p.power_consumption_kwh) FROM office_power_usage p WHERE p.office_id = o.office_id AND p.reading_date BETWEEN '2023-01-01' AND '2023-12-31') AS avg_annual_power FROM offices o WHERE o.country = 'USA' AND o.square_footage > 5000 AND o.office_id NOT IN (SELECT DISTINCT ir.office_id FROM incident_reports ir WHERE ir.incident_date > '2023-01-01' AND ir.severity = 'High') AND EXISTS (SELECT 1 FROM office_amenities oa WHERE oa.office_id = o.office_id AND oa.amenity_type = 'Gym') ORDER BY active_employees DESC, avg_annual_power ASC LIMIT 10;","output":"WITH ActiveEmployees AS (SELECT office_id, COUNT(employee_id) AS active_employees FROM employees WHERE status = 'active' GROUP BY office_id), AnnualPowerUsage AS (SELECT office_id, AVG(power_consumption_kwh) AS avg_annual_power FROM office_power_usage WHERE reading_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY office_id) SELECT o.office_name, o.city, COALESCE(ae.active_employees, 0) AS active_employees, COALESCE(apu.avg_annual_power, 0) AS avg_annual_power FROM offices AS o LEFT JOIN ActiveEmployees AS ae ON o.office_id = ae.office_id LEFT JOIN AnnualPowerUsage AS apu ON o.office_id = apu.office_id LEFT JOIN incident_reports AS ir ON o.office_id = ir.office_id AND ir.incident_date > '2023-01-01' AND ir.severity = 'High' JOIN office_amenities AS oa ON o.office_id = oa.office_id WHERE o.country = 'USA' AND o.square_footage > 5000 AND ir.office_id IS NULL AND oa.amenity_type = 'Gym' ORDER BY active_employees DESC, avg_annual_power ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.continent_name, c.population, (SELECT AVG(gdp_per_capita) FROM countries co WHERE co.continent_id = c.continent_id) AS avg_gdp_continent, (SELECT MAX(life_expectancy) FROM countries co WHERE co.continent_id = c.continent_id) AS max_life_expectancy_continent FROM continents c WHERE c.area_sq_km > 10000000 AND c.continent_id NOT IN (SELECT DISTINCT dc.continent_id FROM disaster_events dc WHERE dc.event_date > '2023-01-01' AND dc.severity = 'High') ORDER BY avg_gdp_continent DESC, max_life_expectancy_continent DESC LIMIT 5;","output":"WITH ContinentStats AS (SELECT continent_id, AVG(gdp_per_capita) AS avg_gdp_continent, MAX(life_expectancy) AS max_life_expectancy_continent FROM countries GROUP BY continent_id) SELECT c.continent_name, c.population, cs.avg_gdp_continent, cs.max_life_expectancy_continent FROM continents AS c LEFT JOIN ContinentStats AS cs ON c.continent_id = cs.continent_id LEFT JOIN disaster_events AS de ON c.continent_id = de.continent_id AND de.event_date > '2023-01-01' AND de.severity = 'High' WHERE c.area_sq_km > 10000000 AND de.continent_id IS NULL ORDER BY avg_gdp_continent DESC, max_life_expectancy_continent DESC LIMIT 5;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.server_name, s.ip_address, (SELECT COUNT(l.log_id) FROM server_logs l WHERE l.server_id = s.server_id AND l.log_level = 'ERROR' AND l.log_timestamp > CURDATE() - INTERVAL 1 DAY) AS daily_errors, (SELECT MAX(m.cpu_usage) FROM server_metrics m WHERE m.server_id = s.server_id AND m.metric_timestamp > CURDATE() - INTERVAL 1 DAY) AS daily_max_cpu FROM servers s WHERE s.status = 'Online' AND s.location = 'Datacenter A' AND s.server_id NOT IN (SELECT d.server_id FROM server_downtime d WHERE d.downtime_start > CURDATE() - INTERVAL 7 DAY) AND EXISTS (SELECT 1 FROM server_configs sc WHERE sc.server_id = s.server_id AND sc.config_version = '2.1') ORDER BY daily_errors DESC, daily_max_cpu DESC LIMIT 10;","output":"WITH DailyErrors AS (SELECT server_id, COUNT(log_id) AS daily_errors FROM server_logs WHERE log_level = 'ERROR' AND log_timestamp > CURDATE() - INTERVAL 1 DAY GROUP BY server_id), DailyMaxCpu AS (SELECT server_id, MAX(cpu_usage) AS daily_max_cpu FROM server_metrics WHERE metric_timestamp > CURDATE() - INTERVAL 1 DAY GROUP BY server_id) SELECT s.server_name, s.ip_address, COALESCE(de.daily_errors, 0) AS daily_errors, COALESCE(dmc.daily_max_cpu, 0) AS daily_max_cpu FROM servers AS s LEFT JOIN DailyErrors AS de ON s.server_id = de.server_id LEFT JOIN DailyMaxCpu AS dmc ON s.server_id = dmc.server_id LEFT JOIN server_downtime AS sd ON s.server_id = sd.server_id AND sd.downtime_start > CURDATE() - INTERVAL 7 DAY JOIN server_configs AS sc ON s.server_id = sc.server_id WHERE s.status = 'Online' AND s.location = 'Datacenter A' AND sd.server_id IS NULL AND sc.config_version = '2.1' ORDER BY daily_errors DESC, daily_max_cpu DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT t.task_id, t.task_name, t.due_date, p.project_name FROM tasks t JOIN projects p ON t.project_id = p.project_id WHERE t.status = 'Pending' AND p.status = 'Active' AND t.due_date < CURDATE() + INTERVAL 7 DAY AND t.assigned_to_user_id IN (SELECT user_id FROM users WHERE department_id = (SELECT department_id FROM departments WHERE department_name = 'Development')) AND t.task_id NOT IN (SELECT sub.parent_task_id FROM subtasks sub WHERE sub.status = 'Blocked') ORDER BY t.due_date ASC, t.task_name ASC LIMIT 20;","output":"SELECT t.task_id, t.task_name, t.due_date, p.project_name FROM tasks AS t JOIN projects AS p ON t.project_id = p.project_id JOIN users AS u ON t.assigned_to_user_id = u.user_id JOIN departments AS d ON u.department_id = d.department_id LEFT JOIN subtasks AS sub ON t.task_id = sub.parent_task_id AND sub.status = 'Blocked' WHERE t.status = 'Pending' AND p.status = 'Active' AND t.due_date < CURDATE() + INTERVAL 7 DAY AND d.department_name = 'Development' AND sub.parent_task_id IS NULL ORDER BY t.due_date ASC, t.task_name ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.student_id, s.student_name, s.major, (SELECT COUNT(e.enrollment_id) FROM enrollments e WHERE e.student_id = s.student_id AND e.enrollment_date > '2022-09-01') AS recent_enrollments, (SELECT AVG(g.grade_value) FROM grades g WHERE g.student_id = s.student_id AND g.grade_date > '2022-09-01') AS avg_recent_grade FROM students s WHERE s.graduation_year = 2024 AND s.student_status = 'Active' AND s.student_id NOT IN (SELECT sd.student_id FROM student_disciplinary_actions sd WHERE sd.action_date > '2023-01-01' AND sd.severity = 'High') AND EXISTS (SELECT 1 FROM student_scholarships ss WHERE ss.student_id = s.student_id AND ss.scholarship_amount > 1000) ORDER BY recent_enrollments DESC, avg_recent_grade DESC LIMIT 15;","output":"WITH RecentEnrollments AS (SELECT student_id, COUNT(enrollment_id) AS recent_enrollments FROM enrollments WHERE enrollment_date > '2022-09-01' GROUP BY student_id), AvgRecentGrade AS (SELECT student_id, AVG(grade_value) AS avg_recent_grade FROM grades WHERE grade_date > '2022-09-01' GROUP BY student_id) SELECT s.student_id, s.student_name, s.major, COALESCE(re.recent_enrollments, 0) AS recent_enrollments, COALESCE(arg.avg_recent_grade, 0) AS avg_recent_grade FROM students AS s LEFT JOIN RecentEnrollments AS re ON s.student_id = re.student_id LEFT JOIN AvgRecentGrade AS arg ON s.student_id = arg.student_id LEFT JOIN student_disciplinary_actions AS sda ON s.student_id = sda.student_id AND sda.action_date > '2023-01-01' AND sda.severity = 'High' JOIN student_scholarships AS ss ON s.student_id = ss.student_id WHERE s.graduation_year = 2024 AND s.student_status = 'Active' AND sda.student_id IS NULL AND ss.scholarship_amount > 1000 ORDER BY recent_enrollments DESC, avg_recent_grade DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT p.patient_id, p.first_name, p.last_name, (SELECT MAX(va.visit_date) FROM patient_visits va WHERE va.patient_id = p.patient_id) AS last_visit_date, (SELECT COUNT(t.test_id) FROM medical_tests t WHERE t.patient_id = p.patient_id AND t.test_date > '2023-01-01' AND t.result = 'Abnormal') AS recent_abnormal_tests FROM patients p WHERE p.gender = 'Female' AND p.date_of_birth BETWEEN '1960-01-01' AND '1980-12-31' AND p.patient_id NOT IN (SELECT ad.patient_id FROM admission_details ad WHERE ad.admission_date > '2023-01-01' AND ad.diagnosis_code = 'C50') AND EXISTS (SELECT 1 FROM patient_medications pm WHERE pm.patient_id = p.patient_id AND pm.medication_status = 'Active') ORDER BY last_visit_date DESC, recent_abnormal_tests DESC LIMIT 10;","output":"WITH LastVisit AS (SELECT patient_id, MAX(visit_date) AS last_visit_date FROM patient_visits GROUP BY patient_id), RecentAbnormalTests AS (SELECT patient_id, COUNT(test_id) AS recent_abnormal_tests FROM medical_tests WHERE test_date > '2023-01-01' AND result = 'Abnormal' GROUP BY patient_id) SELECT p.patient_id, p.first_name, p.last_name, lv.last_visit_date, COALESCE(rat.recent_abnormal_tests, 0) AS recent_abnormal_tests FROM patients AS p LEFT JOIN LastVisit AS lv ON p.patient_id = lv.patient_id LEFT JOIN RecentAbnormalTests AS rat ON p.patient_id = rat.patient_id LEFT JOIN admission_details AS ad ON p.patient_id = ad.patient_id AND ad.admission_date > '2023-01-01' AND ad.diagnosis_code = 'C50' JOIN patient_medications AS pm ON p.patient_id = pm.patient_id WHERE p.gender = 'Female' AND p.date_of_birth BETWEEN '1960-01-01' AND '1980-12-31' AND ad.patient_id IS NULL AND pm.medication_status = 'Active' ORDER BY last_visit_date DESC, recent_abnormal_tests DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT h.hotel_name, h.city, (SELECT AVG(r.rating_score) FROM reviews r WHERE r.hotel_id = h.hotel_id AND r.review_date > '2023-01-01') AS avg_recent_rating, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.hotel_id = h.hotel_id AND b.check_in_date BETWEEN '2023-10-01' AND '2023-12-31') AS Q4_bookings FROM hotels h WHERE h.star_rating = 5 AND h.country = 'France' AND h.hotel_id NOT IN (SELECT co.hotel_id FROM hotel_closures co WHERE co.closure_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM hotel_amenities ha WHERE ha.hotel_id = h.hotel_id AND ha.amenity_type = 'Swimming Pool') ORDER BY avg_recent_rating DESC, Q4_bookings DESC LIMIT 10;","output":"WITH RecentRatings AS (SELECT hotel_id, AVG(rating_score) AS avg_recent_rating FROM reviews WHERE review_date > '2023-01-01' GROUP BY hotel_id), Q4Bookings AS (SELECT hotel_id, COUNT(booking_id) AS Q4_bookings FROM bookings WHERE check_in_date BETWEEN '2023-10-01' AND '2023-12-31' GROUP BY hotel_id) SELECT h.hotel_name, h.city, COALESCE(rr.avg_recent_rating, 0) AS avg_recent_rating, COALESCE(qb.Q4_bookings, 0) AS Q4_bookings FROM hotels AS h LEFT JOIN RecentRatings AS rr ON h.hotel_id = rr.hotel_id LEFT JOIN Q4Bookings AS qb ON h.hotel_id = qb.hotel_id LEFT JOIN hotel_closures AS hc ON h.hotel_id = hc.hotel_id AND hc.closure_end_date > CURDATE() JOIN hotel_amenities AS ha ON h.hotel_id = ha.hotel_id WHERE h.star_rating = 5 AND h.country = 'France' AND hc.hotel_id IS NULL AND ha.amenity_type = 'Swimming Pool' ORDER BY avg_recent_rating DESC, Q4_bookings DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT v.vehicle_make, v.vehicle_model, v.model_year, (SELECT COUNT(s.service_id) FROM service_records s WHERE s.vehicle_id = v.vehicle_id AND s.service_date > '2023-01-01') AS recent_services, (SELECT AVG(r.repair_cost) FROM repair_records r WHERE r.vehicle_id = v.vehicle_id AND r.repair_date > '2023-01-01') AS avg_recent_repair_cost FROM vehicles v WHERE v.mileage < 50000 AND v.vehicle_type = 'Sedan' AND v.model_year BETWEEN 2018 AND 2022 AND v.vehicle_id NOT IN (SELECT rr.vehicle_id FROM recall_records rr WHERE rr.recall_date > '2023-01-01') AND EXISTS (SELECT 1 FROM vehicle_owners vo WHERE vo.vehicle_id = v.vehicle_id AND vo.owner_type = 'First Owner') ORDER BY recent_services DESC, avg_recent_repair_cost DESC LIMIT 10;","output":"WITH RecentServices AS (SELECT vehicle_id, COUNT(service_id) AS recent_services FROM service_records WHERE service_date > '2023-01-01' GROUP BY vehicle_id), AvgRecentRepairCost AS (SELECT vehicle_id, AVG(repair_cost) AS avg_recent_repair_cost FROM repair_records WHERE repair_date > '2023-01-01' GROUP BY vehicle_id) SELECT v.vehicle_make, v.vehicle_model, v.model_year, COALESCE(rs.recent_services, 0) AS recent_services, COALESCE(arrc.avg_recent_repair_cost, 0) AS avg_recent_repair_cost FROM vehicles AS v LEFT JOIN RecentServices AS rs ON v.vehicle_id = rs.vehicle_id LEFT JOIN AvgRecentRepairCost AS arrc ON v.vehicle_id = arrc.vehicle_id LEFT JOIN recall_records AS rr ON v.vehicle_id = rr.vehicle_id AND rr.recall_date > '2023-01-01' JOIN vehicle_owners AS vo ON v.vehicle_id = vo.vehicle_id WHERE v.mileage < 50000 AND v.vehicle_type = 'Sedan' AND v.model_year BETWEEN 2018 AND 2022 AND rr.vehicle_id IS NULL AND vo.owner_type = 'First Owner' ORDER BY recent_services DESC, avg_recent_repair_cost DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.investor_name, inv.country, (SELECT SUM(t.amount) FROM transactions t WHERE t.investor_id = inv.investor_id AND t.transaction_type = 'Buy' AND t.transaction_date > '2023-01-01') AS total_buy_2023, (SELECT SUM(t.amount) FROM transactions t WHERE t.investor_id = inv.investor_id AND t.transaction_type = 'Sell' AND t.transaction_date > '2023-01-01') AS total_sell_2023 FROM investors inv WHERE inv.investment_strategy = 'Growth' AND inv.registration_date < '2020-01-01' AND inv.investor_id NOT IN (SELECT bl.investor_id FROM blacklist_investors bl WHERE bl.reason = 'Fraud') AND EXISTS (SELECT 1 FROM investor_portfolios ip WHERE ip.investor_id = inv.investor_id AND ip.asset_class = 'Stocks') ORDER BY total_buy_2023 DESC, total_sell_2023 DESC LIMIT 10;","output":"WITH InvestorBuys AS (SELECT investor_id, SUM(amount) AS total_buy_2023 FROM transactions WHERE transaction_type = 'Buy' AND transaction_date > '2023-01-01' GROUP BY investor_id), InvestorSells AS (SELECT investor_id, SUM(amount) AS total_sell_2023 FROM transactions WHERE transaction_type = 'Sell' AND transaction_date > '2023-01-01' GROUP BY investor_id) SELECT inv.investor_name, inv.country, COALESCE(ib.total_buy_2023, 0) AS total_buy_2023, COALESCE(is.total_sell_2023, 0) AS total_sell_2023 FROM investors AS inv LEFT JOIN InvestorBuys AS ib ON inv.investor_id = ib.investor_id LEFT JOIN InvestorSells AS is ON inv.investor_id = is.investor_id LEFT JOIN blacklist_investors AS bl ON inv.investor_id = bl.investor_id AND bl.reason = 'Fraud' JOIN investor_portfolios AS ip ON inv.investor_id = ip.investor_id WHERE inv.investment_strategy = 'Growth' AND inv.registration_date < '2020-01-01' AND bl.investor_id IS NULL AND ip.asset_class = 'Stocks' ORDER BY total_buy_2023 DESC, total_sell_2023 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.sensor_id, s.sensor_type, s.location, (SELECT AVG(d.reading_value) FROM sensor_data d WHERE d.sensor_id = s.sensor_id AND d.reading_date > CURDATE() - INTERVAL 1 DAY) AS avg_daily_reading, (SELECT MAX(d.reading_value) FROM sensor_data d WHERE d.sensor_id = s.sensor_id AND d.reading_date > CURDATE() - INTERVAL 1 DAY) AS max_daily_reading FROM sensors s WHERE s.status = 'Operational' AND s.deployment_date < '2023-01-01' AND s.sensor_id NOT IN (SELECT al.sensor_id FROM sensor_alerts al WHERE al.alert_level = 'Critical' AND al.alert_date > CURDATE() - INTERVAL 7 DAY) AND EXISTS (SELECT 1 FROM sensor_maintenance sm WHERE sm.sensor_id = s.sensor_id AND sm.maintenance_type = 'Calibration' AND sm.next_maintenance_date < CURDATE() + INTERVAL 30 DAY) ORDER BY avg_daily_reading DESC, max_daily_reading DESC LIMIT 10;","output":"WITH DailyReadings AS (SELECT sensor_id, AVG(reading_value) AS avg_daily_reading, MAX(reading_value) AS max_daily_reading FROM sensor_data WHERE reading_date > CURDATE() - INTERVAL 1 DAY GROUP BY sensor_id) SELECT s.sensor_id, s.sensor_type, s.location, COALESCE(dr.avg_daily_reading, 0) AS avg_daily_reading, COALESCE(dr.max_daily_reading, 0) AS max_daily_reading FROM sensors AS s LEFT JOIN DailyReadings AS dr ON s.sensor_id = dr.sensor_id LEFT JOIN sensor_alerts AS sa ON s.sensor_id = sa.sensor_id AND sa.alert_level = 'Critical' AND sa.alert_date > CURDATE() - INTERVAL 7 DAY JOIN sensor_maintenance AS sm ON s.sensor_id = sm.sensor_id WHERE s.status = 'Operational' AND s.deployment_date < '2023-01-01' AND sa.sensor_id IS NULL AND sm.maintenance_type = 'Calibration' AND sm.next_maintenance_date < CURDATE() + INTERVAL 30 DAY ORDER BY avg_daily_reading DESC, max_daily_reading DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_id, c.campaign_name, c.start_date, (SELECT SUM(cm.clicks) FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-06-30') AS Q2_clicks, (SELECT AVG(cm.conversion_rate) FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-06-30') AS Q2_avg_conversion_rate FROM campaigns c WHERE c.campaign_type = 'Social Media' AND c.status = 'Completed' AND c.budget > 10000 AND c.campaign_id NOT IN (SELECT fr.campaign_id FROM fraud_reports fr WHERE fr.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM campaign_goals cg WHERE cg.campaign_id = c.campaign_id AND cg.goal_met = TRUE) ORDER BY Q2_clicks DESC, Q2_avg_conversion_rate DESC LIMIT 10;","output":"WITH Q2Metrics AS (SELECT campaign_id, SUM(clicks) AS Q2_clicks, AVG(conversion_rate) AS Q2_avg_conversion_rate FROM campaign_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY campaign_id) SELECT c.campaign_id, c.campaign_name, c.start_date, COALESCE(qm.Q2_clicks, 0) AS Q2_clicks, COALESCE(qm.Q2_avg_conversion_rate, 0) AS Q2_avg_conversion_rate FROM campaigns AS c LEFT JOIN Q2Metrics AS qm ON c.campaign_id = qm.campaign_id LEFT JOIN fraud_reports AS fr ON c.campaign_id = fr.campaign_id AND fr.report_date > '2023-01-01' JOIN campaign_goals AS cg ON c.campaign_id = cg.campaign_id WHERE c.campaign_type = 'Social Media' AND c.status = 'Completed' AND c.budget > 10000 AND fr.campaign_id IS NULL AND cg.goal_met = TRUE ORDER BY Q2_clicks DESC, Q2_avg_conversion_rate DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, u.registration_date, COUNT(p.post_id) AS total_posts, AVG(p.likes) AS avg_likes_per_post FROM users u LEFT JOIN posts p ON u.user_id = p.user_id WHERE u.status = 'active' AND u.registration_date > '2022-01-01' AND p.created_at > '2023-01-01' AND u.user_id NOT IN (SELECT sp.user_id FROM suspended_users sp WHERE sp.suspension_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM user_roles ur JOIN roles r ON ur.role_id = r.role_id WHERE ur.user_id = u.user_id AND r.role_name = 'Content Creator') GROUP BY u.user_id, u.username, u.registration_date HAVING COUNT(p.post_id) > 10 AND AVG(p.likes) > 50 ORDER BY total_posts DESC, avg_likes_per_post DESC LIMIT 20;","output":"SELECT u.user_id, u.username, u.registration_date, COUNT(p.post_id) AS total_posts, AVG(p.likes) AS avg_likes_per_post FROM users AS u LEFT JOIN posts AS p ON u.user_id = p.user_id LEFT JOIN suspended_users AS su ON u.user_id = su.user_id AND su.suspension_end_date > CURDATE() JOIN user_roles AS ur ON u.user_id = ur.user_id JOIN roles AS r ON ur.role_id = r.role_id WHERE u.status = 'active' AND u.registration_date > '2022-01-01' AND p.created_at > '2023-01-01' AND su.user_id IS NULL AND r.role_name = 'Content Creator' GROUP BY u.user_id, u.username, u.registration_date HAVING COUNT(p.post_id) > 10 AND AVG(p.likes) > 50 ORDER BY total_posts DESC, avg_likes_per_post DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.price, p.stock_quantity, c.category_name, (SELECT AVG(pr.rating) FROM product_reviews pr WHERE pr.product_id = p.product_id) AS average_rating, (SELECT COUNT(oi.order_item_id) FROM order_items oi WHERE oi.product_id = p.product_id AND oi.order_id IN (SELECT order_id FROM orders WHERE order_date > '2023-01-01')) AS sales_2023 FROM products p JOIN categories c ON p.category_id = c.category_id WHERE p.price > 50 AND p.stock_quantity > 0 AND c.category_name IN ('Electronics', 'Home Goods') AND p.product_id NOT IN (SELECT cp.product_id FROM discontinued_products cp WHERE cp.discontinuation_date > '2023-01-01') ORDER BY average_rating DESC, sales_2023 DESC LIMIT 25;","output":"WITH ProductRatings AS (SELECT product_id, AVG(rating) AS average_rating FROM product_reviews GROUP BY product_id), Sales2023 AS (SELECT oi.product_id, COUNT(oi.order_item_id) AS sales_2023 FROM order_items AS oi JOIN orders AS o ON oi.order_id = o.order_id WHERE o.order_date > '2023-01-01' GROUP BY oi.product_id) SELECT p.product_id, p.product_name, p.price, p.stock_quantity, c.category_name, COALESCE(pr.average_rating, 0) AS average_rating, COALESCE(s23.sales_2023, 0) AS sales_2023 FROM products AS p JOIN categories AS c ON p.category_id = c.category_id LEFT JOIN ProductRatings AS pr ON p.product_id = pr.product_id LEFT JOIN Sales2023 AS s23 ON p.product_id = s23.product_id LEFT JOIN discontinued_products AS dp ON p.product_id = dp.product_id AND dp.discontinuation_date > '2023-01-01' WHERE p.price > 50 AND p.stock_quantity > 0 AND c.category_name IN ('Electronics', 'Home Goods') AND dp.product_id IS NULL ORDER BY average_rating DESC, sales_2023 DESC LIMIT 25;"}
{"instruction":"Optimize the SQL query","input":"SELECT e.event_id, e.event_name, e.event_date, e.location, COUNT(t.ticket_id) AS total_tickets_sold, SUM(t.price) AS total_revenue FROM events e LEFT JOIN tickets t ON e.event_id = t.event_id WHERE e.event_date BETWEEN '2024-01-01' AND '2024-06-30' AND e.event_type = 'Concert' AND e.event_id NOT IN (SELECT ce.event_id FROM cancelled_events ce WHERE ce.cancellation_date < CURDATE()) AND EXISTS (SELECT 1 FROM event_performers ep JOIN performers p ON ep.performer_id = p.performer_id WHERE ep.event_id = e.event_id AND p.genre = 'Rock') GROUP BY e.event_id, e.event_name, e.event_date, e.location HAVING COUNT(t.ticket_id) > 100 AND SUM(t.price) > 5000 ORDER BY total_revenue DESC, total_tickets_sold DESC LIMIT 15;","output":"SELECT e.event_id, e.event_name, e.event_date, e.location, COUNT(t.ticket_id) AS total_tickets_sold, SUM(t.price) AS total_revenue FROM events AS e LEFT JOIN tickets AS t ON e.event_id = t.event_id LEFT JOIN cancelled_events AS ce ON e.event_id = ce.event_id AND ce.cancellation_date < CURDATE() JOIN event_performers AS ep ON e.event_id = ep.event_id JOIN performers AS p ON ep.performer_id = p.performer_id WHERE e.event_date BETWEEN '2024-01-01' AND '2024-06-30' AND e.event_type = 'Concert' AND ce.event_id IS NULL AND p.genre = 'Rock' GROUP BY e.event_id, e.event_name, e.event_date, e.location HAVING COUNT(t.ticket_id) > 100 AND SUM(t.price) > 5000 ORDER BY total_revenue DESC, total_tickets_sold DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT d.drug_id, d.drug_name, d.manufacturer, d.expiration_date FROM drugs d WHERE d.is_controlled = TRUE AND d.stock_quantity < 100 AND d.expiration_date BETWEEN CURDATE() AND CURDATE() + INTERVAL 6 MONTH AND d.drug_id IN (SELECT DISTINCT rs.drug_id FROM drug_reorder_suggestions rs WHERE rs.suggestion_date > CURDATE() - INTERVAL 30 DAY AND rs.priority = 'High') AND NOT EXISTS (SELECT 1 FROM drug_approvals da WHERE da.drug_id = d.drug_id AND da.approval_status = 'Pending') ORDER BY d.expiration_date ASC, d.drug_name ASC LIMIT 20;","output":"SELECT d.drug_id, d.drug_name, d.manufacturer, d.expiration_date FROM drugs AS d JOIN drug_reorder_suggestions AS drs ON d.drug_id = drs.drug_id LEFT JOIN drug_approvals AS da ON d.drug_id = da.drug_id WHERE d.is_controlled = TRUE AND d.stock_quantity < 100 AND d.expiration_date BETWEEN CURDATE() AND CURDATE() + INTERVAL 6 MONTH AND drs.suggestion_date > CURDATE() - INTERVAL 30 DAY AND drs.priority = 'High' AND (da.drug_id IS NULL OR da.approval_status != 'Pending') ORDER BY d.expiration_date ASC, d.drug_name ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT f.flight_number, f.departure_airport_code, f.arrival_airport_code, f.departure_time, (SELECT COUNT(p.passenger_id) FROM bookings b JOIN passengers p ON b.passenger_id = p.passenger_id WHERE b.flight_id = f.flight_id AND b.booking_status = 'Confirmed') AS confirmed_passengers, (SELECT AVG(pr.price) FROM prices pr WHERE pr.flight_id = f.flight_id AND pr.price_date = CURDATE()) AS current_avg_price FROM flights f WHERE f.flight_date = CURDATE() + INTERVAL 7 DAY AND f.status = 'Scheduled' AND f.airline_id IN (SELECT airline_id FROM airlines WHERE airline_country = 'USA') AND f.flight_id NOT IN (SELECT dl.flight_id FROM delayed_flights dl WHERE dl.delay_reason = 'Technical') ORDER BY confirmed_passengers DESC, current_avg_price DESC LIMIT 15;","output":"WITH ConfirmedPassengers AS (SELECT b.flight_id, COUNT(p.passenger_id) AS confirmed_passengers FROM bookings AS b JOIN passengers AS p ON b.passenger_id = p.passenger_id WHERE b.booking_status = 'Confirmed' GROUP BY b.flight_id), CurrentAvgPrice AS (SELECT flight_id, AVG(price) AS current_avg_price FROM prices WHERE price_date = CURDATE() GROUP BY flight_id) SELECT f.flight_number, f.departure_airport_code, f.arrival_airport_code, f.departure_time, COALESCE(cp.confirmed_passengers, 0) AS confirmed_passengers, COALESCE(cap.current_avg_price, 0) AS current_avg_price FROM flights AS f LEFT JOIN ConfirmedPassengers AS cp ON f.flight_id = cp.flight_id LEFT JOIN CurrentAvgPrice AS cap ON f.flight_id = cap.flight_id JOIN airlines AS al ON f.airline_id = al.airline_id LEFT JOIN delayed_flights AS df ON f.flight_id = df.flight_id AND df.delay_reason = 'Technical' WHERE f.flight_date = CURDATE() + INTERVAL 7 DAY AND f.status = 'Scheduled' AND al.airline_country = 'USA' AND df.flight_id IS NULL ORDER BY confirmed_passengers DESC, current_avg_price DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT ch.chapter_title, ch.chapter_number, b.book_title, b.author FROM chapters ch JOIN books b ON ch.book_id = b.book_id WHERE b.publication_year BETWEEN 2010 AND 2020 AND b.genre = 'Fantasy' AND ch.chapter_id NOT IN (SELECT pr.chapter_id FROM problem_reports pr WHERE pr.report_date > '2023-01-01' AND pr.severity = 'High') AND EXISTS (SELECT 1 FROM chapter_keywords ck WHERE ck.chapter_id = ch.chapter_id AND ck.keyword = 'Magic') ORDER BY ch.chapter_number ASC, b.book_title ASC LIMIT 20;","output":"SELECT ch.chapter_title, ch.chapter_number, b.book_title, b.author FROM chapters AS ch JOIN books AS b ON ch.book_id = b.book_id LEFT JOIN problem_reports AS pr ON ch.chapter_id = pr.chapter_id AND pr.report_date > '2023-01-01' AND pr.severity = 'High' JOIN chapter_keywords AS ck ON ch.chapter_id = ck.chapter_id WHERE b.publication_year BETWEEN 2010 AND 2020 AND b.genre = 'Fantasy' AND pr.chapter_id IS NULL AND ck.keyword = 'Magic' ORDER BY ch.chapter_number ASC, b.book_title ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT d.device_name, d.device_type, d.last_seen FROM devices d WHERE d.status = 'Online' AND d.location = 'Server Room 1' AND d.device_id NOT IN (SELECT ir.device_id FROM incident_reports ir WHERE ir.incident_date > '2023-01-01' AND ir.impact = 'Critical') AND EXISTS (SELECT 1 FROM device_firmware df WHERE df.device_id = d.device_id AND df.firmware_version = '1.2.0') AND d.last_seen > CURDATE() - INTERVAL 1 HOUR ORDER BY d.last_seen DESC, d.device_name ASC LIMIT 10;","output":"SELECT d.device_name, d.device_type, d.last_seen FROM devices AS d LEFT JOIN incident_reports AS ir ON d.device_id = ir.device_id AND ir.incident_date > '2023-01-01' AND ir.impact = 'Critical' JOIN device_firmware AS df ON d.device_id = df.device_id WHERE d.status = 'Online' AND d.location = 'Server Room 1' AND df.firmware_version = '1.2.0' AND d.last_seen > CURDATE() - INTERVAL 1 HOUR AND ir.device_id IS NULL ORDER BY d.last_seen DESC, d.device_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.sensor_id, s.sensor_type, s.deployment_date FROM sensors s WHERE s.status = 'Active' AND s.location = 'Outdoor' AND s.sensor_id IN (SELECT md.sensor_id FROM measurement_data md WHERE md.measurement_value > 100 AND md.measurement_date > '2023-01-01' GROUP BY md.sensor_id HAVING COUNT(md.data_id) > 1000) AND EXISTS (SELECT 1 FROM sensor_alerts sa WHERE sa.sensor_id = s.sensor_id AND sa.alert_type = 'High Value' AND sa.alert_date > '2023-01-01') ORDER BY s.deployment_date ASC, s.sensor_type ASC LIMIT 15;","output":"SELECT s.sensor_id, s.sensor_type, s.deployment_date FROM sensors AS s JOIN (SELECT sensor_id FROM measurement_data WHERE measurement_value > 100 AND measurement_date > '2023-01-01' GROUP BY sensor_id HAVING COUNT(data_id) > 1000) AS high_value_sensors ON s.sensor_id = high_value_sensors.sensor_id JOIN sensor_alerts AS sa ON s.sensor_id = sa.sensor_id WHERE s.status = 'Active' AND s.location = 'Outdoor' AND sa.alert_type = 'High Value' AND sa.alert_date > '2023-01-01' ORDER BY s.deployment_date ASC, s.sensor_type ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT t.team_name, t.team_lead, (SELECT COUNT(p.player_id) FROM players p WHERE p.team_id = t.team_id AND p.status = 'Active') AS active_players_count, (SELECT AVG(p.skill_rating) FROM players p WHERE p.team_id = t.team_id) AS avg_team_skill_rating FROM teams t WHERE t.league = 'Premier League' AND t.founding_year < 2000 AND t.team_id NOT IN (SELECT fp.team_id FROM financial_penalties fp WHERE fp.penalty_date > '2023-01-01' AND fp.penalty_amount > 10000) ORDER BY active_players_count DESC, avg_team_skill_rating DESC LIMIT 10;","output":"WITH TeamStats AS (SELECT team_id, COUNT(player_id) AS active_players_count, AVG(skill_rating) AS avg_team_skill_rating FROM players WHERE status = 'Active' GROUP BY team_id) SELECT t.team_name, t.team_lead, COALESCE(ts.active_players_count, 0) AS active_players_count, COALESCE(ts.avg_team_skill_rating, 0) AS avg_team_skill_rating FROM teams AS t LEFT JOIN TeamStats AS ts ON t.team_id = ts.team_id LEFT JOIN financial_penalties AS fp ON t.team_id = fp.team_id AND fp.penalty_date > '2023-01-01' AND fp.penalty_amount > 10000 WHERE t.league = 'Premier League' AND t.founding_year < 2000 AND fp.team_id IS NULL ORDER BY active_players_count DESC, avg_team_skill_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT f.forum_name, f.category, (SELECT COUNT(th.thread_id) FROM forum_threads th WHERE th.forum_id = f.forum_id AND th.created_date > '2023-01-01') AS new_threads_2023, (SELECT MAX(th.last_post_date) FROM forum_threads th WHERE th.forum_id = f.forum_id) AS last_activity_date FROM forums f WHERE f.status = 'Active' AND f.creation_date < '2020-01-01' AND f.forum_id NOT IN (SELECT fa.forum_id FROM forum_abuse_reports fa WHERE fa.report_date > '2023-01-01' AND fa.severity = 'High') AND EXISTS (SELECT 1 FROM forum_moderators fm WHERE fm.forum_id = f.forum_id AND fm.moderator_level = 'Admin') ORDER BY new_threads_2023 DESC, last_activity_date DESC LIMIT 10;","output":"WITH ForumThreadStats AS (SELECT forum_id, COUNT(thread_id) AS new_threads_2023, MAX(last_post_date) AS last_activity_date FROM forum_threads WHERE created_date > '2023-01-01' GROUP BY forum_id) SELECT f.forum_name, f.category, COALESCE(fts.new_threads_2023, 0) AS new_threads_2023, fts.last_activity_date FROM forums AS f LEFT JOIN ForumThreadStats AS fts ON f.forum_id = fts.forum_id LEFT JOIN forum_abuse_reports AS far ON f.forum_id = far.forum_id AND far.report_date > '2023-01-01' AND far.severity = 'High' JOIN forum_moderators AS fm ON f.forum_id = fm.forum_id WHERE f.status = 'Active' AND f.creation_date < '2020-01-01' AND far.forum_id IS NULL AND fm.moderator_level = 'Admin' ORDER BY new_threads_2023 DESC, last_activity_date DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.playlist_name, p.creation_date, u.username FROM playlists p JOIN users u ON p.user_id = u.user_id WHERE p.is_public = TRUE AND u.country = 'USA' AND p.creation_date > '2023-01-01' AND p.playlist_id IN (SELECT pt.playlist_id FROM playlist_tracks pt WHERE pt.track_id IN (SELECT t.track_id FROM tracks t WHERE t.genre = 'Electronic' AND t.duration > 300)) AND NOT EXISTS (SELECT 1 FROM playlist_reports pr WHERE pr.playlist_id = p.playlist_id AND pr.report_type = 'Copyright Infringement') ORDER BY p.creation_date DESC, p.playlist_name ASC LIMIT 10;","output":"SELECT p.playlist_name, p.creation_date, u.username FROM playlists AS p JOIN users AS u ON p.user_id = u.user_id JOIN playlist_tracks AS pt ON p.playlist_id = pt.playlist_id JOIN tracks AS t ON pt.track_id = t.track_id LEFT JOIN playlist_reports AS pr ON p.playlist_id = pr.playlist_id AND pr.report_type = 'Copyright Infringement' WHERE p.is_public = TRUE AND u.country = 'USA' AND p.creation_date > '2023-01-01' AND t.genre = 'Electronic' AND t.duration > 300 AND pr.playlist_id IS NULL ORDER BY p.creation_date DESC, p.playlist_name ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, u.email, u.first_name, u.last_name, u.registration_date, u.last_login, u.account_status, p.phone_number, p.phone_type, a.address_line1, a.address_line2, a.city, a.state, a.postal_code, a.country, pref.preference_name, pref.preference_value, sub.subscription_type, sub.subscription_status, sub.renewal_date, pay.payment_method, pay.card_last_four, pay.expiry_date, ord.order_count, ord.total_spent, ord.last_order_date, rev.review_count, rev.average_rating, sup.support_tickets, sup.last_ticket_date, not.notification_preferences, not.marketing_consent FROM users u LEFT JOIN user_phones p ON u.user_id = p.user_id LEFT JOIN user_addresses a ON u.user_id = a.user_id LEFT JOIN user_preferences pref ON u.user_id = pref.user_id LEFT JOIN user_subscriptions sub ON u.user_id = sub.user_id LEFT JOIN user_payment_methods pay ON u.user_id = pay.user_id LEFT JOIN (SELECT user_id, COUNT(*) as order_count, SUM(total_amount) as total_spent, MAX(order_date) as last_order_date FROM orders GROUP BY user_id) ord ON u.user_id = ord.user_id LEFT JOIN (SELECT user_id, COUNT(*) as review_count, AVG(rating) as average_rating FROM reviews GROUP BY user_id) rev ON u.user_id = rev.user_id LEFT JOIN (SELECT user_id, COUNT(*) as support_tickets, MAX(created_date) as last_ticket_date FROM support_tickets GROUP BY user_id) sup ON u.user_id = sup.user_id LEFT JOIN user_notifications not ON u.user_id = not.user_id WHERE u.registration_date > '2022-01-01' AND u.account_status = 'active' AND u.last_login > '2023-06-01' AND sub.subscription_status = 'active' AND pay.payment_method IS NOT NULL AND ord.order_count > 5 AND ord.total_spent > 1000 AND rev.average_rating >= 4.0 AND sup.support_tickets < 3 AND not.marketing_consent = TRUE ORDER BY ord.total_spent DESC, u.registration_date DESC LIMIT 50 OFFSET 0","output":"SELECT u.user_id, u.username, u.email, u.first_name, u.last_name, u.registration_date, u.last_login, u.account_status, p.phone_number, p.phone_type, a.address_line1, a.address_line2, a.city, a.state, a.postal_code, a.country, pref.preference_name, pref.preference_value, sub.subscription_type, sub.subscription_status, sub.renewal_date, pay.payment_method, pay.card_last_four, pay.expiry_date, ord.order_count, ord.total_spent, ord.last_order_date, rev.review_count, rev.average_rating, sup.support_tickets, sup.last_ticket_date, not.notification_preferences, not.marketing_consent FROM users u LEFT JOIN user_phones p ON u.user_id = p.user_id LEFT JOIN user_addresses a ON u.user_id = a.user_id LEFT JOIN user_preferences pref ON u.user_id = pref.user_id LEFT JOIN user_subscriptions sub ON u.user_id = sub.user_id LEFT JOIN user_payment_methods pay ON u.user_id = pay.user_id LEFT JOIN (SELECT user_id, COUNT(*) as order_count, SUM(total_amount) as total_spent, MAX(order_date) as last_order_date FROM orders GROUP BY user_id) ord ON u.user_id = ord.user_id LEFT JOIN (SELECT user_id, COUNT(*) as review_count, AVG(rating) as average_rating FROM reviews GROUP BY user_id) rev ON u.user_id = rev.user_id LEFT JOIN (SELECT user_id, COUNT(*) as support_tickets, MAX(created_date) as last_ticket_date FROM support_tickets GROUP BY user_id) sup ON u.user_id = sup.user_id LEFT JOIN user_notifications not ON u.user_id = not.user_id WHERE u.registration_date > '2022-01-01' AND u.account_status = 'active' AND u.last_login > '2023-06-01' AND sub.subscription_status = 'active' AND pay.payment_method IS NOT NULL AND ord.order_count > 5 AND ord.total_spent > 1000 AND rev.average_rating >= 4.0 AND sup.support_tickets < 3 AND not.marketing_consent = true ORDER BY ord.total_spent DESC, u.registration_date DESC LIMIT 50"}
{"instruction":"Optimize the SQL query","input":"SELECT emp.employee_id, emp.first_name, emp.last_name, emp.email, emp.department, emp.position, emp.salary, emp.hire_date, emp.employment_type, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, d.department_head, l.office_name, l.city, l.country, s.skill_name, s.skill_level, p.project_name, p.project_status, r.role_name, r.responsibilities, t.team_name, t.team_leader, per.performance_rating, per.review_date, per.reviewer_name, sal.salary_amount, sal.effective_date, sal.salary_type, ben.benefit_name, ben.coverage_amount, ben.provider, att.attendance_date, att.hours_worked, att.overtime_hours, att.absence_reason, vac.vacation_days_used, vac.vacation_days_remaining, vac.sick_days_used, train.training_name, train.completion_date, train.certification_status FROM employees emp LEFT JOIN employees m ON emp.manager_id = m.employee_id JOIN departments d ON emp.department_id = d.department_id JOIN locations l ON emp.location_id = l.location_id JOIN employee_skills es ON emp.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON emp.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id JOIN teams t ON emp.team_id = t.team_id JOIN performance_reviews per ON emp.employee_id = per.employee_id JOIN salary_history sal ON emp.employee_id = sal.employee_id JOIN benefits ben ON emp.employee_id = ben.employee_id JOIN attendance_records att ON emp.employee_id = att.employee_id JOIN vacation_balances vac ON emp.employee_id = vac.employee_id JOIN training_records train ON emp.employee_id = train.employee_id WHERE emp.salary > 80000 AND emp.hire_date > '2019-01-01' AND emp.employment_type = 'full_time' AND d.department_name IN ('Engineering', 'Data Science', 'Product', 'UX/UI') AND l.country = 'USA' AND s.skill_level >= 4 AND p.project_status = 'active' AND r.role_name IN ('Senior', 'Lead', 'Architect', 'Manager') AND t.team_size > 5 AND per.performance_rating >= 4.2 AND sal.salary_amount > 85000 AND ben.coverage_amount > 50000 AND att.hours_worked > 160 AND vac.vacation_days_remaining > 7 AND train.certification_status = 'completed' ORDER BY emp.salary DESC, per.performance_rating DESC, emp.hire_date DESC LIMIT 40 OFFSET 0","output":"SELECT emp.employee_id, emp.first_name, emp.last_name, emp.email, emp.department, emp.position, emp.salary, emp.hire_date, emp.employment_type, m.first_name AS manager_first, m.last_name AS manager_last, d.department_name, d.department_head, l.office_name, l.city, l.country, s.skill_name, s.skill_level, p.project_name, p.project_status, r.role_name, r.responsibilities, t.team_name, t.team_leader, per.performance_rating, per.review_date, per.reviewer_name, sal.salary_amount, sal.effective_date, sal.salary_type, ben.benefit_name, ben.coverage_amount, ben.provider, att.attendance_date, att.hours_worked, att.overtime_hours, att.absence_reason, vac.vacation_days_used, vac.vacation_days_remaining, vac.sick_days_used, train.training_name, train.completion_date, train.certification_status FROM employees emp LEFT JOIN employees m ON emp.manager_id = m.employee_id JOIN departments d ON emp.department_id = d.department_id JOIN locations l ON emp.location_id = l.location_id JOIN employee_skills es ON emp.employee_id = es.employee_id JOIN skills s ON es.skill_id = s.skill_id JOIN project_assignments pa ON emp.employee_id = pa.employee_id JOIN projects p ON pa.project_id = p.project_id JOIN roles r ON pa.role_id = r.role_id JOIN teams t ON emp.team_id = t.team_id JOIN performance_reviews per ON emp.employee_id = per.employee_id JOIN salary_history sal ON emp.employee_id = sal.employee_id JOIN benefits ben ON emp.employee_id = ben.employee_id JOIN attendance_records att ON emp.employee_id = att.employee_id JOIN vacation_balances vac ON emp.employee_id = vac.employee_id JOIN training_records train ON emp.employee_id = train.employee_id WHERE emp.salary > 80000 AND emp.hire_date > '2019-01-01' AND emp.employment_type = 'full_time' AND d.department_name IN ('Engineering', 'Data Science', 'Product', 'UX/UI') AND l.country = 'USA' AND s.skill_level >= 4 AND p.project_status = 'active' AND r.role_name IN ('Senior', 'Lead', 'Architect', 'Manager') AND t.team_size > 5 AND per.performance_rating >= 4.2 AND sal.salary_amount > 85000 AND ben.coverage_amount > 50000 AND att.hours_worked > 160 AND vac.vacation_days_remaining > 7 AND train.certification_status = 'completed' ORDER BY emp.salary DESC, per.performance_rating DESC, emp.hire_date DESC LIMIT 40"}
{"instruction":"Optimize the SQL query","input":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.sku, inv.upc_code, inv.current_quantity, inv.min_quantity, inv.max_quantity, inv.unit_cost, inv.total_value, inv.reorder_point, wh.warehouse_name, wh.location, wh.capacity_sqft, wh.manager_name, s.supplier_name, s.contact_person, s.contact_email, s.phone_number, s.supplier_rating, cat.category_name, cat.category_description, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reference_number, emp.employee_name, aud.audit_date, aud.audit_result, aud.auditor_name, ord.po_number, ord.order_quantity, ord.order_date, ord.expected_delivery, sup.unit_cost AS supply_cost, sup.min_order_quantity, sup.lead_time_days, qua.quality_score, qua.inspection_date, qua.inspector_name, ser.service_history, ser.last_service_date, ser.next_service_date, war.warranty_period, war.warranty_status, war.warranty_expiry FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN purchase_orders ord ON inv.inventory_id = ord.inventory_id LEFT JOIN supplier_costs sup ON inv.supplier_id = sup.supplier_id LEFT JOIN quality_controls qua ON inv.inventory_id = qua.inventory_id LEFT JOIN service_history ser ON inv.inventory_id = ser.inventory_id LEFT JOIN warranty_info war ON inv.inventory_id = war.inventory_id WHERE inv.current_quantity < inv.reorder_point AND inv.unit_cost > 15.00 AND wh.capacity_sqft > 10000 AND s.supplier_rating >= 4.5 AND cat.category_name IN ('Electronics', 'Mechanical', 'Electrical') AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-04-01' AND aud.audit_result = 'passed' AND ord.order_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND sup.lead_time_days < 10 AND qua.quality_score >= 95 AND ser.next_service_date > CURRENT_DATE AND war.warranty_status = 'active' ORDER BY inv.current_quantity ASC, inv.unit_cost DESC, sup.lead_time_days ASC LIMIT 70 OFFSET 0","output":"SELECT inv.inventory_id, inv.item_name, inv.description, inv.sku, inv.upc_code, inv.current_quantity, inv.min_quantity, inv.max_quantity, inv.unit_cost, inv.total_value, inv.reorder_point, wh.warehouse_name, wh.location, wh.capacity_sqft, wh.manager_name, s.supplier_name, s.contact_person, s.contact_email, s.phone_number, s.supplier_rating, cat.category_name, cat.category_description, sub.subcategory_name, mov.movement_type, mov.quantity, mov.movement_date, mov.reference_number, emp.employee_name, aud.audit_date, aud.audit_result, aud.auditor_name, ord.po_number, ord.order_quantity, ord.order_date, ord.expected_delivery, sup.unit_cost AS supply_cost, sup.min_order_quantity, sup.lead_time_days, qua.quality_score, qua.inspection_date, qua.inspector_name, ser.service_history, ser.last_service_date, ser.next_service_date, war.warranty_period, war.warranty_status, war.warranty_expiry FROM inventory inv JOIN warehouses wh ON inv.warehouse_id = wh.warehouse_id JOIN suppliers s ON inv.supplier_id = s.supplier_id JOIN categories cat ON inv.category_id = cat.category_id JOIN subcategories sub ON inv.subcategory_id = sub.subcategory_id LEFT JOIN inventory_movements mov ON inv.inventory_id = mov.inventory_id LEFT JOIN employees emp ON mov.employee_id = emp.employee_id LEFT JOIN inventory_audits aud ON inv.inventory_id = aud.inventory_id LEFT JOIN purchase_orders ord ON inv.inventory_id = ord.inventory_id LEFT JOIN supplier_costs sup ON inv.supplier_id = sup.supplier_id LEFT JOIN quality_controls qua ON inv.inventory_id = qua.inventory_id LEFT JOIN service_history ser ON inv.inventory_id = ser.inventory_id LEFT JOIN warranty_info war ON inv.inventory_id = war.inventory_id WHERE inv.current_quantity < inv.reorder_point AND inv.unit_cost > 15.00 AND wh.capacity_sqft > 10000 AND s.supplier_rating >= 4.5 AND cat.category_name IN ('Electronics', 'Mechanical', 'Electrical') AND mov.movement_type = 'outbound' AND mov.movement_date > '2023-04-01' AND aud.audit_result = 'passed' AND ord.order_date IS NOT NULL AND ord.expected_delivery > CURRENT_DATE AND sup.lead_time_days < 10 AND qua.quality_score >= 95 AND ser.next_service_date > CURRENT_DATE AND war.warranty_status = 'active' ORDER BY inv.current_quantity ASC, inv.unit_cost DESC, sup.lead_time_days ASC LIMIT 70"}
{"instruction":"Optimize the SQL query","input":"SELECT loan.loan_id, loan.loan_amount, loan.interest_rate, loan.start_date, loan.end_date, loan.term_months, loan.loan_purpose, loan.loan_status, c.customer_id, c.customer_name, c.credit_score, c.annual_income, c.employment_status, c.years_at_current_job, e.employee_id, e.employee_name, e.department, br.branch_id, br.branch_name, br.branch_region, pt.payment_terms, pt.number_of_payments, pt.payment_frequency, sch.due_date, sch.amount_due, sch.principal_amount, sch.interest_amount, sch.payment_status, coll.collection_stage, coll.collection_status, coll.collection_amount, coll.collector_name, risk.risk_level, risk.risk_score, risk.probability_of_default, doc.document_name, doc.document_status, doc.verification_date, ins.insurance_coverage, ins.insurance_provider, ins.policy_number, g.guarantor_name, g.guarantor_relationship, g.guarantor_income, g.guarantor_credit_score, sec.collateral_type, sec.collateral_value, sec.collateral_description FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.loan_officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_terms_id = pt.terms_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id LEFT JOIN guarantors g ON loan.loan_id = g.loan_id LEFT JOIN security_collateral sec ON loan.loan_id = sec.loan_id WHERE loan.loan_amount > 40000.00 AND loan.interest_rate < 6.75 AND loan.start_date > '2020-07-01' AND loan.loan_status = 'active' AND c.credit_score > 750 AND c.annual_income > 85000 AND e.department = 'consumer_lending' AND br.branch_region IN ('west', 'southwest') AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-11-01' AND '2024-02-29' AND coll.collection_status = 'in_progress' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_coverage > loan.loan_amount * 0.9 AND g.guarantor_credit_score > 700 AND sec.collateral_value > loan.loan_amount * 1.2 ORDER BY loan.loan_amount DESC, loan.interest_rate ASC, c.credit_score DESC LIMIT 55 OFFSET 0","output":"SELECT loan.loan_id, loan.loan_amount, loan.interest_rate, loan.start_date, loan.end_date, loan.term_months, loan.loan_purpose, loan.loan_status, c.customer_id, c.customer_name, c.credit_score, c.annual_income, c.employment_status, c.years_at_current_job, e.employee_id, e.employee_name, e.department, br.branch_id, br.branch_name, br.branch_region, pt.payment_terms, pt.number_of_payments, pt.payment_frequency, sch.due_date, sch.amount_due, sch.principal_amount, sch.interest_amount, sch.payment_status, coll.collection_stage, coll.collection_status, coll.collection_amount, coll.collector_name, risk.risk_level, risk.risk_score, risk.probability_of_default, doc.document_name, doc.document_status, doc.verification_date, ins.insurance_coverage, ins.insurance_provider, ins.policy_number, g.guarantor_name, g.guarantor_relationship, g.guarantor_income, g.guarantor_credit_score, sec.collateral_type, sec.collateral_value, sec.collateral_description FROM loans loan JOIN customers c ON loan.customer_id = c.customer_id JOIN employees e ON loan.loan_officer_id = e.employee_id JOIN branches br ON loan.branch_id = br.branch_id JOIN payment_terms pt ON loan.payment_terms_id = pt.terms_id JOIN payment_schedule sch ON loan.loan_id = sch.loan_id LEFT JOIN collection_efforts coll ON loan.loan_id = coll.loan_id LEFT JOIN risk_assessments risk ON loan.loan_id = risk.loan_id LEFT JOIN loan_documents doc ON loan.loan_id = doc.loan_id LEFT JOIN loan_insurance ins ON loan.loan_id = ins.loan_id LEFT JOIN guarantors g ON loan.loan_id = g.loan_id LEFT JOIN security_collateral sec ON loan.loan_id = sec.loan_id WHERE loan.loan_amount > 40000.00 AND loan.interest_rate < 6.75 AND loan.start_date > '2020-07-01' AND loan.loan_status = 'active' AND c.credit_score > 750 AND c.annual_income > 85000 AND e.department = 'consumer_lending' AND br.branch_region IN ('west', 'southwest') AND pt.number_of_payments > 36 AND sch.due_date BETWEEN '2023-11-01' AND '2024-02-29' AND coll.collection_status = 'in_progress' AND risk.risk_level = 'low' AND doc.document_status = 'verified' AND ins.insurance_coverage > loan.loan_amount * 0.9 AND g.guarantor_credit_score > 700 AND sec.collateral_value > loan.loan_amount * 1.2 ORDER BY loan.loan_amount DESC, loan.interest_rate ASC, c.credit_score DESC LIMIT 55"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.project_description, p.start_date, p.end_date, p.estimated_budget, p.actual_cost, p.estimated_profit, p.project_status, p.priority_level, c.client_id, c.client_name, c.industry_sector, c.client_rating, m.employee_id AS manager_id, m.first_name AS manager_first, m.last_name AS manager_last, d.department_id, d.department_name, d.department_budget, t.team_id, t.team_name, t.team_size, r.risk_id, r.risk_description, r.impact_level, r.likelihood, r.mitigation_strategy, del.deliverable_id, del.deliverable_name, del.deliverable_status, del.due_date, res.resource_id, res.resource_name, res.resource_type, res.hourly_rate, times.time_entry_id, times.hours_logged, times.overtime_hours, times.work_date, exp.expense_id, exp.expense_description, exp.amount, exp.expense_date, mil.milestone_id, mil.milestone_name, mil.completion_date, mil.milestone_status, sta.stakeholder_id, sta.stakeholder_name, sta.influence_level, sta.interest_level FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.project_manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables del ON p.project_id = del.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id LEFT JOIN project_expenses exp ON p.project_id = exp.project_id LEFT JOIN project_milestones mil ON p.project_id = mil.project_id LEFT JOIN project_stakeholders sta ON p.project_id = sta.project_id WHERE p.start_date > '2021-09-01' AND p.estimated_budget > 125000.00 AND p.project_status IN ('execution', 'monitoring') AND c.industry_sector IN ('Technology', 'Finance', 'Healthcare', 'Energy') AND c.client_rating >= 4.3 AND d.department_name = 'Innovation' AND t.team_size > 7 AND r.impact_level IN ('high', 'medium') AND del.deliverable_status = 'in_progress' AND res.resource_type = 'external' AND res.hourly_rate > 65.00 AND times.hours_logged > 25 AND times.work_date > '2023-05-01' AND exp.amount > 2500.00 AND mil.milestone_status = 'completed' AND sta.influence_level = 'high' ORDER BY p.estimated_budget DESC, p.priority_level ASC, p.start_date ASC LIMIT 35 OFFSET 0","output":"SELECT p.project_id, p.project_name, p.project_description, p.start_date, p.end_date, p.estimated_budget, p.actual_cost, p.estimated_profit, p.project_status, p.priority_level, c.client_id, c.client_name, c.industry_sector, c.client_rating, m.employee_id AS manager_id, m.first_name AS manager_first, m.last_name AS manager_last, d.department_id, d.department_name, d.department_budget, t.team_id, t.team_name, t.team_size, r.risk_id, r.risk_description, r.impact_level, r.likelihood, r.mitigation_strategy, del.deliverable_id, del.deliverable_name, del.deliverable_status, del.due_date, res.resource_id, res.resource_name, res.resource_type, res.hourly_rate, times.time_entry_id, times.hours_logged, times.overtime_hours, times.work_date, exp.expense_id, exp.expense_description, exp.amount, exp.expense_date, mil.milestone_id, mil.milestone_name, mil.completion_date, mil.milestone_status, sta.stakeholder_id, sta.stakeholder_name, sta.influence_level, sta.interest_level FROM projects p JOIN clients c ON p.client_id = c.client_id JOIN employees m ON p.project_manager_id = m.employee_id JOIN departments d ON p.department_id = d.department_id JOIN teams t ON p.team_id = t.team_id LEFT JOIN project_risks r ON p.project_id = r.project_id LEFT JOIN project_deliverables del ON p.project_id = del.project_id LEFT JOIN project_resources res ON p.project_id = res.project_id LEFT JOIN time_entries times ON p.project_id = times.project_id LEFT JOIN project_expenses exp ON p.project_id = exp.project_id LEFT JOIN project_milestones mil ON p.project_id = mil.project_id LEFT JOIN project_stakeholders sta ON p.project_id = sta.project_id WHERE p.start_date > '2021-09-01' AND p.estimated_budget > 125000.00 AND p.project_status IN ('execution', 'monitoring') AND c.industry_sector IN ('Technology', 'Finance', 'Healthcare', 'Energy') AND c.client_rating >= 4.3 AND d.department_name = 'Innovation' AND t.team_size > 7 AND r.impact_level IN ('high', 'medium') AND del.deliverable_status = 'in_progress' AND res.resource_type = 'external' AND res.hourly_rate > 65.00 AND times.hours_logged > 25 AND times.work_date > '2023-05-01' AND exp.amount > 2500.00 AND mil.milestone_status = 'completed' AND sta.influence_level = 'high' ORDER BY p.estimated_budget DESC, p.priority_level ASC, p.start_date ASC LIMIT 35"}
{"instruction":"Optimize the SQL query","input":"SELECT u.user_id, u.username, u.email, (SELECT COUNT(DISTINCT p.post_id) FROM posts p WHERE p.user_id = u.user_id AND p.created_at > '2023-01-01') AS posts_count_2023, (SELECT AVG(c.rating) FROM comments c JOIN posts p ON c.post_id = p.post_id WHERE p.user_id = u.user_id AND c.created_at > '2023-01-01') AS avg_comment_rating_2023 FROM users u WHERE u.registration_date BETWEEN '2022-01-01' AND '2022-12-31' AND u.status = 'active' AND u.user_id NOT IN (SELECT bl.user_id FROM blacklist_users bl WHERE bl.reason = 'Spamming') AND EXISTS (SELECT 1 FROM user_groups ug JOIN groups g ON ug.group_id = g.group_id WHERE ug.user_id = u.user_id AND g.group_type = 'Premium') ORDER BY posts_count_2023 DESC, avg_comment_rating_2023 DESC LIMIT 15;","output":"WITH UserPostStats AS (SELECT p.user_id, COUNT(DISTINCT p.post_id) AS posts_count_2023, AVG(c.rating) AS avg_comment_rating_2023 FROM posts AS p LEFT JOIN comments AS c ON p.post_id = c.post_id WHERE p.created_at > '2023-01-01' AND c.created_at > '2023-01-01' GROUP BY p.user_id) SELECT u.user_id, u.username, u.email, COALESCE(ups.posts_count_2023, 0) AS posts_count_2023, COALESCE(ups.avg_comment_rating_2023, 0) AS avg_comment_rating_2023 FROM users AS u LEFT JOIN UserPostStats AS ups ON u.user_id = ups.user_id LEFT JOIN blacklist_users AS bl ON u.user_id = bl.user_id AND bl.reason = 'Spamming' JOIN user_groups AS ug ON u.user_id = ug.user_id JOIN groups AS g ON ug.group_id = g.group_id WHERE u.registration_date BETWEEN '2022-01-01' AND '2022-12-31' AND u.status = 'active' AND bl.user_id IS NULL AND g.group_type = 'Premium' ORDER BY posts_count_2023 DESC, avg_comment_rating_2023 DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT p.product_id, p.product_name, p.price, (SELECT COUNT(oi.order_item_id) FROM order_items oi WHERE oi.product_id = p.product_id AND oi.order_id IN (SELECT order_id FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-06-30')) AS total_sales_H1_2023, (SELECT AVG(rr.rating) FROM product_reviews rr WHERE rr.product_id = p.product_id AND rr.review_date > '2023-01-01') AS avg_review_score FROM products p WHERE p.category_id = (SELECT c.category_id FROM categories c WHERE c.category_name = 'Electronics') AND p.stock_quantity > 10 AND p.price > 100 AND p.product_id NOT IN (SELECT dp.product_id FROM discontinued_products dp WHERE dp.discontinuation_date > '2023-01-01') ORDER BY total_sales_H1_2023 DESC, avg_review_score DESC LIMIT 20;","output":"WITH H1Sales AS (SELECT oi.product_id, COUNT(oi.order_item_id) AS total_sales_H1_2023 FROM order_items AS oi JOIN orders AS o ON oi.order_id = o.order_id WHERE o.order_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY oi.product_id), ReviewScores AS (SELECT product_id, AVG(rating) AS avg_review_score FROM product_reviews WHERE review_date > '2023-01-01' GROUP BY product_id) SELECT p.product_id, p.product_name, p.price, COALESCE(hs.total_sales_H1_2023, 0) AS total_sales_H1_2023, COALESCE(rs.avg_review_score, 0) AS avg_review_score FROM products AS p JOIN categories AS cat ON p.category_id = cat.category_id LEFT JOIN H1Sales AS hs ON p.product_id = hs.product_id LEFT JOIN ReviewScores AS rs ON p.product_id = rs.product_id LEFT JOIN discontinued_products AS dp ON p.product_id = dp.product_id AND dp.discontinuation_date > '2023-01-01' WHERE cat.category_name = 'Electronics' AND p.stock_quantity > 10 AND p.price > 100 AND dp.product_id IS NULL ORDER BY total_sales_H1_2023 DESC, avg_review_score DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT c.company_id, c.company_name, c.industry, (SELECT COUNT(DISTINCT pr.project_id) FROM projects pr WHERE pr.client_company_id = c.company_id AND pr.status = 'Completed' AND pr.end_date BETWEEN '2022-01-01' AND '2023-12-31') AS completed_projects_last_2_years, (SELECT AVG(pr.budget) FROM projects pr WHERE pr.client_company_id = c.company_id AND pr.status = 'Completed') AS avg_project_budget FROM companies c WHERE c.company_size = 'Large' AND c.founded_year < 2000 AND c.company_id NOT IN (SELECT bp.company_id FROM bankrupt_companies bp WHERE bp.bankruptcy_date > '2023-01-01') AND EXISTS (SELECT 1 FROM company_partnerships cp WHERE cp.company_id = c.company_id AND cp.partnership_type = 'Strategic Alliance') ORDER BY completed_projects_last_2_years DESC, avg_project_budget DESC LIMIT 10;","output":"WITH ProjectStats AS (SELECT client_company_id AS company_id, COUNT(DISTINCT project_id) AS completed_projects_last_2_years, AVG(budget) AS avg_project_budget FROM projects WHERE status = 'Completed' AND end_date BETWEEN '2022-01-01' AND '2023-12-31' GROUP BY client_company_id) SELECT c.company_id, c.company_name, c.industry, COALESCE(ps.completed_projects_last_2_years, 0) AS completed_projects_last_2_years, COALESCE(ps.avg_project_budget, 0) AS avg_project_budget FROM companies AS c LEFT JOIN ProjectStats AS ps ON c.company_id = ps.company_id LEFT JOIN bankrupt_companies AS bc ON c.company_id = bc.company_id AND bc.bankruptcy_date > '2023-01-01' JOIN company_partnerships AS cp ON c.company_id = cp.company_id WHERE c.company_size = 'Large' AND c.founded_year < 2000 AND bc.company_id IS NULL AND cp.partnership_type = 'Strategic Alliance' ORDER BY completed_projects_last_2_years DESC, avg_project_budget DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.station_id, s.station_name, s.city, (SELECT AVG(r.temperature) FROM weather_readings r WHERE r.station_id = s.station_id AND r.reading_date BETWEEN '2023-01-01' AND '2023-01-31') AS avg_jan_temp, (SELECT MAX(r.wind_speed) FROM weather_readings r WHERE r.station_id = s.station_id AND r.reading_date BETWEEN '2023-01-01' AND '2023-01-31') AS max_jan_wind_speed FROM weather_stations s WHERE s.country = 'Germany' AND s.elevation > 500 AND s.station_id NOT IN (SELECT ff.station_id FROM equipment_failures ff WHERE ff.failure_date BETWEEN '2023-01-01' AND '2023-06-30') AND EXISTS (SELECT 1 FROM station_sensors ss WHERE ss.station_id = s.station_id AND ss.sensor_type = 'Anemometer') ORDER BY avg_jan_temp DESC, max_jan_wind_speed DESC LIMIT 10;","output":"WITH JanWeatherStats AS (SELECT station_id, AVG(temperature) AS avg_jan_temp, MAX(wind_speed) AS max_jan_wind_speed FROM weather_readings WHERE reading_date BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY station_id) SELECT s.station_id, s.station_name, s.city, COALESCE(jws.avg_jan_temp, 0) AS avg_jan_temp, COALESCE(jws.max_jan_wind_speed, 0) AS max_jan_wind_speed FROM weather_stations AS s LEFT JOIN JanWeatherStats AS jws ON s.station_id = jws.station_id LEFT JOIN equipment_failures AS ef ON s.station_id = ef.station_id AND ef.failure_date BETWEEN '2023-01-01' AND '2023-06-30' JOIN station_sensors AS ss ON s.station_id = ss.station_id WHERE s.country = 'Germany' AND s.elevation > 500 AND ef.station_id IS NULL AND ss.sensor_type = 'Anemometer' ORDER BY avg_jan_temp DESC, max_jan_wind_speed DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.playlist_id, p.playlist_name, u.username, (SELECT COUNT(pt.track_id) FROM playlist_tracks pt WHERE pt.playlist_id = p.playlist_id) AS total_tracks, (SELECT SUM(t.duration_seconds) FROM playlist_tracks pt JOIN tracks t ON pt.track_id = t.track_id WHERE pt.playlist_id = p.playlist_id) AS total_duration_seconds FROM playlists p JOIN users u ON p.user_id = u.user_id WHERE p.is_public = TRUE AND u.country = 'USA' AND p.creation_date BETWEEN '2022-01-01' AND '2022-12-31' AND p.playlist_id NOT IN (SELECT DISTINCT rp.playlist_id FROM reported_playlists rp WHERE rp.report_type = 'Inappropriate Content') ORDER BY total_tracks DESC, total_duration_seconds DESC LIMIT 10;","output":"WITH PlaylistStats AS (SELECT pt.playlist_id, COUNT(pt.track_id) AS total_tracks, SUM(t.duration_seconds) AS total_duration_seconds FROM playlist_tracks AS pt JOIN tracks AS t ON pt.track_id = t.track_id GROUP BY pt.playlist_id) SELECT p.playlist_id, p.playlist_name, u.username, COALESCE(ps.total_tracks, 0) AS total_tracks, COALESCE(ps.total_duration_seconds, 0) AS total_duration_seconds FROM playlists AS p JOIN users AS u ON p.user_id = u.user_id LEFT JOIN PlaylistStats AS ps ON p.playlist_id = ps.playlist_id LEFT JOIN reported_playlists AS rp ON p.playlist_id = rp.playlist_id AND rp.report_type = 'Inappropriate Content' WHERE p.is_public = TRUE AND u.country = 'USA' AND p.creation_date BETWEEN '2022-01-01' AND '2022-12-31' AND rp.playlist_id IS NULL ORDER BY total_tracks DESC, total_duration_seconds DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT a.article_id, a.title, au.author_name, a.publication_date, (SELECT COUNT(c.comment_id) FROM comments c WHERE c.article_id = a.article_id) AS total_comments, (SELECT AVG(r.rating_score) FROM article_ratings r WHERE r.article_id = a.article_id) AS avg_rating FROM articles a JOIN authors au ON a.author_id = au.author_id WHERE a.category = 'Technology' AND a.publication_date BETWEEN '2023-01-01' AND '2023-06-30' AND a.article_id NOT IN (SELECT pr.article_id FROM flagged_articles pr WHERE pr.flag_reason = 'Misinformation') AND EXISTS (SELECT 1 FROM article_tags at JOIN tags t ON at.tag_id = t.tag_id WHERE at.article_id = a.article_id AND t.tag_name = 'AI') ORDER BY total_comments DESC, avg_rating DESC LIMIT 15;","output":"WITH ArticleStats AS (SELECT a.article_id, COUNT(c.comment_id) AS total_comments, AVG(r.rating_score) AS avg_rating FROM articles AS a LEFT JOIN comments AS c ON a.article_id = c.article_id LEFT JOIN article_ratings AS r ON a.article_id = r.article_id GROUP BY a.article_id) SELECT a.article_id, a.title, au.author_name, a.publication_date, COALESCE(aps.total_comments, 0) AS total_comments, COALESCE(aps.avg_rating, 0) AS avg_rating FROM articles AS a JOIN authors AS au ON a.author_id = au.author_id LEFT JOIN ArticleStats AS aps ON a.article_id = aps.article_id LEFT JOIN flagged_articles AS fa ON a.article_id = fa.article_id AND fa.flag_reason = 'Misinformation' JOIN article_tags AS at ON a.article_id = at.article_id JOIN tags AS t ON at.tag_id = t.tag_id WHERE a.category = 'Technology' AND a.publication_date BETWEEN '2023-01-01' AND '2023-06-30' AND fa.article_id IS NULL AND t.tag_name = 'AI' ORDER BY total_comments DESC, avg_rating DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT v.vendor_id, v.vendor_name, v.country, (SELECT SUM(po.total_amount) FROM purchase_orders po WHERE po.vendor_id = v.vendor_id AND po.order_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_purchase_amount, (SELECT AVG(dr.delivery_time_days) FROM delivery_records dr WHERE dr.vendor_id = v.vendor_id AND dr.delivery_date > '2023-01-01') AS avg_delivery_time FROM vendors v WHERE v.vendor_status = 'Preferred' AND v.contract_start_date < '2020-01-01' AND v.vendor_id NOT IN (SELECT lp.vendor_id FROM late_payments lp WHERE lp.payment_date > '2023-01-01') AND EXISTS (SELECT 1 FROM vendor_certifications vc WHERE vc.vendor_id = v.vendor_id AND vc.certification_type = 'ISO 9001') ORDER BY annual_purchase_amount DESC, avg_delivery_time ASC LIMIT 10;","output":"WITH VendorPurchaseStats AS (SELECT vendor_id, SUM(total_amount) AS annual_purchase_amount FROM purchase_orders WHERE order_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY vendor_id), VendorDeliveryStats AS (SELECT vendor_id, AVG(delivery_time_days) AS avg_delivery_time FROM delivery_records WHERE delivery_date > '2023-01-01' GROUP BY vendor_id) SELECT v.vendor_id, v.vendor_name, v.country, COALESCE(vps.annual_purchase_amount, 0) AS annual_purchase_amount, COALESCE(vds.avg_delivery_time, 0) AS avg_delivery_time FROM vendors AS v LEFT JOIN VendorPurchaseStats AS vps ON v.vendor_id = vps.vendor_id LEFT JOIN VendorDeliveryStats AS vds ON v.vendor_id = vds.vendor_id LEFT JOIN late_payments AS lp ON v.vendor_id = lp.vendor_id AND lp.payment_date > '2023-01-01' JOIN vendor_certifications AS vc ON v.vendor_id = vc.vendor_id WHERE v.vendor_status = 'Preferred' AND v.contract_start_date < '2020-01-01' AND lp.vendor_id IS NULL AND vc.certification_type = 'ISO 9001' ORDER BY annual_purchase_amount DESC, avg_delivery_time ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT h.hospital_id, h.hospital_name, h.city, (SELECT COUNT(p.patient_id) FROM patients p WHERE p.hospital_id = h.hospital_id AND p.admission_date > '2023-01-01') AS patients_admitted_2023, (SELECT AVG(s.satisfaction_score) FROM patient_surveys s WHERE s.hospital_id = h.hospital_id AND s.survey_date > '2023-01-01') AS avg_patient_satisfaction FROM hospitals h WHERE h.hospital_type = 'General' AND h.number_of_beds > 200 AND h.hospital_id NOT IN (SELECT ci.hospital_id FROM critical_incidents ci WHERE ci.incident_date > '2023-01-01' AND ci.severity = 'High') AND EXISTS (SELECT 1 FROM hospital_accreditations ha WHERE ha.hospital_id = h.hospital_id AND ha.accreditation_body = 'JCI') ORDER BY patients_admitted_2023 DESC, avg_patient_satisfaction DESC LIMIT 10;","output":"WITH HospitalPatientStats AS (SELECT hospital_id, COUNT(patient_id) AS patients_admitted_2023 FROM patients WHERE admission_date > '2023-01-01' GROUP BY hospital_id), PatientSatisfaction AS (SELECT hospital_id, AVG(satisfaction_score) AS avg_patient_satisfaction FROM patient_surveys WHERE survey_date > '2023-01-01' GROUP BY hospital_id) SELECT h.hospital_id, h.hospital_name, h.city, COALESCE(hps.patients_admitted_2023, 0) AS patients_admitted_2023, COALESCE(ps.avg_patient_satisfaction, 0) AS avg_patient_satisfaction FROM hospitals AS h LEFT JOIN HospitalPatientStats AS hps ON h.hospital_id = hps.hospital_id LEFT JOIN PatientSatisfaction AS ps ON h.hospital_id = ps.hospital_id LEFT JOIN critical_incidents AS ci ON h.hospital_id = ci.hospital_id AND ci.incident_date > '2023-01-01' AND ci.severity = 'High' JOIN hospital_accreditations AS ha ON h.hospital_id = ha.hospital_id WHERE h.hospital_type = 'General' AND h.number_of_beds > 200 AND ci.hospital_id IS NULL AND ha.accreditation_body = 'JCI' ORDER BY patients_admitted_2023 DESC, avg_patient_satisfaction DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.software_id, s.software_name, s.version, (SELECT COUNT(il.installation_id) FROM installations il WHERE il.software_id = s.software_id AND il.installation_date > '2023-01-01') AS installations_2023, (SELECT AVG(ur.usability_score) FROM user_reviews ur WHERE ur.software_id = s.software_id AND ur.review_date > '2023-01-01') AS avg_usability_score FROM software s WHERE s.software_type = 'Productivity' AND s.release_date < '2022-01-01' AND s.software_id NOT IN (SELECT vd.software_id FROM vulnerability_reports vd WHERE vd.report_date > '2023-01-01' AND vd.severity = 'Critical') AND EXISTS (SELECT 1 FROM software_licenses sl WHERE sl.software_id = s.software_id AND sl.license_type = 'Enterprise') ORDER BY installations_2023 DESC, avg_usability_score DESC LIMIT 10;","output":"WITH SoftwareStats AS (SELECT il.software_id, COUNT(il.installation_id) AS installations_2023, AVG(ur.usability_score) AS avg_usability_score FROM installations AS il LEFT JOIN user_reviews AS ur ON il.software_id = ur.software_id WHERE il.installation_date > '2023-01-01' AND ur.review_date > '2023-01-01' GROUP BY il.software_id) SELECT s.software_id, s.software_name, s.version, COALESCE(ss.installations_2023, 0) AS installations_2023, COALESCE(ss.avg_usability_score, 0) AS avg_usability_score FROM software AS s LEFT JOIN SoftwareStats AS ss ON s.software_id = ss.software_id LEFT JOIN vulnerability_reports AS vr ON s.software_id = vr.software_id AND vr.report_date > '2023-01-01' AND vr.severity = 'Critical' JOIN software_licenses AS sl ON s.software_id = sl.software_id WHERE s.software_type = 'Productivity' AND s.release_date < '2022-01-01' AND vr.software_id IS NULL AND sl.license_type = 'Enterprise' ORDER BY installations_2023 DESC, avg_usability_score DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT f.firm_id, f.firm_name, f.city, (SELECT COUNT(cl.client_id) FROM clients cl WHERE cl.firm_id = f.firm_id AND cl.onboarding_date > '2023-01-01') AS new_clients_2023, (SELECT AVG(fb.satisfaction_score) FROM client_feedback fb WHERE fb.firm_id = f.firm_id AND fb.feedback_date > '2023-01-01') AS avg_client_satisfaction FROM firms f WHERE f.firm_type = 'Legal' AND f.founding_year < 1990 AND f.firm_id NOT IN (SELECT lr.firm_id FROM lawsuit_records lr WHERE lr.case_status = 'Lost' AND lr.case_date > '2023-01-01') AND EXISTS (SELECT 1 FROM firm_specialties fs WHERE fs.firm_id = f.firm_id AND fs.specialty_area = 'Corporate Law') ORDER BY new_clients_2023 DESC, avg_client_satisfaction DESC LIMIT 10;","output":"WITH FirmClientStats AS (SELECT cl.firm_id, COUNT(cl.client_id) AS new_clients_2023, AVG(fb.satisfaction_score) AS avg_client_satisfaction FROM clients AS cl LEFT JOIN client_feedback AS fb ON cl.firm_id = fb.firm_id WHERE cl.onboarding_date > '2023-01-01' AND fb.feedback_date > '2023-01-01' GROUP BY cl.firm_id) SELECT f.firm_id, f.firm_name, f.city, COALESCE(fcs.new_clients_2023, 0) AS new_clients_2023, COALESCE(fcs.avg_client_satisfaction, 0) AS avg_client_satisfaction FROM firms AS f LEFT JOIN FirmClientStats AS fcs ON f.firm_id = fcs.firm_id LEFT JOIN lawsuit_records AS lr ON f.firm_id = lr.firm_id AND lr.case_status = 'Lost' AND lr.case_date > '2023-01-01' JOIN firm_specialties AS fs ON f.firm_id = fs.firm_id WHERE f.firm_type = 'Legal' AND f.founding_year < 1990 AND lr.firm_id IS NULL AND fs.specialty_area = 'Corporate Law' ORDER BY new_clients_2023 DESC, avg_client_satisfaction DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT uni.university_id, uni.university_name, uni.city, (SELECT COUNT(st.student_id) FROM students st WHERE st.university_id = uni.university_id AND st.enrollment_date > '2023-01-01') AS new_enrollments_2023, (SELECT AVG(pr.research_citations) FROM professors pr WHERE pr.university_id = uni.university_id) AS avg_prof_citations FROM universities uni WHERE uni.country = 'USA' AND uni.ranking <= 50 AND uni.university_id NOT IN (SELECT ap.university_id FROM academic_penalties ap WHERE ap.penalty_date > '2023-01-01') AND EXISTS (SELECT 1 FROM university_programs up WHERE up.university_id = uni.university_id AND up.program_type = 'Doctorate') ORDER BY new_enrollments_2023 DESC, avg_prof_citations DESC LIMIT 10;","output":"WITH UniversityStats AS (SELECT st.university_id, COUNT(st.student_id) AS new_enrollments_2023 FROM students AS st WHERE st.enrollment_date > '2023-01-01' GROUP BY st.university_id), ProfessorCitations AS (SELECT university_id, AVG(research_citations) AS avg_prof_citations FROM professors GROUP BY university_id) SELECT uni.university_id, uni.university_name, uni.city, COALESCE(us.new_enrollments_2023, 0) AS new_enrollments_2023, COALESCE(pc.avg_prof_citations, 0) AS avg_prof_citations FROM universities AS uni LEFT JOIN UniversityStats AS us ON uni.university_id = us.university_id LEFT JOIN ProfessorCitations AS pc ON uni.university_id = pc.university_id LEFT JOIN academic_penalties AS ap ON uni.university_id = ap.university_id AND ap.penalty_date > '2023-01-01' JOIN university_programs AS up ON uni.university_id = up.university_id WHERE uni.country = 'USA' AND uni.ranking <= 50 AND ap.university_id IS NULL AND up.program_type = 'Doctorate' ORDER BY new_enrollments_2023 DESC, avg_prof_citations DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.sensor_id, s.sensor_type, s.location, (SELECT AVG(d.value) FROM sensor_data d WHERE d.sensor_id = s.sensor_id AND d.timestamp BETWEEN '2023-01-01' AND '2023-01-31') AS avg_jan_value, (SELECT COUNT(a.alert_id) FROM sensor_alerts a WHERE a.sensor_id = s.sensor_id AND a.alert_date BETWEEN '2023-01-01' AND '2023-01-31') AS jan_alerts FROM sensors s WHERE s.status = 'Operational' AND s.deployment_date < '2022-01-01' AND s.sensor_id NOT IN (SELECT ce.sensor_id FROM sensor_critical_errors ce WHERE ce.error_date > '2023-01-01') AND EXISTS (SELECT 1 FROM sensor_calibration sc WHERE sc.sensor_id = s.sensor_id AND sc.last_calibration_date > '2023-01-01') ORDER BY jan_alerts DESC, avg_jan_value DESC LIMIT 10;","output":"WITH JanSensorStats AS (SELECT sensor_id, AVG(value) AS avg_jan_value, COUNT(alert_id) AS jan_alerts FROM sensor_data AS sd LEFT JOIN sensor_alerts AS sa ON sd.sensor_id = sa.sensor_id AND sa.alert_date BETWEEN '2023-01-01' AND '2023-01-31' WHERE sd.timestamp BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY sensor_id) SELECT s.sensor_id, s.sensor_type, s.location, COALESCE(jss.avg_jan_value, 0) AS avg_jan_value, COALESCE(jss.jan_alerts, 0) AS jan_alerts FROM sensors AS s LEFT JOIN JanSensorStats AS jss ON s.sensor_id = jss.sensor_id LEFT JOIN sensor_critical_errors AS sce ON s.sensor_id = sce.sensor_id AND sce.error_date > '2023-01-01' JOIN sensor_calibration AS sc ON s.sensor_id = sc.sensor_id WHERE s.status = 'Operational' AND s.deployment_date < '2022-01-01' AND sce.sensor_id IS NULL AND sc.last_calibration_date > '2023-01-01' ORDER BY jan_alerts DESC, avg_jan_value DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_name, c.start_date, c.end_date, (SELECT SUM(cm.spend) FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_spend, (SELECT AVG(cm.roi) FROM campaign_metrics cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_roi FROM campaigns c WHERE c.campaign_type = 'Digital' AND c.status = 'Active' AND c.budget > 5000 AND c.campaign_id NOT IN (SELECT fr.campaign_id FROM fraud_reports fr WHERE fr.report_date > '2023-01-01' AND fr.severity = 'High') AND EXISTS (SELECT 1 FROM campaign_creatives cc WHERE cc.campaign_id = c.campaign_id AND cc.creative_type = 'Video Ad') ORDER BY Q1_spend DESC, Q1_avg_roi DESC LIMIT 10;","output":"WITH Q1CampaignMetrics AS (SELECT campaign_id, SUM(spend) AS Q1_spend, AVG(roi) AS Q1_avg_roi FROM campaign_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY campaign_id) SELECT c.campaign_name, c.start_date, c.end_date, COALESCE(qcm.Q1_spend, 0) AS Q1_spend, COALESCE(qcm.Q1_avg_roi, 0) AS Q1_avg_roi FROM campaigns AS c LEFT JOIN Q1CampaignMetrics AS qcm ON c.campaign_id = qcm.campaign_id LEFT JOIN fraud_reports AS fr ON c.campaign_id = fr.campaign_id AND fr.report_date > '2023-01-01' AND fr.severity = 'High' JOIN campaign_creatives AS cc ON c.campaign_id = cc.campaign_id WHERE c.campaign_type = 'Digital' AND c.status = 'Active' AND c.budget > 5000 AND fr.campaign_id IS NULL AND cc.creative_type = 'Video Ad' ORDER BY Q1_spend DESC, Q1_avg_roi DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT a.ad_id, a.ad_title, a.platform, (SELECT SUM(am.impressions) FROM ad_metrics am WHERE am.ad_id = a.ad_id AND am.metric_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_impressions, (SELECT AVG(am.ctr) FROM ad_metrics am WHERE am.ad_id = a.ad_id AND am.metric_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_ctr FROM ads a WHERE a.campaign_id = (SELECT cm.campaign_id FROM campaigns cm WHERE cm.campaign_name = 'Summer Sale 2023') AND a.status = 'Active' AND a.ad_type = 'Banner' AND a.ad_id NOT IN (SELECT ar.ad_id FROM ad_rejections ar WHERE ar.rejection_date > '2023-01-01') ORDER BY H1_impressions DESC, H1_avg_ctr DESC LIMIT 20;","output":"WITH H1AdMetrics AS (SELECT ad_id, SUM(impressions) AS H1_impressions, AVG(ctr) AS H1_avg_ctr FROM ad_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY ad_id) SELECT a.ad_id, a.ad_title, a.platform, COALESCE(ham.H1_impressions, 0) AS H1_impressions, COALESCE(ham.H1_avg_ctr, 0) AS H1_avg_ctr FROM ads AS a JOIN campaigns AS cm ON a.campaign_id = cm.campaign_id LEFT JOIN H1AdMetrics AS ham ON a.ad_id = ham.ad_id LEFT JOIN ad_rejections AS ar ON a.ad_id = ar.ad_id AND ar.rejection_date > '2023-01-01' WHERE cm.campaign_name = 'Summer Sale 2023' AND a.status = 'Active' AND a.ad_type = 'Banner' AND ar.ad_id IS NULL ORDER BY H1_impressions DESC, H1_avg_ctr DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT l.location_id, l.location_name, l.city, (SELECT COUNT(e.employee_id) FROM employees e WHERE e.location_id = l.location_id AND e.hire_date > '2023-01-01') AS new_hires_2023, (SELECT AVG(r.rating) FROM office_reviews r WHERE r.location_id = l.location_id) AS avg_office_rating FROM locations l WHERE l.country = 'Canada' AND l.location_type = 'Office' AND l.location_id NOT IN (SELECT co.location_id FROM construction_projects co WHERE co.end_date > CURDATE()) AND EXISTS (SELECT 1 FROM location_amenities la WHERE la.location_id = l.location_id AND la.amenity_type = 'Cafeteria') ORDER BY new_hires_2023 DESC, avg_office_rating DESC LIMIT 10;","output":"WITH LocationEmployeeStats AS (SELECT e.location_id, COUNT(e.employee_id) AS new_hires_2023 FROM employees AS e WHERE e.hire_date > '2023-01-01' GROUP BY e.location_id), OfficeRatings AS (SELECT location_id, AVG(rating) AS avg_office_rating FROM office_reviews GROUP BY location_id) SELECT l.location_id, l.location_name, l.city, COALESCE(les.new_hires_2023, 0) AS new_hires_2023, COALESCE(ors.avg_office_rating, 0) AS avg_office_rating FROM locations AS l LEFT JOIN LocationEmployeeStats AS les ON l.location_id = les.location_id LEFT JOIN OfficeRatings AS ors ON l.location_id = ors.location_id LEFT JOIN construction_projects AS cp ON l.location_id = cp.location_id AND cp.end_date > CURDATE() JOIN location_amenities AS la ON l.location_id = la.location_id WHERE l.country = 'Canada' AND l.location_type = 'Office' AND cp.location_id IS NULL AND la.amenity_type = 'Cafeteria' ORDER BY new_hires_2023 DESC, avg_office_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT m.membership_id, m.member_name, m.membership_level, (SELECT COUNT(a.activity_id) FROM member_activities a WHERE a.membership_id = m.membership_id AND a.activity_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_activities, (SELECT MAX(a.activity_date) FROM member_activities a WHERE a.membership_id = m.membership_id) AS last_activity FROM memberships m WHERE m.status = 'Active' AND m.join_date < '2022-01-01' AND m.membership_id NOT IN (SELECT fp.membership_id FROM membership_violations fp WHERE fp.violation_date > '2023-01-01' AND fp.severity = 'High') AND EXISTS (SELECT 1 FROM member_benefits mb JOIN benefits b ON mb.benefit_id = b.benefit_id WHERE mb.membership_id = m.membership_id AND b.benefit_type = 'Exclusive Access') ORDER BY annual_activities DESC, last_activity DESC LIMIT 15;","output":"WITH MemberActivityStats AS (SELECT membership_id, COUNT(activity_id) AS annual_activities, MAX(activity_date) AS last_activity FROM member_activities WHERE activity_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY membership_id) SELECT m.membership_id, m.member_name, m.membership_level, COALESCE(mas.annual_activities, 0) AS annual_activities, mas.last_activity FROM memberships AS m LEFT JOIN MemberActivityStats AS mas ON m.membership_id = mas.membership_id LEFT JOIN membership_violations AS mv ON m.membership_id = mv.membership_id AND mv.violation_date > '2023-01-01' AND mv.severity = 'High' JOIN member_benefits AS mb ON m.membership_id = mb.membership_id JOIN benefits AS b ON mb.benefit_id = b.benefit_id WHERE m.status = 'Active' AND m.join_date < '2022-01-01' AND mv.membership_id IS NULL AND b.benefit_type = 'Exclusive Access' ORDER BY annual_activities DESC, last_activity DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.supplier_id, s.supplier_name, s.country, (SELECT SUM(po.total_amount) FROM purchase_orders po WHERE po.supplier_id = s.supplier_id AND po.order_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_purchase_amount, (SELECT AVG(dp.delivery_rating) FROM delivery_performance dp WHERE dp.supplier_id = s.supplier_id AND dp.rating_date > '2023-01-01') AS avg_delivery_rating FROM suppliers s WHERE s.supplier_status = 'Approved' AND s.contract_start_date < '2021-01-01' AND s.supplier_id NOT IN (SELECT qr.supplier_id FROM quality_reports qr WHERE qr.report_date > '2023-01-01' AND qr.issue_type = 'Major') AND EXISTS (SELECT 1 FROM supplier_products sp WHERE sp.supplier_id = s.supplier_id AND sp.product_category = 'Raw Materials') ORDER BY H1_purchase_amount DESC, avg_delivery_rating DESC LIMIT 10;","output":"WITH SupplierPurchaseStats AS (SELECT supplier_id, SUM(total_amount) AS H1_purchase_amount FROM purchase_orders WHERE order_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY supplier_id), DeliveryRatings AS (SELECT supplier_id, AVG(delivery_rating) AS avg_delivery_rating FROM delivery_performance WHERE rating_date > '2023-01-01' GROUP BY supplier_id) SELECT s.supplier_id, s.supplier_name, s.country, COALESCE(sps.H1_purchase_amount, 0) AS H1_purchase_amount, COALESCE(dr.avg_delivery_rating, 0) AS avg_delivery_rating FROM suppliers AS s LEFT JOIN SupplierPurchaseStats AS sps ON s.supplier_id = sps.supplier_id LEFT JOIN DeliveryRatings AS dr ON s.supplier_id = dr.supplier_id LEFT JOIN quality_reports AS qr ON s.supplier_id = qr.supplier_id AND qr.report_date > '2023-01-01' AND qr.issue_type = 'Major' JOIN supplier_products AS sp ON s.supplier_id = sp.supplier_id WHERE s.supplier_status = 'Approved' AND s.contract_start_date < '2021-01-01' AND qr.supplier_id IS NULL AND sp.product_category = 'Raw Materials' ORDER BY H1_purchase_amount DESC, avg_delivery_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT v.vessel_id, v.vessel_name, v.vessel_type, (SELECT MAX(sp.speed_knots) FROM voyage_segments vs JOIN speed_readings sp ON vs.segment_id = sp.segment_id WHERE vs.vessel_id = v.vessel_id AND vs.voyage_date > '2023-01-01') AS max_recent_speed, (SELECT AVG(fc.fuel_consumption_per_hour) FROM voyage_segments vs JOIN fuel_logs fc ON vs.segment_id = fc.segment_id WHERE vs.vessel_id = v.vessel_id AND vs.voyage_date > '2023-01-01') AS avg_recent_fuel_consumption FROM vessels v WHERE v.status = 'Operational' AND v.build_year < 2010 AND v.vessel_id NOT IN (SELECT md.vessel_id FROM maintenance_due md WHERE md.due_date < CURDATE() + INTERVAL 30 DAY) AND EXISTS (SELECT 1 FROM vessel_sensors vsn WHERE vsn.vessel_id = v.vessel_id AND vsn.sensor_type = 'Engine Monitoring') ORDER BY max_recent_speed DESC, avg_recent_fuel_consumption ASC LIMIT 10;","output":"WITH VesselSpeed AS (SELECT vs.vessel_id, MAX(sp.speed_knots) AS max_recent_speed FROM voyage_segments AS vs JOIN speed_readings AS sp ON vs.segment_id = sp.segment_id WHERE vs.voyage_date > '2023-01-01' GROUP BY vs.vessel_id), VesselFuel AS (SELECT vs.vessel_id, AVG(fc.fuel_consumption_per_hour) AS avg_recent_fuel_consumption FROM voyage_segments AS vs JOIN fuel_logs AS fc ON vs.segment_id = fc.segment_id WHERE vs.voyage_date > '2023-01-01' GROUP BY vs.vessel_id) SELECT v.vessel_id, v.vessel_name, v.vessel_type, COALESCE(vs.max_recent_speed, 0) AS max_recent_speed, COALESCE(vf.avg_recent_fuel_consumption, 0) AS avg_recent_fuel_consumption FROM vessels AS v LEFT JOIN VesselSpeed AS vs ON v.vessel_id = vs.vessel_id LEFT JOIN VesselFuel AS vf ON v.vessel_id = vf.vessel_id LEFT JOIN maintenance_due AS md ON v.vessel_id = md.vessel_id AND md.due_date < CURDATE() + INTERVAL 30 DAY JOIN vessel_sensors AS vsn ON v.vessel_id = vsn.vessel_id WHERE v.status = 'Operational' AND v.build_year < 2010 AND md.vessel_id IS NULL AND vsn.sensor_type = 'Engine Monitoring' ORDER BY max_recent_speed DESC, avg_recent_fuel_consumption ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT p.project_id, p.project_name, p.start_date, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = p.project_id AND t.status = 'Completed') AS completed_tasks_count, (SELECT AVG(t.actual_duration_days) FROM tasks t WHERE t.project_id = p.project_id AND t.status = 'Completed') AS avg_task_completion_time FROM projects p WHERE p.status = 'Active' AND p.budget > 100000 AND p.project_id NOT IN (SELECT di.project_id FROM project_delays di WHERE di.delay_start_date > '2023-01-01' AND di.severity = 'High') AND EXISTS (SELECT 1 FROM project_managers pm JOIN employees e ON pm.employee_id = e.employee_id WHERE pm.project_id = p.project_id AND e.department_id = (SELECT department_id FROM departments WHERE department_name = 'Project Management')) ORDER BY completed_tasks_count DESC, avg_task_completion_time ASC LIMIT 10;","output":"WITH ProjectTaskStats AS (SELECT project_id, COUNT(task_id) AS completed_tasks_count, AVG(actual_duration_days) AS avg_task_completion_time FROM tasks WHERE status = 'Completed' GROUP BY project_id) SELECT p.project_id, p.project_name, p.start_date, COALESCE(pts.completed_tasks_count, 0) AS completed_tasks_count, COALESCE(pts.avg_task_completion_time, 0) AS avg_task_completion_time FROM projects AS p LEFT JOIN ProjectTaskStats AS pts ON p.project_id = pts.project_id LEFT JOIN project_delays AS pd ON p.project_id = pd.project_id AND pd.delay_start_date > '2023-01-01' AND pd.severity = 'High' JOIN project_managers AS pm ON p.project_id = pm.project_id JOIN employees AS e ON pm.employee_id = e.employee_id JOIN departments AS d ON e.department_id = d.department_id WHERE p.status = 'Active' AND p.budget > 100000 AND pd.project_id IS NULL AND d.department_name = 'Project Management' ORDER BY completed_tasks_count DESC, avg_task_completion_time ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT cu.customer_id, cu.customer_name, cu.email, (SELECT COUNT(s.subscription_id) FROM subscriptions s WHERE s.customer_id = cu.customer_id AND s.status = 'Active') AS active_subscriptions, (SELECT MAX(o.order_date) FROM orders o WHERE o.customer_id = cu.customer_id) AS last_order_date FROM customers cu WHERE cu.registration_date > '2022-01-01' AND cu.customer_type = 'Premium' AND cu.customer_id NOT IN (SELECT cp.customer_id FROM churned_customers cp WHERE cp.churn_date > '2023-01-01') AND EXISTS (SELECT 1 FROM customer_feedback cf WHERE cf.customer_id = cu.customer_id AND cf.feedback_score = 5) ORDER BY active_subscriptions DESC, last_order_date DESC LIMIT 15;","output":"WITH CustomerSubscriptionStats AS (SELECT customer_id, COUNT(subscription_id) AS active_subscriptions FROM subscriptions WHERE status = 'Active' GROUP BY customer_id), LastOrderDate AS (SELECT customer_id, MAX(order_date) AS last_order_date FROM orders GROUP BY customer_id) SELECT cu.customer_id, cu.customer_name, cu.email, COALESCE(css.active_subscriptions, 0) AS active_subscriptions, lod.last_order_date FROM customers AS cu LEFT JOIN CustomerSubscriptionStats AS css ON cu.customer_id = css.customer_id LEFT JOIN LastOrderDate AS lod ON cu.customer_id = lod.customer_id LEFT JOIN churned_customers AS cc ON cu.customer_id = cc.customer_id AND cc.churn_date > '2023-01-01' JOIN customer_feedback AS cf ON cu.customer_id = cf.customer_id WHERE cu.registration_date > '2022-01-01' AND cu.customer_type = 'Premium' AND cc.customer_id IS NULL AND cf.feedback_score = 5 ORDER BY active_subscriptions DESC, last_order_date DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT b.building_id, b.building_name, b.address, (SELECT SUM(uf.utility_cost) FROM utility_bills uf WHERE uf.building_id = b.building_id AND uf.bill_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_utility_cost, (SELECT AVG(oc.occupancy_rate) FROM occupancy_data oc WHERE oc.building_id = b.building_id AND oc.data_date BETWEEN '2023-01-01' AND '2023-12-31') AS avg_annual_occupancy FROM buildings b WHERE b.building_type = 'Commercial' AND b.year_built < 2000 AND b.building_id NOT IN (SELECT rs.building_id FROM structural_issues rs WHERE rs.issue_date > '2023-01-01' AND rs.severity = 'High') AND EXISTS (SELECT 1 FROM building_certifications bc WHERE bc.building_id = b.building_id AND bc.certification_type = 'LEED Platinum') ORDER BY annual_utility_cost DESC, avg_annual_occupancy DESC LIMIT 10;","output":"WITH BuildingUtilityCosts AS (SELECT building_id, SUM(utility_cost) AS annual_utility_cost FROM utility_bills WHERE bill_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY building_id), AnnualOccupancy AS (SELECT building_id, AVG(occupancy_rate) AS avg_annual_occupancy FROM occupancy_data WHERE data_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY building_id) SELECT b.building_id, b.building_name, b.address, COALESCE(buc.annual_utility_cost, 0) AS annual_utility_cost, COALESCE(ao.avg_annual_occupancy, 0) AS avg_annual_occupancy FROM buildings AS b LEFT JOIN BuildingUtilityCosts AS buc ON b.building_id = buc.building_id LEFT JOIN AnnualOccupancy AS ao ON b.building_id = ao.building_id LEFT JOIN structural_issues AS si ON b.building_id = si.building_id AND si.issue_date > '2023-01-01' AND si.severity = 'High' JOIN building_certifications AS bc ON b.building_id = bc.building_id WHERE b.building_type = 'Commercial' AND b.year_built < 2000 AND si.building_id IS NULL AND bc.certification_type = 'LEED Platinum' ORDER BY annual_utility_cost DESC, avg_annual_occupancy DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT inv.investor_id, inv.investor_name, inv.country, (SELECT SUM(tr.amount) FROM transactions tr WHERE tr.investor_id = inv.investor_id AND tr.transaction_type = 'Equity Buy' AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_equity_buys, (SELECT AVG(pr.return_percentage) FROM portfolio_returns pr WHERE pr.investor_id = inv.investor_id AND pr.period = 'YTD') AS YTD_avg_return FROM investors inv WHERE inv.investment_focus = 'Technology' AND inv.risk_tolerance = 'High' AND inv.investor_id NOT IN (SELECT ft.investor_id FROM fraudulent_transactions ft WHERE ft.transaction_date > '2023-01-01') AND EXISTS (SELECT 1 FROM investor_preferences ip WHERE ip.investor_id = inv.investor_id AND ip.preference_type = 'ESG Investing') ORDER BY H1_equity_buys DESC, YTD_avg_return DESC LIMIT 10;","output":"WITH H1EquityBuys AS (SELECT investor_id, SUM(amount) AS H1_equity_buys FROM transactions WHERE transaction_type = 'Equity Buy' AND transaction_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY investor_id), YTDReturns AS (SELECT investor_id, AVG(return_percentage) AS YTD_avg_return FROM portfolio_returns WHERE period = 'YTD' GROUP BY investor_id) SELECT inv.investor_id, inv.investor_name, inv.country, COALESCE(heb.H1_equity_buys, 0) AS H1_equity_buys, COALESCE(ytdr.YTD_avg_return, 0) AS YTD_avg_return FROM investors AS inv LEFT JOIN H1EquityBuys AS heb ON inv.investor_id = heb.investor_id LEFT JOIN YTDReturns AS ytdr ON inv.investor_id = ytdr.investor_id LEFT JOIN fraudulent_transactions AS ft ON inv.investor_id = ft.investor_id AND ft.transaction_date > '2023-01-01' JOIN investor_preferences AS ip ON inv.investor_id = ip.investor_id WHERE inv.investment_focus = 'Technology' AND inv.risk_tolerance = 'High' AND ft.investor_id IS NULL AND ip.preference_type = 'ESG Investing' ORDER BY H1_equity_buys DESC, YTD_avg_return DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT d.division_id, d.division_name, d.head_count, (SELECT COUNT(p.project_id) FROM projects p WHERE p.division_id = d.division_id AND p.status = 'Completed' AND p.end_date BETWEEN '2023-01-01' AND '2023-12-31') AS completed_projects_2023, (SELECT AVG(e.salary) FROM employees e WHERE e.division_id = d.division_id AND e.status = 'Active') AS avg_division_salary FROM divisions d WHERE d.annual_revenue_usd > 100000000 AND d.location = 'Global' AND d.division_id NOT IN (SELECT rd.division_id FROM restructuring_data rd WHERE rd.start_date < CURDATE() AND rd.end_date > CURDATE()) AND EXISTS (SELECT 1 FROM division_goals dg WHERE dg.division_id = d.division_id AND dg.goal_year = 2023 AND dg.status = 'Achieved') ORDER BY completed_projects_2023 DESC, avg_division_salary DESC LIMIT 10;","output":"WITH CompletedProjects AS (SELECT project_id, division_id FROM projects WHERE status = 'Completed' AND end_date BETWEEN '2023-01-01' AND '2023-12-31'), DivisionProjectCounts AS (SELECT division_id, COUNT(project_id) AS completed_projects_2023 FROM CompletedProjects GROUP BY division_id), DivisionAvgSalary AS (SELECT division_id, AVG(salary) AS avg_division_salary FROM employees WHERE status = 'Active' GROUP BY division_id) SELECT d.division_id, d.division_name, d.head_count, COALESCE(dpc.completed_projects_2023, 0) AS completed_projects_2023, COALESCE(das.avg_division_salary, 0) AS avg_division_salary FROM divisions AS d LEFT JOIN DivisionProjectCounts AS dpc ON d.division_id = dpc.division_id LEFT JOIN DivisionAvgSalary AS das ON d.division_id = das.division_id LEFT JOIN restructuring_data AS rd ON d.division_id = rd.division_id AND rd.start_date < CURDATE() AND rd.end_date > CURDATE() JOIN division_goals AS dg ON d.division_id = dg.division_id WHERE d.annual_revenue_usd > 100000000 AND d.location = 'Global' AND rd.division_id IS NULL AND dg.goal_year = 2023 AND dg.status = 'Achieved' ORDER BY completed_projects_2023 DESC, avg_division_salary DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.store_id, s.store_name, s.city, s.region, (SELECT SUM(t.total_amount) FROM transactions t WHERE t.store_id = s.store_id AND t.transaction_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_total_sales, (SELECT AVG(cr.customer_satisfaction_score) FROM customer_reviews cr WHERE cr.store_id = s.store_id AND cr.review_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_satisfaction FROM stores s WHERE s.store_type = 'Retail' AND s.opening_date < '2015-01-01' AND s.store_id NOT IN (SELECT fa.store_id FROM facility_alerts fa WHERE fa.alert_date > '2023-01-01' AND fa.alert_type = 'Security Breach') AND EXISTS (SELECT 1 FROM store_products sp JOIN products p ON sp.product_id = p.product_id WHERE sp.store_id = s.store_id AND p.category_id = (SELECT category_id FROM categories WHERE category_name = 'Electronics')) ORDER BY Q1_total_sales DESC, Q1_avg_satisfaction DESC LIMIT 10;","output":"WITH Q1Sales AS (SELECT store_id, SUM(total_amount) AS Q1_total_sales FROM transactions WHERE transaction_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY store_id), Q1Satisfaction AS (SELECT store_id, AVG(customer_satisfaction_score) AS Q1_avg_satisfaction FROM customer_reviews WHERE review_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY store_id) SELECT s.store_id, s.store_name, s.city, s.region, COALESCE(qs.Q1_total_sales, 0) AS Q1_total_sales, COALESCE(qcs.Q1_avg_satisfaction, 0) AS Q1_avg_satisfaction FROM stores AS s LEFT JOIN Q1Sales AS qs ON s.store_id = qs.store_id LEFT JOIN Q1Satisfaction AS qcs ON s.store_id = qcs.store_id LEFT JOIN facility_alerts AS fa ON s.store_id = fa.store_id AND fa.alert_date > '2023-01-01' AND fa.alert_type = 'Security Breach' JOIN store_products AS sp ON s.store_id = sp.store_id JOIN products AS p ON sp.product_id = p.product_id JOIN categories AS cat ON p.category_id = cat.category_id WHERE s.store_type = 'Retail' AND s.opening_date < '2015-01-01' AND fa.store_id IS NULL AND cat.category_name = 'Electronics' GROUP BY s.store_id, s.store_name, s.city, s.region ORDER BY Q1_total_sales DESC, Q1_avg_satisfaction DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.country_name, c.population, c.gdp_usd, (SELECT AVG(le.life_expectancy) FROM demographics le WHERE le.country_id = c.country_id AND le.year = 2023) AS avg_life_expectancy_2023, (SELECT SUM(co2.emissions_metric_tons) FROM carbon_emissions co2 WHERE co2.country_id = c.country_id AND co2.year BETWEEN 2020 AND 2022) AS last_3_year_emissions FROM countries c WHERE c.continent = 'Europe' AND c.gdp_per_capita_usd > 50000 AND c.country_id NOT IN (SELECT dr.country_id FROM disaster_relief dr WHERE dr.disaster_date > '2023-01-01' AND dr.relief_amount > 1000000) AND EXISTS (SELECT 1 FROM country_trade_agreements cta WHERE cta.country_id = c.country_id AND cta.partner_country_id IN (SELECT country_id FROM countries WHERE country_name = 'USA')) ORDER BY avg_life_expectancy_2023 DESC, last_3_year_emissions ASC LIMIT 10;","output":"WITH CountryDemographics AS (SELECT country_id, AVG(life_expectancy) AS avg_life_expectancy_2023 FROM demographics WHERE year = 2023 GROUP BY country_id), CarbonEmissions AS (SELECT country_id, SUM(emissions_metric_tons) AS last_3_year_emissions FROM carbon_emissions WHERE year BETWEEN 2020 AND 2022 GROUP BY country_id), USACountry AS (SELECT country_id FROM countries WHERE country_name = 'USA') SELECT c.country_name, c.population, c.gdp_usd, COALESCE(cd.avg_life_expectancy_2023, 0) AS avg_life_expectancy_2023, COALESCE(ce.last_3_year_emissions, 0) AS last_3_year_emissions FROM countries AS c LEFT JOIN CountryDemographics AS cd ON c.country_id = cd.country_id LEFT JOIN CarbonEmissions AS ce ON c.country_id = ce.country_id LEFT JOIN disaster_relief AS dr ON c.country_id = dr.country_id AND dr.disaster_date > '2023-01-01' AND dr.relief_amount > 1000000 JOIN country_trade_agreements AS cta ON c.country_id = cta.country_id JOIN USACountry AS uc ON cta.partner_country_id = uc.country_id WHERE c.continent = 'Europe' AND c.gdp_per_capita_usd > 50000 AND dr.country_id IS NULL ORDER BY avg_life_expectancy_2023 DESC, last_3_year_emissions ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.shipping_provider_id, s.provider_name, s.country, (SELECT AVG(dt.delivery_time_days) FROM delivery_tracking dt WHERE dt.shipping_provider_id = s.shipping_provider_id AND dt.delivery_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_delivery_time, (SELECT COUNT(pkg.package_id) FROM packages pkg WHERE pkg.shipping_provider_id = s.shipping_provider_id AND pkg.status = 'Delivered' AND pkg.delivery_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_delivered_packages FROM shipping_providers s WHERE s.service_type = 'Express' AND s.rating > 4.0 AND s.shipping_provider_id NOT IN (SELECT is.provider_id FROM incident_shipments is WHERE is.incident_date > '2023-01-01' AND is.severity = 'High') AND EXISTS (SELECT 1 FROM provider_coverage pc WHERE pc.shipping_provider_id = s.shipping_provider_id AND pc.coverage_area = 'International') ORDER BY H1_avg_delivery_time ASC, H1_delivered_packages DESC LIMIT 10;","output":"WITH H1DeliveryStats AS (SELECT dt.shipping_provider_id, AVG(dt.delivery_time_days) AS H1_avg_delivery_time FROM delivery_tracking AS dt WHERE dt.delivery_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY dt.shipping_provider_id), H1DeliveredPackages AS (SELECT pkg.shipping_provider_id, COUNT(pkg.package_id) AS H1_delivered_packages FROM packages AS pkg WHERE pkg.status = 'Delivered' AND pkg.delivery_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY pkg.shipping_provider_id) SELECT s.shipping_provider_id, s.provider_name, s.country, COALESCE(hds.H1_avg_delivery_time, 0) AS H1_avg_delivery_time, COALESCE(hdp.H1_delivered_packages, 0) AS H1_delivered_packages FROM shipping_providers AS s LEFT JOIN H1DeliveryStats AS hds ON s.shipping_provider_id = hds.shipping_provider_id LEFT JOIN H1DeliveredPackages AS hdp ON s.shipping_provider_id = hdp.shipping_provider_id LEFT JOIN incident_shipments AS ins ON s.shipping_provider_id = ins.provider_id AND ins.incident_date > '2023-01-01' AND ins.severity = 'High' JOIN provider_coverage AS pc ON s.shipping_provider_id = pc.shipping_provider_id WHERE s.service_type = 'Express' AND s.rating > 4.0 AND ins.provider_id IS NULL AND pc.coverage_area = 'International' ORDER BY H1_avg_delivery_time ASC, H1_delivered_packages DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT cu.currency_code, cu.currency_name, (SELECT AVG(er.exchange_rate) FROM exchange_rates er WHERE er.to_currency_code = cu.currency_code AND er.exchange_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_exchange_rate, (SELECT MAX(er.exchange_rate) FROM exchange_rates er WHERE er.to_currency_code = cu.currency_code AND er.exchange_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_max_exchange_rate FROM currencies cu WHERE cu.is_fiat = TRUE AND cu.country_code IN ('USD', 'EUR', 'GBP') AND cu.currency_code NOT IN (SELECT cr.currency_code FROM currency_restrictions cr WHERE cr.restriction_start_date < CURDATE() AND cr.restriction_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM currency_trade_volumes ctv WHERE ctv.currency_code = cu.currency_code AND ctv.trade_date = CURDATE()) ORDER BY Q1_avg_exchange_rate DESC, Q1_max_exchange_rate DESC LIMIT 5;","output":"WITH Q1ExchangeRates AS (SELECT to_currency_code AS currency_code, AVG(exchange_rate) AS Q1_avg_exchange_rate, MAX(exchange_rate) AS Q1_max_exchange_rate FROM exchange_rates WHERE exchange_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY to_currency_code) SELECT cu.currency_code, cu.currency_name, COALESCE(qer.Q1_avg_exchange_rate, 0) AS Q1_avg_exchange_rate, COALESCE(qer.Q1_max_exchange_rate, 0) AS Q1_max_exchange_rate FROM currencies AS cu LEFT JOIN Q1ExchangeRates AS qer ON cu.currency_code = qer.currency_code LEFT JOIN currency_restrictions AS cr ON cu.currency_code = cr.currency_code AND cr.restriction_start_date < CURDATE() AND cr.restriction_end_date > CURDATE() JOIN currency_trade_volumes AS ctv ON cu.currency_code = ctv.currency_code WHERE cu.is_fiat = TRUE AND cu.country_code IN ('USD', 'EUR', 'GBP') AND cr.currency_code IS NULL AND ctv.trade_date = CURDATE() ORDER BY Q1_avg_exchange_rate DESC, Q1_max_exchange_rate DESC LIMIT 5;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.trainer_id, tr.trainer_name, tr.specialty, (SELECT COUNT(cs.client_id) FROM client_sessions cs WHERE cs.trainer_id = tr.trainer_id AND cs.session_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_sessions_count, (SELECT AVG(cs.duration_minutes) FROM client_sessions cs WHERE cs.trainer_id = tr.trainer_id AND cs.session_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_session_duration FROM trainers tr WHERE tr.experience_years > 10 AND tr.certifications LIKE '%NASM%' AND tr.trainer_id NOT IN (SELECT co.trainer_id FROM trainer_complaints co WHERE co.complaint_date > '2023-01-01' AND co.severity = 'High') AND EXISTS (SELECT 1 FROM trainer_availability ta WHERE ta.trainer_id = tr.trainer_id AND ta.day_of_week = 'Monday' AND ta.is_available = TRUE) ORDER BY H1_sessions_count DESC, H1_avg_session_duration DESC LIMIT 10;","output":"WITH H1TrainerStats AS (SELECT trainer_id, COUNT(client_id) AS H1_sessions_count, AVG(duration_minutes) AS H1_avg_session_duration FROM client_sessions WHERE session_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY trainer_id) SELECT tr.trainer_id, tr.trainer_name, tr.specialty, COALESCE(hts.H1_sessions_count, 0) AS H1_sessions_count, COALESCE(hts.H1_avg_session_duration, 0) AS H1_avg_session_duration FROM trainers AS tr LEFT JOIN H1TrainerStats AS hts ON tr.trainer_id = hts.trainer_id LEFT JOIN trainer_complaints AS tc ON tr.trainer_id = tc.trainer_id AND tc.complaint_date > '2023-01-01' AND tc.severity = 'High' JOIN trainer_availability AS ta ON tr.trainer_id = ta.trainer_id WHERE tr.experience_years > 10 AND tr.certifications LIKE '%NASM%' AND tc.trainer_id IS NULL AND ta.day_of_week = 'Monday' AND ta.is_available = TRUE ORDER BY H1_sessions_count DESC, H1_avg_session_duration DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT crs.course_id, crs.course_name, crs.department, (SELECT AVG(e.grade) FROM enrollments e WHERE e.course_id = crs.course_id AND e.enrollment_date > '2023-01-01') AS avg_grade_2023, (SELECT COUNT(DISTINCT s.student_id) FROM enrollments e JOIN students s ON e.student_id = s.student_id WHERE e.course_id = crs.course_id AND s.student_status = 'Active') AS active_students FROM courses crs WHERE crs.credits >= 3 AND crs.course_level = 'Graduate' AND crs.course_id NOT IN (SELECT oc.course_id FROM course_cancellations oc WHERE oc.cancellation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM course_prerequisites cp JOIN courses pre_crs ON cp.prerequisite_course_id = pre_crs.course_id WHERE cp.course_id = crs.course_id AND pre_crs.course_code = 'CS101') ORDER BY avg_grade_2023 DESC, active_students DESC LIMIT 15;","output":"WITH CourseGradeStats AS (SELECT course_id, AVG(grade) AS avg_grade_2023 FROM enrollments WHERE enrollment_date > '2023-01-01' GROUP BY course_id), ActiveStudentsCount AS (SELECT e.course_id, COUNT(DISTINCT s.student_id) AS active_students FROM enrollments AS e JOIN students AS s ON e.student_id = s.student_id WHERE s.student_status = 'Active' GROUP BY e.course_id) SELECT crs.course_id, crs.course_name, crs.department, COALESCE(cgs.avg_grade_2023, 0) AS avg_grade_2023, COALESCE(asc.active_students, 0) AS active_students FROM courses AS crs LEFT JOIN CourseGradeStats AS cgs ON crs.course_id = cgs.course_id LEFT JOIN ActiveStudentsCount AS asc ON crs.course_id = asc.course_id LEFT JOIN course_cancellations AS cc ON crs.course_id = cc.course_id AND cc.cancellation_date > '2023-01-01' JOIN course_prerequisites AS cp ON crs.course_id = cp.course_id JOIN courses AS pre_crs ON cp.prerequisite_course_id = pre_crs.course_id WHERE crs.credits >= 3 AND crs.course_level = 'Graduate' AND cc.course_id IS NULL AND pre_crs.course_code = 'CS101' ORDER BY avg_grade_2023 DESC, active_students DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT l.listing_id, l.title, l.price, l.posted_date, (SELECT AVG(r.rating) FROM property_reviews r WHERE r.listing_id = l.listing_id) AS avg_listing_rating, (SELECT COUNT(i.inquiry_id) FROM property_inquiries i WHERE i.listing_id = l.listing_id AND i.inquiry_date > '2023-01-01') AS recent_inquiries FROM listings l WHERE l.status = 'Active' AND l.property_type = 'Apartment' AND l.city = 'San Francisco' AND l.listing_id NOT IN (SELECT dl.listing_id FROM delisted_properties dl WHERE dl.delist_date > '2023-01-01') AND EXISTS (SELECT 1 FROM listing_amenities la WHERE la.listing_id = l.listing_id AND la.amenity_name = 'Gym') ORDER BY avg_listing_rating DESC, recent_inquiries DESC LIMIT 20;","output":"WITH ListingRatings AS (SELECT listing_id, AVG(rating) AS avg_listing_rating FROM property_reviews GROUP BY listing_id), RecentInquiries AS (SELECT listing_id, COUNT(inquiry_id) AS recent_inquiries FROM property_inquiries WHERE inquiry_date > '2023-01-01' GROUP BY listing_id) SELECT l.listing_id, l.title, l.price, l.posted_date, COALESCE(lr.avg_listing_rating, 0) AS avg_listing_rating, COALESCE(ri.recent_inquiries, 0) AS recent_inquiries FROM listings AS l LEFT JOIN ListingRatings AS lr ON l.listing_id = lr.listing_id LEFT JOIN RecentInquiries AS ri ON l.listing_id = ri.listing_id LEFT JOIN delisted_properties AS dp ON l.listing_id = dp.listing_id AND dp.delist_date > '2023-01-01' JOIN listing_amenities AS la ON l.listing_id = la.listing_id WHERE l.status = 'Active' AND l.property_type = 'Apartment' AND l.city = 'San Francisco' AND dp.listing_id IS NULL AND la.amenity_name = 'Gym' ORDER BY avg_listing_rating DESC, recent_inquiries DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT m.member_id, m.member_name, m.email, (SELECT COUNT(lp.loan_id) FROM loan_applications lp WHERE lp.member_id = m.member_id AND lp.application_date > '2023-01-01') AS loan_applications_2023, (SELECT SUM(lg.amount) FROM loan_grants lg WHERE lg.member_id = m.member_id AND lg.grant_date > '2023-01-01') AS total_loans_granted_2023 FROM members m WHERE m.status = 'Active' AND m.join_date < '2020-01-01' AND m.member_id NOT IN (SELECT dm.member_id FROM delinquent_members dm WHERE dm.delinquency_start_date < CURDATE() AND dm.delinquency_end_date > CURDATE()) AND EXISTS (SELECT 1 FROM member_benefits mb JOIN benefits b ON mb.benefit_id = b.benefit_id WHERE mb.member_id = m.member_id AND b.benefit_type = 'Financial Counseling') ORDER BY loan_applications_2023 DESC, total_loans_granted_2023 DESC LIMIT 10;","output":"WITH MemberLoanStats AS (SELECT m.member_id, COUNT(lp.loan_id) AS loan_applications_2023, SUM(lg.amount) AS total_loans_granted_2023 FROM members AS m LEFT JOIN loan_applications AS lp ON m.member_id = lp.member_id AND lp.application_date > '2023-01-01' LEFT JOIN loan_grants AS lg ON m.member_id = lg.member_id AND lg.grant_date > '2023-01-01' GROUP BY m.member_id) SELECT m.member_id, m.member_name, m.email, COALESCE(mls.loan_applications_2023, 0) AS loan_applications_2023, COALESCE(mls.total_loans_granted_2023, 0) AS total_loans_granted_2023 FROM members AS m LEFT JOIN MemberLoanStats AS mls ON m.member_id = mls.member_id LEFT JOIN delinquent_members AS dm ON m.member_id = dm.member_id AND dm.delinquency_start_date < CURDATE() AND dm.delinquency_end_date > CURDATE() JOIN member_benefits AS mb ON m.member_id = mb.member_id JOIN benefits AS b ON mb.benefit_id = b.benefit_id WHERE m.status = 'Active' AND m.join_date < '2020-01-01' AND dm.member_id IS NULL AND b.benefit_type = 'Financial Counseling' ORDER BY loan_applications_2023 DESC, total_loans_granted_2023 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.show_id, s.show_title, s.genre, (SELECT COUNT(t.ticket_id) FROM tickets t WHERE t.show_id = s.show_id AND t.sale_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_tickets_sold, (SELECT AVG(r.rating_score) FROM show_reviews r WHERE r.show_id = s.show_id AND r.review_date > '2023-01-01') AS avg_show_rating FROM shows s WHERE s.status = 'Active' AND s.run_start_date < '2022-01-01' AND s.show_id NOT IN (SELECT cc.show_id FROM show_cancellations cc WHERE cc.cancellation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM show_venues sv JOIN venues v ON sv.venue_id = v.venue_id WHERE sv.show_id = s.show_id AND v.city = 'London') ORDER BY H1_tickets_sold DESC, avg_show_rating DESC LIMIT 10;","output":"WITH H1TicketSales AS (SELECT show_id, COUNT(ticket_id) AS H1_tickets_sold FROM tickets WHERE sale_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY show_id), ShowRatings AS (SELECT show_id, AVG(rating_score) AS avg_show_rating FROM show_reviews WHERE review_date > '2023-01-01' GROUP BY show_id) SELECT s.show_id, s.show_title, s.genre, COALESCE(hts.H1_tickets_sold, 0) AS H1_tickets_sold, COALESCE(sr.avg_show_rating, 0) AS avg_show_rating FROM shows AS s LEFT JOIN H1TicketSales AS hts ON s.show_id = hts.show_id LEFT JOIN ShowRatings AS sr ON s.show_id = sr.show_id LEFT JOIN show_cancellations AS sc ON s.show_id = sc.show_id AND sc.cancellation_date > '2023-01-01' JOIN show_venues AS sv ON s.show_id = sv.show_id JOIN venues AS v ON sv.venue_id = v.venue_id WHERE s.status = 'Active' AND s.run_start_date < '2022-01-01' AND sc.show_id IS NULL AND v.city = 'London' ORDER BY H1_tickets_sold DESC, avg_show_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT art.artwork_id, art.title, art.artist_name, art.creation_year, (SELECT MAX(b.bid_amount) FROM bids b WHERE b.artwork_id = art.artwork_id AND b.bid_date > '2023-01-01') AS highest_recent_bid, (SELECT COUNT(v.visitor_id) FROM gallery_visits v WHERE v.artwork_id = art.artwork_id AND v.visit_date > '2023-01-01') AS total_recent_views FROM artworks art WHERE art.medium = 'Painting' AND art.style = 'Abstract' AND art.artwork_id NOT IN (SELECT cs.artwork_id FROM conservation_status cs WHERE cs.condition = 'Poor' AND cs.status_date > '2023-01-01') AND EXISTS (SELECT 1 FROM artwork_exhibitions ae JOIN exhibitions e ON ae.exhibition_id = e.exhibition_id WHERE ae.artwork_id = art.artwork_id AND e.start_date < CURDATE() AND e.end_date > CURDATE()) ORDER BY highest_recent_bid DESC, total_recent_views DESC LIMIT 10;","output":"WITH ArtworkBidStats AS (SELECT artwork_id, MAX(bid_amount) AS highest_recent_bid FROM bids WHERE bid_date > '2023-01-01' GROUP BY artwork_id), ArtworkViewStats AS (SELECT artwork_id, COUNT(visitor_id) AS total_recent_views FROM gallery_visits WHERE visit_date > '2023-01-01' GROUP BY artwork_id) SELECT art.artwork_id, art.title, art.artist_name, art.creation_year, COALESCE(abs.highest_recent_bid, 0) AS highest_recent_bid, COALESCE(avs.total_recent_views, 0) AS total_recent_views FROM artworks AS art LEFT JOIN ArtworkBidStats AS abs ON art.artwork_id = abs.artwork_id LEFT JOIN ArtworkViewStats AS avs ON art.artwork_id = avs.artwork_id LEFT JOIN conservation_status AS cs ON art.artwork_id = cs.artwork_id AND cs.condition = 'Poor' AND cs.status_date > '2023-01-01' JOIN artwork_exhibitions AS ae ON art.artwork_id = ae.artwork_id JOIN exhibitions AS e ON ae.exhibition_id = e.exhibition_id WHERE art.medium = 'Painting' AND art.style = 'Abstract' AND cs.artwork_id IS NULL AND e.start_date < CURDATE() AND e.end_date > CURDATE() ORDER BY highest_recent_bid DESC, total_recent_views DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT sc.scenario_id, sc.scenario_name, sc.category, (SELECT COUNT(si.incident_id) FROM security_incidents si WHERE si.scenario_id = sc.scenario_id AND si.incident_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_incidents, (SELECT AVG(sir.resolution_time_hours) FROM security_incident_resolutions sir JOIN security_incidents si ON sir.incident_id = si.incident_id WHERE si.scenario_id = sc.scenario_id AND si.incident_date BETWEEN '2023-01-01' AND '2023-12-31') AS avg_resolution_time FROM security_scenarios sc WHERE sc.severity = 'Critical' AND sc.last_updated_date < '2023-01-01' AND sc.scenario_id NOT IN (SELECT ap.scenario_id FROM audit_failures ap WHERE ap.audit_date > '2023-01-01') AND EXISTS (SELECT 1 FROM scenario_threat_actors sta JOIN threat_actors ta ON sta.threat_actor_id = ta.threat_actor_id WHERE sta.scenario_id = sc.scenario_id AND ta.actor_type = 'Nation-State') ORDER BY annual_incidents DESC, avg_resolution_time ASC LIMIT 10;","output":"WITH AnnualIncidents AS (SELECT scenario_id, COUNT(incident_id) AS annual_incidents FROM security_incidents WHERE incident_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY scenario_id), AvgResolutionTime AS (SELECT si.scenario_id, AVG(sir.resolution_time_hours) AS avg_resolution_time FROM security_incident_resolutions AS sir JOIN security_incidents AS si ON sir.incident_id = si.incident_id WHERE si.incident_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY si.scenario_id) SELECT sc.scenario_id, sc.scenario_name, sc.category, COALESCE(ai.annual_incidents, 0) AS annual_incidents, COALESCE(art.avg_resolution_time, 0) AS avg_resolution_time FROM security_scenarios AS sc LEFT JOIN AnnualIncidents AS ai ON sc.scenario_id = ai.scenario_id LEFT JOIN AvgResolutionTime AS art ON sc.scenario_id = art.scenario_id LEFT JOIN audit_failures AS af ON sc.scenario_id = af.scenario_id AND af.audit_date > '2023-01-01' JOIN scenario_threat_actors AS sta ON sc.scenario_id = sta.scenario_id JOIN threat_actors AS ta ON sta.threat_actor_id = ta.threat_actor_id WHERE sc.severity = 'Critical' AND sc.last_updated_date < '2023-01-01' AND af.scenario_id IS NULL AND ta.actor_type = 'Nation-State' ORDER BY annual_incidents DESC, avg_resolution_time ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.transaction_id, tr.transaction_date, tr.amount, ac.account_number, (SELECT SUM(sf.fee_amount) FROM transaction_fees sf WHERE sf.transaction_id = tr.transaction_id) AS total_fees, (SELECT AVG(rt.response_time_ms) FROM transaction_responses rt WHERE rt.transaction_id = tr.transaction_id AND rt.response_date > '2023-01-01') AS avg_response_time FROM transactions tr JOIN accounts ac ON tr.account_id = ac.account_id WHERE tr.transaction_type = 'Payment' AND ac.account_status = 'Active' AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-06-30' AND tr.transaction_id NOT IN (SELECT ft.transaction_id FROM fraudulent_transactions ft WHERE ft.fraud_detection_date > '2023-01-01') AND EXISTS (SELECT 1 FROM transaction_channels tc WHERE tc.transaction_id = tr.transaction_id AND tc.channel_type = 'Online') ORDER BY total_fees DESC, avg_response_time ASC LIMIT 20;","output":"WITH TransactionFees AS (SELECT transaction_id, SUM(fee_amount) AS total_fees FROM transaction_fees GROUP BY transaction_id), TransactionResponses AS (SELECT transaction_id, AVG(response_time_ms) AS avg_response_time FROM transaction_responses WHERE response_date > '2023-01-01' GROUP BY transaction_id) SELECT tr.transaction_id, tr.transaction_date, tr.amount, ac.account_number, COALESCE(tf.total_fees, 0) AS total_fees, COALESCE(tres.avg_response_time, 0) AS avg_response_time FROM transactions AS tr JOIN accounts AS ac ON tr.account_id = ac.account_id LEFT JOIN TransactionFees AS tf ON tr.transaction_id = tf.transaction_id LEFT JOIN TransactionResponses AS tres ON tr.transaction_id = tres.transaction_id LEFT JOIN fraudulent_transactions AS ft ON tr.transaction_id = ft.transaction_id AND ft.fraud_detection_date > '2023-01-01' JOIN transaction_channels AS tc ON tr.transaction_id = tc.transaction_id WHERE tr.transaction_type = 'Payment' AND ac.account_status = 'Active' AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-06-30' AND ft.transaction_id IS NULL AND tc.channel_type = 'Online' ORDER BY total_fees DESC, avg_response_time ASC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.sensor_id, s.sensor_type, s.location, s.deployment_date, (SELECT AVG(sd.reading_value) FROM sensor_data sd WHERE sd.sensor_id = s.sensor_id AND sd.reading_timestamp BETWEEN '2023-01-01' AND '2023-01-31') AS avg_jan_reading, (SELECT MAX(sd.reading_value) FROM sensor_data sd WHERE sd.sensor_id = s.sensor_id AND sd.reading_timestamp BETWEEN '2023-01-01' AND '2023-01-31') AS max_jan_reading FROM sensors s WHERE s.status = 'Active' AND s.power_source = 'Battery' AND s.sensor_id NOT IN (SELECT ce.sensor_id FROM calibration_errors ce WHERE ce.error_date > '2023-01-01') AND EXISTS (SELECT 1 FROM sensor_networks sn JOIN networks n ON sn.network_id = n.network_id WHERE sn.sensor_id = s.sensor_id AND n.network_type = 'Wireless Mesh') ORDER BY avg_jan_reading DESC, max_jan_reading DESC LIMIT 10;","output":"WITH JanReadings AS (SELECT sensor_id, AVG(reading_value) AS avg_jan_reading, MAX(reading_value) AS max_jan_reading FROM sensor_data WHERE reading_timestamp BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY sensor_id) SELECT s.sensor_id, s.sensor_type, s.location, s.deployment_date, COALESCE(jr.avg_jan_reading, 0) AS avg_jan_reading, COALESCE(jr.max_jan_reading, 0) AS max_jan_reading FROM sensors AS s LEFT JOIN JanReadings AS jr ON s.sensor_id = jr.sensor_id LEFT JOIN calibration_errors AS ce ON s.sensor_id = ce.sensor_id AND ce.error_date > '2023-01-01' JOIN sensor_networks AS sn ON s.sensor_id = sn.sensor_id JOIN networks AS n ON sn.network_id = n.network_id WHERE s.status = 'Active' AND s.power_source = 'Battery' AND ce.sensor_id IS NULL AND n.network_type = 'Wireless Mesh' ORDER BY avg_jan_reading DESC, max_jan_reading DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT proj.project_id, proj.project_name, proj.start_date, proj.end_date, (SELECT COUNT(t.task_id) FROM tasks t WHERE t.project_id = proj.project_id AND t.status = 'Completed') AS completed_tasks, (SELECT AVG(ts.actual_hours) FROM task_submissions ts JOIN tasks t ON ts.task_id = t.task_id WHERE t.project_id = proj.project_id) AS avg_task_hours FROM projects proj WHERE proj.status = 'In Progress' AND proj.budget > 50000 AND proj.project_id NOT IN (SELECT pd.project_id FROM project_disputes pd WHERE pd.dispute_date > '2023-01-01' AND pd.severity = 'High') AND EXISTS (SELECT 1 FROM project_teams pt JOIN teams tm ON pt.team_id = tm.team_id WHERE pt.project_id = proj.project_id AND tm.team_type = 'Development') ORDER BY completed_tasks DESC, avg_task_hours ASC LIMIT 15;","output":"WITH ProjectTaskStats AS (SELECT t.project_id, COUNT(t.task_id) AS completed_tasks, AVG(ts.actual_hours) AS avg_task_hours FROM tasks AS t LEFT JOIN task_submissions AS ts ON t.task_id = ts.task_id WHERE t.status = 'Completed' GROUP BY t.project_id) SELECT proj.project_id, proj.project_name, proj.start_date, proj.end_date, COALESCE(pts.completed_tasks, 0) AS completed_tasks, COALESCE(pts.avg_task_hours, 0) AS avg_task_hours FROM projects AS proj LEFT JOIN ProjectTaskStats AS pts ON proj.project_id = pts.project_id LEFT JOIN project_disputes AS pd ON proj.project_id = pd.project_id AND pd.dispute_date > '2023-01-01' AND pd.severity = 'High' JOIN project_teams AS pt ON proj.project_id = pt.project_id JOIN teams AS tm ON pt.team_id = tm.team_id WHERE proj.status = 'In Progress' AND proj.budget > 50000 AND pd.project_id IS NULL AND tm.team_type = 'Development' ORDER BY completed_tasks DESC, avg_task_hours ASC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT doc.document_id, doc.title, doc.author, doc.publish_date, (SELECT COUNT(re.read_event_id) FROM read_events re WHERE re.document_id = doc.document_id AND re.read_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_reads, (SELECT AVG(us.satisfaction_score) FROM user_feedback us WHERE us.document_id = doc.document_id) AS avg_feedback_score FROM documents doc WHERE doc.document_type = 'Research Paper' AND doc.publish_date > '2022-01-01' AND doc.document_id NOT IN (SELECT pr.document_id FROM plagiarism_reports pr WHERE pr.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM document_tags dt JOIN tags t ON dt.tag_id = t.tag_id WHERE dt.document_id = doc.document_id AND t.tag_name = 'AI Ethics') ORDER BY H1_reads DESC, avg_feedback_score DESC LIMIT 10;","output":"WITH DocumentReadStats AS (SELECT document_id, COUNT(read_event_id) AS H1_reads FROM read_events WHERE read_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY document_id), FeedbackScores AS (SELECT document_id, AVG(satisfaction_score) AS avg_feedback_score FROM user_feedback GROUP BY document_id) SELECT doc.document_id, doc.title, doc.author, doc.publish_date, COALESCE(drs.H1_reads, 0) AS H1_reads, COALESCE(fs.avg_feedback_score, 0) AS avg_feedback_score FROM documents AS doc LEFT JOIN DocumentReadStats AS drs ON doc.document_id = drs.document_id LEFT JOIN FeedbackScores AS fs ON doc.document_id = fs.document_id LEFT JOIN plagiarism_reports AS pr ON doc.document_id = pr.document_id AND pr.report_date > '2023-01-01' JOIN document_tags AS dt ON doc.document_id = dt.document_id JOIN tags AS t ON dt.tag_id = t.tag_id WHERE doc.document_type = 'Research Paper' AND doc.publish_date > '2022-01-01' AND pr.document_id IS NULL AND t.tag_name = 'AI Ethics' ORDER BY H1_reads DESC, avg_feedback_score DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.school_id, s.school_name, s.city, (SELECT COUNT(st.student_id) FROM students st WHERE st.school_id = s.school_id AND st.enrollment_date > '2023-01-01') AS new_students_2023, (SELECT AVG(t.teacher_rating) FROM teachers t WHERE t.school_id = s.school_id) AS avg_teacher_rating FROM schools s WHERE s.school_type = 'Primary' AND s.founding_year < 1950 AND s.school_id NOT IN (SELECT cp.school_id FROM compliance_violations cp WHERE cp.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM school_programs sp WHERE sp.school_id = s.school_id AND sp.program_type = 'STEM') ORDER BY new_students_2023 DESC, avg_teacher_rating DESC LIMIT 10;","output":"WITH SchoolStudentStats AS (SELECT school_id, COUNT(student_id) AS new_students_2023 FROM students WHERE enrollment_date > '2023-01-01' GROUP BY school_id), TeacherRatings AS (SELECT school_id, AVG(teacher_rating) AS avg_teacher_rating FROM teachers GROUP BY school_id) SELECT s.school_id, s.school_name, s.city, COALESCE(sss.new_students_2023, 0) AS new_students_2023, COALESCE(tr.avg_teacher_rating, 0) AS avg_teacher_rating FROM schools AS s LEFT JOIN SchoolStudentStats AS sss ON s.school_id = sss.school_id LEFT JOIN TeacherRatings AS tr ON s.school_id = tr.school_id LEFT JOIN compliance_violations AS cv ON s.school_id = cv.school_id AND cv.violation_date > '2023-01-01' JOIN school_programs AS sp ON s.school_id = sp.school_id WHERE s.school_type = 'Primary' AND s.founding_year < 1950 AND cv.school_id IS NULL AND sp.program_type = 'STEM' ORDER BY new_students_2023 DESC, avg_teacher_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.speaker_id, s.speaker_name, s.specialization, (SELECT COUNT(p.presentation_id) FROM presentations p WHERE p.speaker_id = s.speaker_id AND p.event_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_presentations, (SELECT AVG(fb.feedback_score) FROM presentation_feedback fb WHERE fb.speaker_id = s.speaker_id) AS avg_feedback FROM speakers s WHERE s.country = 'USA' AND s.speaking_experience_years > 5 AND s.speaker_id NOT IN (SELECT cc.speaker_id FROM conflict_of_interest_reports cc WHERE cc.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM speaker_topics st JOIN topics t ON st.topic_id = t.topic_id WHERE st.speaker_id = s.speaker_id AND t.topic_name = 'Machine Learning') ORDER BY annual_presentations DESC, avg_feedback DESC LIMIT 10;","output":"WITH SpeakerPresentationStats AS (SELECT p.speaker_id, COUNT(p.presentation_id) AS annual_presentations FROM presentations AS p WHERE p.event_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY p.speaker_id), SpeakerFeedbackStats AS (SELECT speaker_id, AVG(feedback_score) AS avg_feedback FROM presentation_feedback GROUP BY speaker_id) SELECT s.speaker_id, s.speaker_name, s.specialization, COALESCE(sps.annual_presentations, 0) AS annual_presentations, COALESCE(sfs.avg_feedback, 0) AS avg_feedback FROM speakers AS s LEFT JOIN SpeakerPresentationStats AS sps ON s.speaker_id = sps.speaker_id LEFT JOIN SpeakerFeedbackStats AS sfs ON s.speaker_id = sfs.speaker_id LEFT JOIN conflict_of_interest_reports AS coir ON s.speaker_id = coir.speaker_id AND coir.report_date > '2023-01-01' JOIN speaker_topics AS st ON s.speaker_id = st.speaker_id JOIN topics AS t ON st.topic_id = t.topic_id WHERE s.country = 'USA' AND s.speaking_experience_years > 5 AND coir.speaker_id IS NULL AND t.topic_name = 'Machine Learning' ORDER BY annual_presentations DESC, avg_feedback DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.trade_id, tr.trade_date, tr.symbol, tr.quantity, (SELECT AVG(tp.price) FROM trade_prices tp WHERE tp.trade_id = tr.trade_id AND tp.price_date = tr.trade_date) AS actual_trade_price, (SELECT MAX(tp.volume) FROM trade_prices tp WHERE tp.trade_id = tr.trade_id AND tp.price_date = tr.trade_date) AS max_trade_volume FROM trades tr WHERE tr.trade_type = 'Buy' AND tr.trade_date BETWEEN '2023-01-01' AND '2023-01-31' AND tr.account_id IN (SELECT DISTINCT ia.account_id FROM investor_accounts ia WHERE ia.status = 'Active') AND NOT EXISTS (SELECT 1 FROM trade_alerts ta WHERE ta.trade_id = tr.trade_id AND ta.alert_type = 'Unusual Volume') ORDER BY actual_trade_price DESC, max_trade_volume DESC LIMIT 20;","output":"SELECT tr.trade_id, tr.trade_date, tr.symbol, tr.quantity, COALESCE(tp.price, 0) AS actual_trade_price, COALESCE(tp.volume, 0) AS max_trade_volume FROM trades AS tr JOIN investor_accounts AS ia ON tr.account_id = ia.account_id LEFT JOIN trade_prices AS tp ON tr.trade_id = tp.trade_id AND tp.price_date = tr.trade_date LEFT JOIN trade_alerts AS ta ON tr.trade_id = ta.trade_id AND ta.alert_type = 'Unusual Volume' WHERE tr.trade_type = 'Buy' AND tr.trade_date BETWEEN '2023-01-01' AND '2023-01-31' AND ia.status = 'Active' AND ta.trade_id IS NULL ORDER BY actual_trade_price DESC, max_trade_volume DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_id, c.campaign_name, c.start_date, (SELECT SUM(cm.conversions) FROM campaign_performance cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_conversions, (SELECT AVG(cm.cpc) FROM campaign_performance cm WHERE cm.campaign_id = c.campaign_id AND cm.metric_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_cpc FROM campaigns c WHERE c.campaign_type = 'Search' AND c.budget > 5000 AND c.campaign_id NOT IN (SELECT pr.campaign_id FROM policy_violations pr WHERE pr.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM campaign_audiences ca JOIN audiences a ON ca.audience_id = a.audience_id WHERE ca.campaign_id = c.campaign_id AND a.audience_segment = 'High Intent') ORDER BY Q1_conversions DESC, Q1_avg_cpc ASC LIMIT 10;","output":"WITH Q1CampaignPerformance AS (SELECT campaign_id, SUM(conversions) AS Q1_conversions, AVG(cpc) AS Q1_avg_cpc FROM campaign_performance WHERE metric_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY campaign_id) SELECT c.campaign_id, c.campaign_name, c.start_date, COALESCE(qcp.Q1_conversions, 0) AS Q1_conversions, COALESCE(qcp.Q1_avg_cpc, 0) AS Q1_avg_cpc FROM campaigns AS c LEFT JOIN Q1CampaignPerformance AS qcp ON c.campaign_id = qcp.campaign_id LEFT JOIN policy_violations AS pv ON c.campaign_id = pv.campaign_id AND pv.violation_date > '2023-01-01' JOIN campaign_audiences AS ca ON c.campaign_id = ca.campaign_id JOIN audiences AS a ON ca.audience_id = a.audience_id WHERE c.campaign_type = 'Search' AND c.budget > 5000 AND pv.campaign_id IS NULL AND a.audience_segment = 'High Intent' ORDER BY Q1_conversions DESC, Q1_avg_cpc ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pr.product_id, pr.product_name, pr.category_id, (SELECT SUM(s.quantity) FROM sales s WHERE s.product_id = pr.product_id AND s.sale_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_sales_quantity, (SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = pr.product_id AND r.review_date > '2023-01-01') AS avg_product_rating FROM products pr WHERE pr.price > 200 AND pr.stock_level > 0 AND pr.category_id IN (SELECT cat.category_id FROM categories cat WHERE cat.category_name LIKE '%Gaming%') AND pr.product_id NOT IN (SELECT ir.product_id FROM inventory_reconciliation ir WHERE ir.discrepancy_date > '2023-01-01') ORDER BY H1_sales_quantity DESC, avg_product_rating DESC LIMIT 20;","output":"WITH H1SalesQuantity AS (SELECT product_id, SUM(quantity) AS H1_sales_quantity FROM sales WHERE sale_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY product_id), ProductRatings AS (SELECT product_id, AVG(rating) AS avg_product_rating FROM reviews WHERE review_date > '2023-01-01' GROUP BY product_id) SELECT pr.product_id, pr.product_name, pr.category_id, COALESCE(hsq.H1_sales_quantity, 0) AS H1_sales_quantity, COALESCE(prt.avg_product_rating, 0) AS avg_product_rating FROM products AS pr JOIN categories AS cat ON pr.category_id = cat.category_id LEFT JOIN H1SalesQuantity AS hsq ON pr.product_id = hsq.product_id LEFT JOIN ProductRatings AS prt ON pr.product_id = prt.product_id LEFT JOIN inventory_reconciliation AS ir ON pr.product_id = ir.product_id AND ir.discrepancy_date > '2023-01-01' WHERE pr.price > 200 AND pr.stock_level > 0 AND cat.category_name LIKE '%Gaming%' AND ir.product_id IS NULL ORDER BY H1_sales_quantity DESC, avg_product_rating DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.student_id, s.first_name, s.last_name, (SELECT AVG(g.score) FROM grades g WHERE g.student_id = s.student_id AND g.exam_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_score, (SELECT COUNT(DISTINCT c.course_id) FROM enrollments e JOIN courses c ON e.course_id = c.course_id WHERE e.student_id = s.student_id AND c.department = 'Computer Science') AS cs_course_count FROM students s WHERE s.enrollment_year = 2022 AND s.major = 'Computer Science' AND s.student_id NOT IN (SELECT da.student_id FROM disciplinary_actions da WHERE da.action_date > '2023-01-01' AND da.severity = 'Expulsion') AND EXISTS (SELECT 1 FROM student_achievements sa WHERE sa.student_id = s.student_id AND sa.achievement_type = 'Dean''s List') ORDER BY H1_avg_score DESC, cs_course_count DESC LIMIT 15;","output":"WITH H1AvgScore AS (SELECT student_id, AVG(score) AS H1_avg_score FROM grades WHERE exam_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY student_id), CSCourseCount AS (SELECT e.student_id, COUNT(DISTINCT c.course_id) AS cs_course_count FROM enrollments AS e JOIN courses AS c ON e.course_id = c.course_id WHERE c.department = 'Computer Science' GROUP BY e.student_id) SELECT s.student_id, s.first_name, s.last_name, COALESCE(has.H1_avg_score, 0) AS H1_avg_score, COALESCE(cscc.cs_course_count, 0) AS cs_course_count FROM students AS s LEFT JOIN H1AvgScore AS has ON s.student_id = has.student_id LEFT JOIN CSCourseCount AS cscc ON s.student_id = cscc.student_id LEFT JOIN disciplinary_actions AS da ON s.student_id = da.student_id AND da.action_date > '2023-01-01' AND da.severity = 'Expulsion' JOIN student_achievements AS sa ON s.student_id = sa.student_id WHERE s.enrollment_year = 2022 AND s.major = 'Computer Science' AND da.student_id IS NULL AND sa.achievement_type = 'Dean''s List' ORDER BY H1_avg_score DESC, cs_course_count DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pa.patent_id, pa.title, pa.inventor, pa.filing_date, (SELECT COUNT(l.license_id) FROM licenses l WHERE l.patent_id = pa.patent_id AND l.license_start_date > '2023-01-01') AS new_licenses_2023, (SELECT SUM(r.royalty_amount) FROM royalties r WHERE r.patent_id = pa.patent_id AND r.payment_date > '2023-01-01') AS total_royalties_2023 FROM patents pa WHERE pa.status = 'Granted' AND pa.filing_date BETWEEN '2010-01-01' AND '2020-12-31' AND pa.patent_id NOT IN (SELECT iv.patent_id FROM infringement_violations iv WHERE iv.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM patent_claims pc WHERE pc.patent_id = pa.patent_id AND pc.claim_type = 'Method') ORDER BY new_licenses_2023 DESC, total_royalties_2023 DESC LIMIT 10;","output":"WITH PatentLicenseStats AS (SELECT l.patent_id, COUNT(l.license_id) AS new_licenses_2023 FROM licenses AS l WHERE l.license_start_date > '2023-01-01' GROUP BY l.patent_id), PatentRoyalties AS (SELECT r.patent_id, SUM(r.royalty_amount) AS total_royalties_2023 FROM royalties AS r WHERE r.payment_date > '2023-01-01' GROUP BY r.patent_id) SELECT pa.patent_id, pa.title, pa.inventor, pa.filing_date, COALESCE(pls.new_licenses_2023, 0) AS new_licenses_2023, COALESCE(pr.total_royalties_2023, 0) AS total_royalties_2023 FROM patents AS pa LEFT JOIN PatentLicenseStats AS pls ON pa.patent_id = pls.patent_id LEFT JOIN PatentRoyalties AS pr ON pa.patent_id = pr.patent_id LEFT JOIN infringement_violations AS iv ON pa.patent_id = iv.patent_id AND iv.violation_date > '2023-01-01' JOIN patent_claims AS pc ON pa.patent_id = pc.patent_id WHERE pa.status = 'Granted' AND pa.filing_date BETWEEN '2010-01-01' AND '2020-12-31' AND iv.patent_id IS NULL AND pc.claim_type = 'Method' ORDER BY new_licenses_2023 DESC, total_royalties_2023 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT co.country_code, co.country_name, co.continent, (SELECT AVG(gd.gdp_per_capita) FROM gdp_data gd WHERE gd.country_code = co.country_code AND gd.year BETWEEN 2020 AND 2022) AS avg_gdp_last_3_years, (SELECT SUM(tr.export_value) FROM trade_data tr WHERE tr.country_code = co.country_code AND tr.year = 2023) AS current_year_exports FROM countries co WHERE co.population > 10000000 AND co.gdp_usd > 100000000000 AND co.country_code NOT IN (SELECT sa.country_code FROM sanctions_list sa WHERE sa.start_date < CURDATE() AND sa.end_date > CURDATE()) AND EXISTS (SELECT 1 FROM country_alliances ca JOIN alliances al ON ca.alliance_id = al.alliance_id WHERE ca.country_code = co.country_code AND al.alliance_type = 'Economic') ORDER BY avg_gdp_last_3_years DESC, current_year_exports DESC LIMIT 10;","output":"WITH GDPStats AS (SELECT country_code, AVG(gdp_per_capita) AS avg_gdp_last_3_years FROM gdp_data WHERE year BETWEEN 2020 AND 2022 GROUP BY country_code), TradeStats AS (SELECT country_code, SUM(export_value) AS current_year_exports FROM trade_data WHERE year = 2023 GROUP BY country_code) SELECT co.country_code, co.country_name, co.continent, COALESCE(gs.avg_gdp_last_3_years, 0) AS avg_gdp_last_3_years, COALESCE(ts.current_year_exports, 0) AS current_year_exports FROM countries AS co LEFT JOIN GDPStats AS gs ON co.country_code = gs.country_code LEFT JOIN TradeStats AS ts ON co.country_code = ts.country_code LEFT JOIN sanctions_list AS sl ON co.country_code = sl.country_code AND sl.start_date < CURDATE() AND sl.end_date > CURDATE() JOIN country_alliances AS ca ON co.country_code = ca.country_code JOIN alliances AS al ON ca.alliance_id = al.alliance_id WHERE co.population > 10000000 AND co.gdp_usd > 100000000000 AND sl.country_code IS NULL AND al.alliance_type = 'Economic' ORDER BY avg_gdp_last_3_years DESC, current_year_exports DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.track_id, tr.track_name, tr.artist_id, ar.artist_name, (SELECT COUNT(pl.playlist_id) FROM playlist_tracks pl WHERE pl.track_id = tr.track_id AND pl.added_date > '2023-01-01') AS added_to_playlists_2023, (SELECT AVG(ur.rating) FROM user_track_ratings ur WHERE ur.track_id = tr.track_id AND ur.rating_date > '2023-01-01') AS avg_track_rating FROM tracks tr JOIN artists ar ON tr.artist_id = ar.artist_id WHERE tr.genre = 'Hip Hop' AND tr.release_date BETWEEN '2020-01-01' AND '2022-12-31' AND tr.track_id NOT IN (SELECT cr.track_id FROM copyright_violations cr WHERE cr.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM track_features tf WHERE tf.track_id = tr.track_id AND tf.feature_type = 'Explicit Lyrics') ORDER BY added_to_playlists_2023 DESC, avg_track_rating DESC LIMIT 15;","output":"WITH PlaylistAdds AS (SELECT track_id, COUNT(playlist_id) AS added_to_playlists_2023 FROM playlist_tracks WHERE added_date > '2023-01-01' GROUP BY track_id), TrackRatings AS (SELECT track_id, AVG(rating) AS avg_track_rating FROM user_track_ratings WHERE rating_date > '2023-01-01' GROUP BY track_id) SELECT tr.track_id, tr.track_name, tr.artist_id, ar.artist_name, COALESCE(pa.added_to_playlists_2023, 0) AS added_to_playlists_2023, COALESCE(trr.avg_track_rating, 0) AS avg_track_rating FROM tracks AS tr JOIN artists AS ar ON tr.artist_id = ar.artist_id LEFT JOIN PlaylistAdds AS pa ON tr.track_id = pa.track_id LEFT JOIN TrackRatings AS trr ON tr.track_id = trr.track_id LEFT JOIN copyright_violations AS cv ON tr.track_id = cv.track_id AND cv.violation_date > '2023-01-01' JOIN track_features AS tf ON tr.track_id = tf.track_id WHERE tr.genre = 'Hip Hop' AND tr.release_date BETWEEN '2020-01-01' AND '2022-12-31' AND cv.track_id IS NULL AND tf.feature_type = 'Explicit Lyrics' ORDER BY added_to_playlists_2023 DESC, avg_track_rating DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.stock_id, s.symbol, s.company_name, (SELECT AVG(sh.high_price) FROM stock_history sh WHERE sh.stock_id = s.stock_id AND sh.trade_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_high_price, (SELECT SUM(sh.volume) FROM stock_history sh WHERE sh.stock_id = s.stock_id AND sh.trade_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_total_volume FROM stocks s WHERE s.sector = 'Technology' AND s.market_cap_usd > 10000000000 AND s.stock_id NOT IN (SELECT del.stock_id FROM delisted_stocks del WHERE del.delist_date > '2023-01-01') AND EXISTS (SELECT 1 FROM analyst_ratings ar WHERE ar.stock_id = s.stock_id AND ar.rating = 'Buy') ORDER BY Q1_total_volume DESC, Q1_avg_high_price DESC LIMIT 15;","output":"WITH Q1StockStats AS (SELECT stock_id, AVG(high_price) AS Q1_avg_high_price, SUM(volume) AS Q1_total_volume FROM stock_history WHERE trade_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY stock_id) SELECT s.stock_id, s.symbol, s.company_name, COALESCE(qss.Q1_avg_high_price, 0) AS Q1_avg_high_price, COALESCE(qss.Q1_total_volume, 0) AS Q1_total_volume FROM stocks AS s LEFT JOIN Q1StockStats AS qss ON s.stock_id = qss.stock_id LEFT JOIN delisted_stocks AS ds ON s.stock_id = ds.stock_id AND ds.delist_date > '2023-01-01' JOIN analyst_ratings AS ar ON s.stock_id = ar.stock_id WHERE s.sector = 'Technology' AND s.market_cap_usd > 10000000000 AND ds.stock_id IS NULL AND ar.rating = 'Buy' ORDER BY Q1_total_volume DESC, Q1_avg_high_price DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT ve.voter_id, ve.first_name, ve.last_name, (SELECT MAX(vp.vote_date) FROM voter_participations vp WHERE vp.voter_id = ve.voter_id) AS last_vote_date, (SELECT COUNT(vp.vote_id) FROM voter_participations vp WHERE vp.voter_id = ve.voter_id AND vp.election_year = 2022) AS votes_2022 FROM voters ve WHERE ve.registration_date > '2020-01-01' AND ve.party_affiliation = 'Independent' AND ve.voter_id NOT IN (SELECT vr.voter_id FROM voter_registrations_removed vr WHERE vr.removal_date > '2023-01-01') AND EXISTS (SELECT 1 FROM voter_donations vd WHERE vd.voter_id = ve.voter_id AND vd.donation_amount > 500) ORDER BY last_vote_date DESC, votes_2022 DESC LIMIT 10;","output":"WITH VoterParticipationStats AS (SELECT voter_id, MAX(vote_date) AS last_vote_date, COUNT(CASE WHEN election_year = 2022 THEN vote_id END) AS votes_2022 FROM voter_participations GROUP BY voter_id) SELECT ve.voter_id, ve.first_name, ve.last_name, vps.last_vote_date, COALESCE(vps.votes_2022, 0) AS votes_2022 FROM voters AS ve LEFT JOIN VoterParticipationStats AS vps ON ve.voter_id = vps.voter_id LEFT JOIN voter_registrations_removed AS vrr ON ve.voter_id = vrr.voter_id AND vrr.removal_date > '2023-01-01' JOIN voter_donations AS vd ON ve.voter_id = vd.voter_id WHERE ve.registration_date > '2020-01-01' AND ve.party_affiliation = 'Independent' AND vrr.voter_id IS NULL AND vd.donation_amount > 500 ORDER BY last_vote_date DESC, votes_2022 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.campaign_id, c.campaign_name, c.start_date, (SELECT SUM(ad.spend) FROM ad_data ad WHERE ad.campaign_id = c.campaign_id AND ad.date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_ad_spend, (SELECT AVG(ad.cpm) FROM ad_data ad WHERE ad.campaign_id = c.campaign_id AND ad.date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_avg_cpm FROM campaigns c WHERE c.status = 'Running' AND c.target_audience = 'Youth' AND c.campaign_id NOT IN (SELECT iv.campaign_id FROM invalid_traffic_reports iv WHERE iv.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM campaign_platforms cp JOIN platforms p ON cp.platform_id = p.platform_id WHERE cp.campaign_id = c.campaign_id AND p.platform_name = 'TikTok') ORDER BY Q1_ad_spend DESC, Q1_avg_cpm DESC LIMIT 10;","output":"WITH Q1AdMetrics AS (SELECT campaign_id, SUM(spend) AS Q1_ad_spend, AVG(cpm) AS Q1_avg_cpm FROM ad_data WHERE date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY campaign_id) SELECT c.campaign_id, c.campaign_name, c.start_date, COALESCE(qam.Q1_ad_spend, 0) AS Q1_ad_spend, COALESCE(qam.Q1_avg_cpm, 0) AS Q1_avg_cpm FROM campaigns AS c LEFT JOIN Q1AdMetrics AS qam ON c.campaign_id = qam.campaign_id LEFT JOIN invalid_traffic_reports AS itr ON c.campaign_id = itr.campaign_id AND itr.report_date > '2023-01-01' JOIN campaign_platforms AS cp ON c.campaign_id = cp.campaign_id JOIN platforms AS p ON cp.platform_id = p.platform_id WHERE c.status = 'Running' AND c.target_audience = 'Youth' AND itr.campaign_id IS NULL AND p.platform_name = 'TikTok' ORDER BY Q1_ad_spend DESC, Q1_avg_cpm DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT u.user_id, u.username, u.last_login_date, (SELECT COUNT(f.follow_id) FROM followers f WHERE f.following_id = u.user_id AND f.follow_date > '2023-01-01') AS new_followers_2023, (SELECT COUNT(p.post_id) FROM posts p WHERE p.user_id = u.user_id AND p.created_at > '2023-01-01' AND p.likes > 100) AS high_engagement_posts FROM users u WHERE u.account_status = 'Active' AND u.registration_date BETWEEN '2021-01-01' AND '2022-12-31' AND u.user_id NOT IN (SELECT pr.user_id FROM privacy_violations pr WHERE pr.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM user_settings us WHERE us.user_id = u.user_id AND us.setting_name = 'Public Profile' AND us.setting_value = 'True') ORDER BY new_followers_2023 DESC, high_engagement_posts DESC LIMIT 15;","output":"WITH UserFollowerStats AS (SELECT following_id AS user_id, COUNT(follow_id) AS new_followers_2023 FROM followers WHERE follow_date > '2023-01-01' GROUP BY following_id), UserPostEngagement AS (SELECT user_id, COUNT(post_id) AS high_engagement_posts FROM posts WHERE created_at > '2023-01-01' AND likes > 100 GROUP BY user_id) SELECT u.user_id, u.username, u.last_login_date, COALESCE(ufs.new_followers_2023, 0) AS new_followers_2023, COALESCE(upe.high_engagement_posts, 0) AS high_engagement_posts FROM users AS u LEFT JOIN UserFollowerStats AS ufs ON u.user_id = ufs.user_id LEFT JOIN UserPostEngagement AS upe ON u.user_id = upe.user_id LEFT JOIN privacy_violations AS pv ON u.user_id = pv.user_id AND pv.violation_date > '2023-01-01' JOIN user_settings AS us ON u.user_id = us.user_id WHERE u.account_status = 'Active' AND u.registration_date BETWEEN '2021-01-01' AND '2022-12-31' AND pv.user_id IS NULL AND us.setting_name = 'Public Profile' AND us.setting_value = 'True' ORDER BY new_followers_2023 DESC, high_engagement_posts DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.transaction_id, tr.transaction_type, tr.amount, tr.transaction_date, (SELECT ba.balance_after_transaction FROM bank_accounts ba WHERE ba.account_id = tr.account_id AND ba.transaction_id = tr.transaction_id) AS post_transaction_balance, (SELECT COUNT(al.alert_id) FROM security_alerts al WHERE al.transaction_id = tr.transaction_id AND al.alert_type = 'Fraudulent Activity') AS fraud_alerts_count FROM transactions tr WHERE tr.account_id IN (SELECT DISTINCT ca.account_id FROM customer_accounts ca WHERE ca.customer_id IN (SELECT customer_id FROM customers WHERE country = 'USA')) AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-03-31' AND tr.status = 'Completed' AND tr.transaction_id NOT IN (SELECT rv.transaction_id FROM reversed_transactions rv WHERE rv.reversal_date > '2023-01-01') ORDER BY fraud_alerts_count DESC, post_transaction_balance DESC LIMIT 20;","output":"WITH TransactionBalance AS (SELECT account_id, transaction_id, balance_after_transaction FROM bank_accounts), FraudAlerts AS (SELECT transaction_id, COUNT(alert_id) AS fraud_alerts_count FROM security_alerts WHERE alert_type = 'Fraudulent Activity' GROUP BY transaction_id) SELECT tr.transaction_id, tr.transaction_type, tr.amount, tr.transaction_date, tbal.balance_after_transaction AS post_transaction_balance, COALESCE(fa.fraud_alerts_count, 0) AS fraud_alerts_count FROM transactions AS tr JOIN customer_accounts AS ca ON tr.account_id = ca.account_id JOIN customers AS cust ON ca.customer_id = cust.customer_id LEFT JOIN TransactionBalance AS tbal ON tr.account_id = tbal.account_id AND tr.transaction_id = tbal.transaction_id LEFT JOIN FraudAlerts AS fa ON tr.transaction_id = fa.transaction_id LEFT JOIN reversed_transactions AS rt ON tr.transaction_id = rt.transaction_id AND rt.reversal_date > '2023-01-01' WHERE cust.country = 'USA' AND tr.transaction_date BETWEEN '2023-01-01' AND '2023-03-31' AND tr.status = 'Completed' AND rt.transaction_id IS NULL ORDER BY fraud_alerts_count DESC, post_transaction_balance DESC LIMIT 20;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT s.server_id, s.hostname, s.ip_address, (SELECT AVG(cpu.usage_percent) FROM cpu_metrics cpu WHERE cpu.server_id = s.server_id AND cpu.metric_date BETWEEN '2023-01-01' AND '2023-01-31') AS avg_jan_cpu, (SELECT SUM(mem.memory_used_gb) FROM memory_metrics mem WHERE mem.server_id = s.server_id AND mem.metric_date BETWEEN '2023-01-01' AND '2023-01-31') AS total_jan_memory_used FROM servers s WHERE s.status = 'Operational' AND s.environment = 'Production' AND s.server_id NOT IN (SELECT ofl.server_id FROM outage_failures ofl WHERE ofl.outage_date > '2023-01-01') AND EXISTS (SELECT 1 FROM server_roles sr JOIN roles r ON sr.role_id = r.role_id WHERE sr.server_id = s.server_id AND r.role_name = 'Web Server') ORDER BY avg_jan_cpu DESC, total_jan_memory_used DESC LIMIT 10;","output":"WITH JanCPUMetrics AS (SELECT server_id, AVG(usage_percent) AS avg_jan_cpu FROM cpu_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY server_id), JanMemoryMetrics AS (SELECT server_id, SUM(memory_used_gb) AS total_jan_memory_used FROM memory_metrics WHERE metric_date BETWEEN '2023-01-01' AND '2023-01-31' GROUP BY server_id) SELECT s.server_id, s.hostname, s.ip_address, COALESCE(jcm.avg_jan_cpu, 0) AS avg_jan_cpu, COALESCE(jmm.total_jan_memory_used, 0) AS total_jan_memory_used FROM servers AS s LEFT JOIN JanCPUMetrics AS jcm ON s.server_id = jcm.server_id LEFT JOIN JanMemoryMetrics AS jmm ON s.server_id = jmm.server_id LEFT JOIN outage_failures AS ofl ON s.server_id = ofl.server_id AND ofl.outage_date > '2023-01-01' JOIN server_roles AS sr ON s.server_id = sr.server_id JOIN roles AS r ON sr.role_id = r.role_id WHERE s.status = 'Operational' AND s.environment = 'Production' AND ofl.server_id IS NULL AND r.role_name = 'Web Server' ORDER BY avg_jan_cpu DESC, total_jan_memory_used DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT p.patient_id, p.first_name, p.last_name, (SELECT COUNT(v.visit_id) FROM visits v WHERE v.patient_id = p.patient_id AND v.visit_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_visits, (SELECT MAX(v.diagnosis_code) FROM visits v WHERE v.patient_id = p.patient_id) AS last_diagnosis FROM patients p WHERE p.gender = 'Male' AND p.age BETWEEN 50 AND 70 AND p.patient_id NOT IN (SELECT pr.patient_id FROM prescription_refills pr WHERE pr.refill_date > '2023-01-01' AND pr.medication_id IN (SELECT drug_id FROM drugs WHERE is_controlled = TRUE)) AND EXISTS (SELECT 1 FROM patient_conditions pc JOIN conditions c ON pc.condition_id = c.condition_id WHERE pc.patient_id = p.patient_id AND c.condition_name = 'Diabetes') ORDER BY H1_visits DESC, last_diagnosis ASC LIMIT 10;","output":"WITH PatientVisitStats AS (SELECT patient_id, COUNT(visit_id) AS H1_visits, MAX(diagnosis_code) AS last_diagnosis FROM visits WHERE visit_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY patient_id) SELECT p.patient_id, p.first_name, p.last_name, COALESCE(pvs.H1_visits, 0) AS H1_visits, pvs.last_diagnosis FROM patients AS p LEFT JOIN PatientVisitStats AS pvs ON p.patient_id = pvs.patient_id LEFT JOIN prescription_refills AS pr ON p.patient_id = pr.patient_id AND pr.refill_date > '2023-01-01' LEFT JOIN drugs AS d ON pr.medication_id = d.drug_id AND d.is_controlled = TRUE JOIN patient_conditions AS pc ON p.patient_id = pc.patient_id JOIN conditions AS c ON pc.condition_id = c.condition_id WHERE p.gender = 'Male' AND p.age BETWEEN 50 AND 70 AND pr.patient_id IS NULL AND c.condition_name = 'Diabetes' ORDER BY H1_visits DESC, last_diagnosis ASC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT c.class_id, c.class_name, c.instructor_name, (SELECT COUNT(e.enrollment_id) FROM enrollments e WHERE e.class_id = c.class_id AND e.enrollment_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_enrollments, (SELECT AVG(g.grade_value) FROM grades g WHERE g.class_id = c.class_id AND g.grade_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_grade FROM classes c WHERE c.semester = 'Spring 2023' AND c.department = 'Arts' AND c.class_id NOT IN (SELECT wc.class_id FROM waitlist_classes wc WHERE wc.waitlist_count > 10) AND EXISTS (SELECT 1 FROM class_materials cm WHERE cm.class_id = c.class_id AND cm.material_type = 'Textbook') ORDER BY H1_enrollments DESC, H1_avg_grade DESC LIMIT 10;","output":"WITH H1Enrollments AS (SELECT class_id, COUNT(enrollment_id) AS H1_enrollments FROM enrollments WHERE enrollment_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY class_id), H1AvgGrade AS (SELECT class_id, AVG(grade_value) AS H1_avg_grade FROM grades WHERE grade_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY class_id) SELECT c.class_id, c.class_name, c.instructor_name, COALESCE(he.H1_enrollments, 0) AS H1_enrollments, COALESCE(hag.H1_avg_grade, 0) AS H1_avg_grade FROM classes AS c LEFT JOIN H1Enrollments AS he ON c.class_id = he.class_id LEFT JOIN H1AvgGrade AS hag ON c.class_id = hag.class_id LEFT JOIN waitlist_classes AS wc ON c.class_id = wc.class_id AND wc.waitlist_count > 10 JOIN class_materials AS cm ON c.class_id = cm.class_id WHERE c.semester = 'Spring 2023' AND c.department = 'Arts' AND wc.class_id IS NULL AND cm.material_type = 'Textbook' ORDER BY H1_enrollments DESC, H1_avg_grade DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pub.publisher_id, pub.publisher_name, pub.country, (SELECT COUNT(b.book_id) FROM books b WHERE b.publisher_id = pub.publisher_id AND b.publication_year = 2023) AS new_books_2023, (SELECT SUM(s.royalty_amount) FROM sales_royalty s WHERE s.publisher_id = pub.publisher_id AND s.sale_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_royalties_2023 FROM publishers pub WHERE pub.founding_year < 1980 AND pub.publisher_id NOT IN (SELECT cr.publisher_id FROM copyright_infringements cr WHERE cr.infringement_date > '2023-01-01') AND EXISTS (SELECT 1 FROM publisher_genres pg JOIN genres g ON pg.genre_id = g.genre_id WHERE pg.publisher_id = pub.publisher_id AND g.genre_name = 'Fantasy') ORDER BY new_books_2023 DESC, annual_royalties_2023 DESC LIMIT 10;","output":"WITH PublisherBookStats AS (SELECT publisher_id, COUNT(book_id) AS new_books_2023 FROM books WHERE publication_year = 2023 GROUP BY publisher_id), PublisherRoyalties AS (SELECT publisher_id, SUM(royalty_amount) AS annual_royalties_2023 FROM sales_royalty WHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY publisher_id) SELECT pub.publisher_id, pub.publisher_name, pub.country, COALESCE(pbs.new_books_2023, 0) AS new_books_2023, COALESCE(pr.annual_royalties_2023, 0) AS annual_royalties_2023 FROM publishers AS pub LEFT JOIN PublisherBookStats AS pbs ON pub.publisher_id = pbs.publisher_id LEFT JOIN PublisherRoyalties AS pr ON pub.publisher_id = pr.publisher_id LEFT JOIN copyright_infringements AS ci ON pub.publisher_id = ci.publisher_id AND ci.infringement_date > '2023-01-01' JOIN publisher_genres AS pg ON pub.publisher_id = pg.publisher_id JOIN genres AS g ON pg.genre_id = g.genre_id WHERE pub.founding_year < 1980 AND ci.publisher_id IS NULL AND g.genre_name = 'Fantasy' ORDER BY new_books_2023 DESC, annual_royalties_2023 DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT co.customer_id, co.customer_name, co.city, (SELECT COUNT(o.order_id) FROM orders o WHERE o.customer_id = co.customer_id AND o.order_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_orders, (SELECT SUM(o.total_amount) FROM orders o WHERE o.customer_id = co.customer_id AND o.order_date BETWEEN '2023-01-01' AND '2023-03-31') AS Q1_total_spend FROM customers co WHERE co.registration_date > '2022-01-01' AND co.customer_type = 'Business' AND co.customer_id NOT IN (SELECT cb.customer_id FROM customer_blacklists cb WHERE cb.blacklist_date > '2023-01-01') AND EXISTS (SELECT 1 FROM customer_contracts cc WHERE cc.customer_id = co.customer_id AND cc.contract_status = 'Active') ORDER BY Q1_total_spend DESC, Q1_orders DESC LIMIT 15;","output":"WITH Q1CustomerStats AS (SELECT customer_id, COUNT(order_id) AS Q1_orders, SUM(total_amount) AS Q1_total_spend FROM orders WHERE order_date BETWEEN '2023-01-01' AND '2023-03-31' GROUP BY customer_id) SELECT co.customer_id, co.customer_name, co.city, COALESCE(qcs.Q1_orders, 0) AS Q1_orders, COALESCE(qcs.Q1_total_spend, 0) AS Q1_total_spend FROM customers AS co LEFT JOIN Q1CustomerStats AS qcs ON co.customer_id = qcs.customer_id LEFT JOIN customer_blacklists AS cb ON co.customer_id = cb.customer_id AND cb.blacklist_date > '2023-01-01' JOIN customer_contracts AS cc ON co.customer_id = cc.customer_id WHERE co.registration_date > '2022-01-01' AND co.customer_type = 'Business' AND cb.customer_id IS NULL AND cc.contract_status = 'Active' ORDER BY Q1_total_spend DESC, Q1_orders DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT ev.event_id, ev.event_name, ev.event_date, (SELECT COUNT(reg.registration_id) FROM event_registrations reg WHERE reg.event_id = ev.event_id AND reg.registration_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_registrations, (SELECT AVG(fb.satisfaction_score) FROM event_feedback fb WHERE fb.event_id = ev.event_id AND fb.feedback_date > '2023-01-01') AS avg_feedback_score FROM events ev WHERE ev.event_type = 'Webinar' AND ev.status = 'Completed' AND ev.event_date BETWEEN '2023-01-01' AND '2023-12-31' AND ev.event_id NOT IN (SELECT tech.event_id FROM technical_issues tech WHERE tech.issue_date > '2023-01-01') AND EXISTS (SELECT 1 FROM event_speakers es JOIN speakers s ON es.speaker_id = s.speaker_id WHERE es.event_id = ev.event_id AND s.specialization = 'Data Science') ORDER BY H1_registrations DESC, avg_feedback_score DESC LIMIT 10;","output":"WITH H1Registrations AS (SELECT event_id, COUNT(registration_id) AS H1_registrations FROM event_registrations WHERE registration_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY event_id), EventFeedback AS (SELECT event_id, AVG(satisfaction_score) AS avg_feedback_score FROM event_feedback WHERE feedback_date > '2023-01-01' GROUP BY event_id) SELECT ev.event_id, ev.event_name, ev.event_date, COALESCE(hr.H1_registrations, 0) AS H1_registrations, COALESCE(ef.avg_feedback_score, 0) AS avg_feedback_score FROM events AS ev LEFT JOIN H1Registrations AS hr ON ev.event_id = hr.event_id LEFT JOIN EventFeedback AS ef ON ev.event_id = ef.event_id LEFT JOIN technical_issues AS ti ON ev.event_id = ti.event_id AND ti.issue_date > '2023-01-01' JOIN event_speakers AS es ON ev.event_id = es.event_id JOIN speakers AS s ON es.speaker_id = s.speaker_id WHERE ev.event_type = 'Webinar' AND ev.status = 'Completed' AND ev.event_date BETWEEN '2023-01-01' AND '2023-12-31' AND ti.event_id IS NULL AND s.specialization = 'Data Science' ORDER BY H1_registrations DESC, avg_feedback_score DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT rep.report_id, rep.report_name, rep.report_type, rep.generation_date, (SELECT COUNT(dist.distribution_id) FROM report_distributions dist WHERE dist.report_id = rep.report_id AND dist.distribution_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_distributions, (SELECT AVG(usg.usage_count) FROM report_usage usg WHERE usg.report_id = rep.report_id AND usg.usage_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_avg_usage FROM reports rep WHERE rep.status = 'Published' AND rep.visibility = 'Public' AND rep.generation_date > '2022-01-01' AND rep.report_id NOT IN (SELECT err.report_id FROM report_errors err WHERE err.error_date > '2023-01-01') AND EXISTS (SELECT 1 FROM report_categories rc JOIN categories cat ON rc.category_id = cat.category_id WHERE rc.report_id = rep.report_id AND cat.category_name = 'Financial') ORDER BY H1_distributions DESC, H1_avg_usage DESC LIMIT 10;","output":"WITH H1Distributions AS (SELECT report_id, COUNT(distribution_id) AS H1_distributions FROM report_distributions WHERE distribution_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY report_id), H1Usage AS (SELECT report_id, AVG(usage_count) AS H1_avg_usage FROM report_usage WHERE usage_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY report_id) SELECT rep.report_id, rep.report_name, rep.report_type, rep.generation_date, COALESCE(hd.H1_distributions, 0) AS H1_distributions, COALESCE(hu.H1_avg_usage, 0) AS H1_avg_usage FROM reports AS rep LEFT JOIN H1Distributions AS hd ON rep.report_id = hd.report_id LEFT JOIN H1Usage AS hu ON rep.report_id = hu.report_id LEFT JOIN report_errors AS re ON rep.report_id = re.report_id AND re.error_date > '2023-01-01' JOIN report_categories AS rc ON rep.report_id = rc.report_id JOIN categories AS cat ON rc.category_id = cat.category_id WHERE rep.status = 'Published' AND rep.visibility = 'Public' AND rep.generation_date > '2022-01-01' AND re.report_id IS NULL AND cat.category_name = 'Financial' ORDER BY H1_distributions DESC, H1_avg_usage DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT em.employee_id, em.first_name, em.last_name, em.department_id, (SELECT COUNT(t.training_id) FROM employee_trainings t WHERE t.employee_id = em.employee_id AND t.completion_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_trainings_completed, (SELECT AVG(pf.score) FROM performance_feedback pf WHERE pf.employee_id = em.employee_id AND pf.feedback_date BETWEEN '2023-01-01' AND '2023-12-31') AS avg_performance_score FROM employees em WHERE em.status = 'Active' AND em.hire_date < '2020-01-01' AND em.employee_id NOT IN (SELECT cp.employee_id FROM disciplinary_cases cp WHERE cp.case_date > '2023-01-01' AND cp.severity = 'Termination') AND EXISTS (SELECT 1 FROM employee_skills es JOIN skills s ON es.skill_id = s.skill_id WHERE es.employee_id = em.employee_id AND s.skill_name = 'Project Management') ORDER BY annual_trainings_completed DESC, avg_performance_score DESC LIMIT 15;","output":"WITH AnnualTrainings AS (SELECT employee_id, COUNT(training_id) AS annual_trainings_completed FROM employee_trainings WHERE completion_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY employee_id), PerformanceScores AS (SELECT employee_id, AVG(score) AS avg_performance_score FROM performance_feedback WHERE feedback_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY employee_id) SELECT em.employee_id, em.first_name, em.last_name, em.department_id, COALESCE(at.annual_trainings_completed, 0) AS annual_trainings_completed, COALESCE(ps.avg_performance_score, 0) AS avg_performance_score FROM employees AS em LEFT JOIN AnnualTrainings AS at ON em.employee_id = at.employee_id LEFT JOIN PerformanceScores AS ps ON em.employee_id = ps.employee_id LEFT JOIN disciplinary_cases AS dc ON em.employee_id = dc.employee_id AND dc.case_date > '2023-01-01' AND dc.severity = 'Termination' JOIN employee_skills AS es ON em.employee_id = es.employee_id JOIN skills AS s ON es.skill_id = s.skill_id WHERE em.status = 'Active' AND em.hire_date < '2020-01-01' AND dc.employee_id IS NULL AND s.skill_name = 'Project Management' ORDER BY annual_trainings_completed DESC, avg_performance_score DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pub.publication_id, pub.title, pub.publisher, (SELECT COUNT(cit.citation_id) FROM citations cit WHERE cit.publication_id = pub.publication_id AND cit.citation_year = 2023) AS citations_2023, (SELECT AVG(met.impact_factor) FROM journal_metrics met WHERE met.publication_id = pub.publication_id AND met.metric_year = 2023) AS avg_impact_factor FROM publications pub WHERE pub.publication_type = 'Journal Article' AND pub.publication_year BETWEEN 2010 AND 2022 AND pub.publication_id NOT IN (SELECT pr.publication_id FROM retraction_notices pr WHERE pr.retraction_date > '2023-01-01') AND EXISTS (SELECT 1 FROM publication_authors pa JOIN authors au ON pa.author_id = au.author_id WHERE pa.publication_id = pub.publication_id AND au.academic_rank = 'Professor') ORDER BY citations_2023 DESC, avg_impact_factor DESC LIMIT 10;","output":"WITH PublicationCitationStats AS (SELECT publication_id, COUNT(citation_id) AS citations_2023 FROM citations WHERE citation_year = 2023 GROUP BY publication_id), ImpactFactors AS (SELECT publication_id, AVG(impact_factor) AS avg_impact_factor FROM journal_metrics WHERE metric_year = 2023 GROUP BY publication_id) SELECT pub.publication_id, pub.title, pub.publisher, COALESCE(pcs.citations_2023, 0) AS citations_2023, COALESCE(imf.avg_impact_factor, 0) AS avg_impact_factor FROM publications AS pub LEFT JOIN PublicationCitationStats AS pcs ON pub.publication_id = pcs.publication_id LEFT JOIN ImpactFactors AS imf ON pub.publication_id = imf.publication_id LEFT JOIN retraction_notices AS rn ON pub.publication_id = rn.publication_id AND rn.retraction_date > '2023-01-01' JOIN publication_authors AS pa ON pub.publication_id = pa.publication_id JOIN authors AS au ON pa.author_id = au.author_id WHERE pub.publication_type = 'Journal Article' AND pub.publication_year BETWEEN 2010 AND 2022 AND rn.publication_id IS NULL AND au.academic_rank = 'Professor' ORDER BY citations_2023 DESC, avg_impact_factor DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT pat.patient_id, pat.first_name, pat.last_name, pat.date_of_birth, (SELECT COUNT(diag.diagnosis_id) FROM diagnoses diag WHERE diag.patient_id = pat.patient_id AND diag.diagnosis_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_diagnoses_count, (SELECT MAX(med.prescription_date) FROM prescriptions med WHERE med.patient_id = pat.patient_id) AS last_prescription_date FROM patients pat WHERE pat.gender = 'Female' AND pat.age BETWEEN 30 AND 50 AND pat.patient_id NOT IN (SELECT adm.patient_id FROM admissions adm WHERE adm.admission_date > '2023-01-01' AND adm.reason = 'Emergency') AND EXISTS (SELECT 1 FROM patient_allergies pa WHERE pa.patient_id = pat.patient_id AND pa.allergy_type = 'Drug') ORDER BY H1_diagnoses_count DESC, last_prescription_date DESC LIMIT 10;","output":"WITH H1Diagnoses AS (SELECT patient_id, COUNT(diagnosis_id) AS H1_diagnoses_count FROM diagnoses WHERE diagnosis_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY patient_id), LastPrescription AS (SELECT patient_id, MAX(prescription_date) AS last_prescription_date FROM prescriptions GROUP BY patient_id) SELECT pat.patient_id, pat.first_name, pat.last_name, pat.date_of_birth, COALESCE(hd.H1_diagnoses_count, 0) AS H1_diagnoses_count, lpr.last_prescription_date FROM patients AS pat LEFT JOIN H1Diagnoses AS hd ON pat.patient_id = hd.patient_id LEFT JOIN LastPrescription AS lpr ON pat.patient_id = lpr.patient_id LEFT JOIN admissions AS adm ON pat.patient_id = adm.patient_id AND adm.admission_date > '2023-01-01' AND adm.reason = 'Emergency' JOIN patient_allergies AS pa ON pat.patient_id = pa.patient_id WHERE pat.gender = 'Female' AND pat.age BETWEEN 30 AND 50 AND adm.patient_id IS NULL AND pa.allergy_type = 'Drug' ORDER BY H1_diagnoses_count DESC, last_prescription_date DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT res.resource_id, res.resource_name, res.resource_type, (SELECT COUNT(b.booking_id) FROM bookings b WHERE b.resource_id = res.resource_id AND b.booking_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_bookings, (SELECT SUM(b.duration_hours) FROM bookings b WHERE b.resource_id = res.resource_id AND b.booking_date BETWEEN '2023-01-01' AND '2023-12-31') AS total_booking_hours FROM resources res WHERE res.status = 'Available' AND res.location = 'Main Campus' AND res.resource_id NOT IN (SELECT br.resource_id FROM breakage_reports br WHERE br.report_date > '2023-01-01') AND EXISTS (SELECT 1 FROM resource_tags rt JOIN tags t ON rt.tag_id = t.tag_id WHERE rt.resource_id = res.resource_id AND t.tag_name = 'High Demand') ORDER BY annual_bookings DESC, total_booking_hours DESC LIMIT 15;","output":"WITH ResourceBookingStats AS (SELECT resource_id, COUNT(booking_id) AS annual_bookings, SUM(duration_hours) AS total_booking_hours FROM bookings WHERE booking_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY resource_id) SELECT res.resource_id, res.resource_name, res.resource_type, COALESCE(rbs.annual_bookings, 0) AS annual_bookings, COALESCE(rbs.total_booking_hours, 0) AS total_booking_hours FROM resources AS res LEFT JOIN ResourceBookingStats AS rbs ON res.resource_id = rbs.resource_id LEFT JOIN breakage_reports AS br ON res.resource_id = br.resource_id AND br.report_date > '2023-01-01' JOIN resource_tags AS rt ON res.resource_id = rt.resource_id JOIN tags AS t ON rt.tag_id = t.tag_id WHERE res.status = 'Available' AND res.location = 'Main Campus' AND br.resource_id IS NULL AND t.tag_name = 'High Demand' ORDER BY annual_bookings DESC, total_booking_hours DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT tr.track_id, tr.track_name, tr.artist_name, tr.album_name, (SELECT COUNT(us.stream_id) FROM user_streams us WHERE us.track_id = tr.track_id AND us.stream_date BETWEEN '2023-01-01' AND '2023-06-30') AS H1_streams, (SELECT AVG(ur.rating_score) FROM user_ratings ur WHERE ur.track_id = tr.track_id AND ur.rating_date > '2023-01-01') AS avg_user_rating FROM tracks tr WHERE tr.genre = 'Pop' AND tr.release_year = 2023 AND tr.track_id NOT IN (SELECT pv.track_id FROM piracy_violations pv WHERE pv.violation_date > '2023-01-01') AND EXISTS (SELECT 1 FROM track_playlists tp JOIN playlists p ON tp.playlist_id = p.playlist_id WHERE tp.track_id = tr.track_id AND p.playlist_type = 'Editorial') ORDER BY H1_streams DESC, avg_user_rating DESC LIMIT 15;","output":"WITH H1Streams AS (SELECT track_id, COUNT(stream_id) AS H1_streams FROM user_streams WHERE stream_date BETWEEN '2023-01-01' AND '2023-06-30' GROUP BY track_id), AvgUserRating AS (SELECT track_id, AVG(rating_score) AS avg_user_rating FROM user_ratings WHERE rating_date > '2023-01-01' GROUP BY track_id) SELECT tr.track_id, tr.track_name, tr.artist_name, tr.album_name, COALESCE(hs.H1_streams, 0) AS H1_streams, COALESCE(aur.avg_user_rating, 0) AS avg_user_rating FROM tracks AS tr LEFT JOIN H1Streams AS hs ON tr.track_id = hs.track_id LEFT JOIN AvgUserRating AS aur ON tr.track_id = aur.track_id LEFT JOIN piracy_violations AS pv ON tr.track_id = pv.track_id AND pv.violation_date > '2023-01-01' JOIN track_playlists AS tp ON tr.track_id = tp.track_id JOIN playlists AS p ON tp.playlist_id = p.playlist_id WHERE tr.genre = 'Pop' AND tr.release_year = 2023 AND pv.track_id IS NULL AND p.playlist_type = 'Editorial' ORDER BY H1_streams DESC, avg_user_rating DESC LIMIT 15;"}
{"instruction":"Optimize the SQL query","input":"SELECT DISTINCT dev.developer_id, dev.developer_name, dev.specialty, (SELECT COUNT(app.app_id) FROM applications app WHERE app.developer_id = dev.developer_id AND app.release_date BETWEEN '2023-01-01' AND '2023-12-31') AS annual_app_releases, (SELECT AVG(ur.average_rating) FROM app_user_ratings ur JOIN applications app ON ur.app_id = app.app_id WHERE app.developer_id = dev.developer_id) AS avg_app_rating FROM developers dev WHERE dev.country = 'Japan' AND dev.years_experience > 5 AND dev.developer_id NOT IN (SELECT pr.developer_id FROM code_review_penalties pr WHERE pr.penalty_date > '2023-01-01') AND EXISTS (SELECT 1 FROM developer_platforms dp JOIN platforms p ON dp.platform_id = p.platform_id WHERE dp.developer_id = dev.developer_id AND p.platform_name = 'iOS') ORDER BY annual_app_releases DESC, avg_app_rating DESC LIMIT 10;","output":"WITH AnnualAppReleases AS (SELECT developer_id, COUNT(app_id) AS annual_app_releases FROM applications WHERE release_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY developer_id), AvgAppRating AS (SELECT app.developer_id, AVG(ur.average_rating) AS avg_app_rating FROM app_user_ratings AS ur JOIN applications AS app ON ur.app_id = app.app_id GROUP BY app.developer_id) SELECT dev.developer_id, dev.developer_name, dev.specialty, COALESCE(aar.annual_app_releases, 0) AS annual_app_releases, COALESCE(aar_avg.avg_app_rating, 0) AS avg_app_rating FROM developers AS dev LEFT JOIN AnnualAppReleases AS aar ON dev.developer_id = aar.developer_id LEFT JOIN AvgAppRating AS aar_avg ON dev.developer_id = aar_avg.developer_id LEFT JOIN code_review_penalties AS crp ON dev.developer_id = crp.developer_id AND crp.penalty_date > '2023-01-01' JOIN developer_platforms AS dp ON dev.developer_id = dp.developer_id JOIN platforms AS p ON dp.platform_id = p.platform_id WHERE dev.country = 'Japan' AND dev.years_experience > 5 AND crp.developer_id IS NULL AND p.platform_name = 'iOS' ORDER BY annual_app_releases DESC, avg_app_rating DESC LIMIT 10;"}
{"instruction":"Optimize the SQL query","input":"WITH RECURSIVE category_tree AS (SELECT category_id, category_name, parent_category_id, 1 as level FROM categories WHERE parent_category_id IS NULL UNION ALL SELECT c.category_id, c.category_name, c.parent_category_id, ct.level + 1 FROM categories c INNER JOIN category_tree ct ON c.parent_category_id = ct.category_id) SELECT ct.category_id, ct.category_name, ct.level, p.product_count, COALESCE(SUM(s.sales_amount), 0) as total_sales FROM category_tree ct LEFT JOIN (SELECT category_id, COUNT(*) as product_count FROM products WHERE discontinued = FALSE GROUP BY category_id) p ON ct.category_id = p.category_id LEFT JOIN (SELECT p.category_id, SUM(sd.quantity * sd.unit_price) as sales_amount FROM sales_details sd JOIN products p ON sd.product_id = p.product_id JOIN sales s ON sd.sale_id = s.sale_id WHERE s.sale_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY p.category_id) s ON ct.category_id = s.category_id WHERE ct.level <= 4 AND p.product_count > 0 ORDER BY ct.level, total_sales DESC","output":"WITH RECURSIVE category_tree AS (SELECT category_id, category_name, parent_category_id, 1 as level FROM categories WHERE parent_category_id IS NULL UNION ALL SELECT c.category_id, c.category_name, c.parent_category_id, ct.level + 1 FROM categories c INNER JOIN category_tree ct ON c.parent_category_id = ct.category_id) SELECT ct.category_id, ct.category_name, ct.level, p.product_count, COALESCE(SUM(s.sales_amount), 0) as total_sales FROM category_tree ct LEFT JOIN (SELECT category_id, COUNT(*) as product_count FROM products WHERE discontinued = false GROUP BY category_id) p ON ct.category_id = p.category_id LEFT JOIN (SELECT p.category_id, SUM(sd.quantity * sd.unit_price) as sales_amount FROM sales_details sd JOIN products p ON sd.product_id = p.product_id JOIN sales s ON sd.sale_id = s.sale_id WHERE s.sale_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY p.category_id) s ON ct.category_id = s.category_id WHERE ct.level <= 4 AND p.product_count > 0 ORDER BY ct.level, total_sales DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT customer_id, customer_name, email, registration_date, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.customer_id AND o.order_date >= CURRENT_DATE - INTERVAL '365 days') as orders_last_year, (SELECT SUM(total_amount) FROM orders o WHERE o.customer_id = c.customer_id AND o.status = 'completed') as lifetime_value, (SELECT MAX(order_date) FROM orders o WHERE o.customer_id = c.customer_id) as last_order_date, EXISTS(SELECT 1 FROM subscriptions s WHERE s.customer_id = c.customer_id AND s.status = 'active') as has_active_subscription, (SELECT STRING_AGG(DISTINCT category_name, ', ') FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id JOIN categories cat ON p.category_id = cat.category_id WHERE o.customer_id = c.customer_id) as purchased_categories FROM customers c WHERE registration_date > '2020-01-01' AND customer_id IN (SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(*) > 3 AND SUM(total_amount) > 500) ORDER BY lifetime_value DESC NULLS LAST LIMIT 100","output":"SELECT customer_id, customer_name, email, registration_date, (SELECT COUNT(*) FROM orders o WHERE o.customer_id = c.customer_id AND o.order_date >= CURRENT_DATE - INTERVAL '365 days') as orders_last_year, (SELECT SUM(total_amount) FROM orders o WHERE o.customer_id = c.customer_id AND o.status = 'completed') as lifetime_value, (SELECT MAX(order_date) FROM orders o WHERE o.customer_id = c.customer_id) as last_order_date, EXISTS(SELECT 1 FROM subscriptions s WHERE s.customer_id = c.customer_id AND s.status = 'active') as has_active_subscription, (SELECT STRING_AGG(DISTINCT category_name, ', ') FROM orders o JOIN order_items oi ON o.order_id = oi.order_id JOIN products p ON oi.product_id = p.product_id JOIN categories cat ON p.category_id = cat.category_id WHERE o.customer_id = c.customer_id) as purchased_categories FROM customers c WHERE registration_date > '2020-01-01' AND customer_id IN (SELECT customer_id FROM orders GROUP BY customer_id HAVING COUNT(*) > 3 AND SUM(total_amount) > 500) ORDER BY lifetime_value DESC NULLS LAST LIMIT 100"}
{"instruction":"Optimize the SQL query","input":"SELECT date_trunc('month', sale_date) as sales_month, product_category, region, SUM(sales_amount) as monthly_sales, AVG(SUM(sales_amount)) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date) ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING) as avg_prev_3_months, (SUM(sales_amount) - LAG(SUM(sales_amount), 1) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date))) / LAG(SUM(sales_amount), 1) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date))) * 100 as growth_rate, RANK() OVER (PARTITION BY date_trunc('month', sale_date), region ORDER BY SUM(sales_amount) DESC) as category_rank FROM sales_data WHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31' AND sales_amount > 0 GROUP BY date_trunc('month', sale_date), product_category, region HAVING SUM(sales_amount) > 10000 ORDER BY sales_month DESC, region, category_rank","output":"SELECT date_trunc('month', sale_date) as sales_month, product_category, region, SUM(sales_amount) as monthly_sales, AVG(SUM(sales_amount)) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date) ROWS BETWEEN 3 PRECEDING AND 1 PRECEDING) as avg_prev_3_months, (SUM(sales_amount) - LAG(SUM(sales_amount), 1) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date))) / LAG(SUM(sales_amount), 1) OVER (PARTITION BY product_category, region ORDER BY date_trunc('month', sale_date))) * 100 as growth_rate, RANK() OVER (PARTITION BY date_trunc('month', sale_date), region ORDER BY SUM(sales_amount) DESC) as category_rank FROM sales_data WHERE sale_date BETWEEN '2023-01-01' AND '2023-12-31' AND sales_amount > 0 GROUP BY date_trunc('month', sale_date), product_category, region HAVING SUM(sales_amount) > 10000 ORDER BY sales_month DESC, region, category_rank"}
{"instruction":"Optimize the SQL query","input":"SELECT employee_id, project_id, SUM(hours_worked) as total_hours, CASE WHEN SUM(hours_worked) > 160 THEN SUM(hours_worked) - 160 ELSE 0 END as overtime_hours, SUM(CASE WHEN billable = TRUE THEN hours_worked ELSE 0 END) as billable_hours, SUM(hours_worked * hourly_rate) as total_cost, SUM(CASE WHEN billable = TRUE THEN hours_worked * hourly_rate ELSE 0 END) as billable_cost, COUNT(DISTINCT task_id) as unique_tasks, MIN(work_date) as first_work_date, MAX(work_date) as last_work_date FROM time_entries WHERE work_date BETWEEN '2023-01-01' AND '2023-12-31' AND approved = TRUE GROUP BY employee_id, project_id HAVING SUM(hours_worked) > 0 AND COUNT(DISTINCT work_date) > 5 UNION ALL SELECT employee_id, NULL as project_id, SUM(hours_worked) as total_hours, CASE WHEN SUM(hours_worked) > 160 THEN SUM(hours_worked) - 160 ELSE 0 END as overtime_hours, SUM(CASE WHEN billable = TRUE THEN hours_worked ELSE 0 END) as billable_hours, SUM(hours_worked * hourly_rate) as total_cost, SUM(CASE WHEN billable = TRUE THEN hours_worked * hourly_rate ELSE 0 END) as billable_cost, COUNT(DISTINCT task_id) as unique_tasks, MIN(work_date) as first_work_date, MAX(work_date) as last_work_date FROM time_entries WHERE work_date BETWEEN '2023-01-01' AND '2023-12-31' AND approved = TRUE GROUP BY employee_id HAVING SUM(hours_worked) > 100 ORDER BY total_hours DESC","output":"SELECT employee_id, project_id, SUM(hours_worked) as total_hours, CASE WHEN SUM(hours_worked) > 160 THEN SUM(hours_worked) - 160 ELSE 0 END as overtime_hours, SUM(CASE WHEN billable = true THEN hours_worked ELSE 0 END) as billable_hours, SUM(hours_worked * hourly_rate) as total_cost, SUM(CASE WHEN billable = true THEN hours_worked * hourly_rate ELSE 0 END) as billable_cost, COUNT(DISTINCT task_id) as unique_tasks, MIN(work_date) as first_work_date, MAX(work_date) as last_work_date FROM time_entries WHERE work_date BETWEEN '2023-01-01' AND '2023-12-31' AND approved = true GROUP BY employee_id, project_id HAVING SUM(hours_worked) > 0 AND COUNT(DISTINCT work_date) > 5 UNION ALL SELECT employee_id, NULL as project_id, SUM(hours_worked) as total_hours, CASE WHEN SUM(hours_worked) > 160 THEN SUM(hours_worked) - 160 ELSE 0 END as overtime_hours, SUM(CASE WHEN billable = true THEN hours_worked ELSE 0 END) as billable_hours, SUM(hours_worked * hourly_rate) as total_cost, SUM(CASE WHEN billable = true THEN hours_worked * hourly_rate ELSE 0 END) as billable_cost, COUNT(DISTINCT task_id) as unique_tasks, MIN(work_date) as first_work_date, MAX(work_date) as last_work_date FROM time_entries WHERE work_date BETWEEN '2023-01-01' AND '2023-12-31' AND approved = true GROUP BY employee_id HAVING SUM(hours_worked) > 100 ORDER BY total_hours DESC"}
{"instruction":"Optimize the SQL query","input":"SELECT p.product_id, p.product_name, p.category_id, p.current_price, p.stock_quantity, COALESCE(SUM(oi.quantity), 0) as total_sold, COALESCE(SUM(oi.quantity * oi.unit_price), 0) as total_revenue, COALESCE(AVG(r.rating), 0) as avg_rating, COUNT(r.review_id) as review_count, COALESCE((SELECT STRING_AGG(DISTINCT s.supplier_name, ', ' ORDER BY s.supplier_name) FROM product_suppliers ps JOIN suppliers s ON ps.supplier_id = s.supplier_id WHERE ps.product_id = p.product_id), 'No supplier') as suppliers, EXISTS(SELECT 1 FROM product_discounts pd WHERE pd.product_id = p.product_id AND pd.start_date <= CURRENT_DATE AND pd.end_date >= CURRENT_DATE) as has_current_discount, (SELECT COUNT(*) FROM order_items oi2 JOIN orders o ON oi2.order_id = o.order_id WHERE oi2.product_id = p.product_id AND o.order_date >= CURRENT_DATE - INTERVAL '30 days') as last_30_days_sales FROM products p LEFT JOIN order_items oi ON p.product_id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.order_id LEFT JOIN reviews r ON p.product_id = r.product_id WHERE p.discontinued = FALSE AND p.stock_quantity > 0 GROUP BY p.product_id, p.product_name, p.category_id, p.current_price, p.stock_quantity HAVING COALESCE(SUM(oi.quantity), 0) > 10 AND COALESCE(AVG(r.rating), 0) >= 3.5 ORDER BY total_revenue DESC, avg_rating DESC LIMIT 50","output":"SELECT p.product_id, p.product_name, p.category_id, p.current_price, p.stock_quantity, COALESCE(SUM(oi.quantity), 0) as total_sold, COALESCE(SUM(oi.quantity * oi.unit_price), 0) as total_revenue, COALESCE(AVG(r.rating), 0) as avg_rating, COUNT(r.review_id) as review_count, COALESCE((SELECT STRING_AGG(DISTINCT s.supplier_name, ', ' ORDER BY s.supplier_name) FROM product_suppliers ps JOIN suppliers s ON ps.supplier_id = s.supplier_id WHERE ps.product_id = p.product_id), 'No supplier') as suppliers, EXISTS(SELECT 1 FROM product_discounts pd WHERE pd.product_id = p.product_id AND pd.start_date <= CURRENT_DATE AND pd.end_date >= CURRENT_DATE) as has_current_discount, (SELECT COUNT(*) FROM order_items oi2 JOIN orders o ON oi2.order_id = o.order_id WHERE oi2.product_id = p.product_id AND o.order_date >= CURRENT_DATE - INTERVAL '30 days') as last_30_days_sales FROM products p LEFT JOIN order_items oi ON p.product_id = oi.product_id LEFT JOIN orders o ON oi.order_id = o.order_id LEFT JOIN reviews r ON p.product_id = r.product_id WHERE p.discontinued = false AND p.stock_quantity > 0 GROUP BY p.product_id, p.product_name, p.category_id, p.current_price, p.stock_quantity HAVING COALESCE(SUM(oi.quantity), 0) > 10 AND COALESCE(AVG(r.rating), 0) >= 3.5 ORDER BY total_revenue DESC, avg_rating DESC LIMIT 50"}
